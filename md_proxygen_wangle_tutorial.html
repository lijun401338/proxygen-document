<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: Wangle Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_proxygen_wangle_tutorial.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Wangle Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Introduction</h2>
<p>The tutorial assumes that you have installed Wangle and its dependencies. The tutorial will demonstrate how to build an echo server - the "hello world" of distributed systems.</p>
<h2>What is Wangle?</h2>
<p>Wangle is a client/server application framework to build asynchronous, event-driven modern C++ services. The fundamental abstraction of Wangle is the Pipeline. Once you have fully understood this abstraction, you will be able to write all sorts of sophisticated modern C++ services. Another important abstraction is Service, which is an advanced version of a pipeline but it’s out of scope for this post.</p>
<h2>What is a Pipeline?</h2>
<p>The pipeline is the most important and powerful abstraction of Wangle. It offers immense flexibility to customize how requests and responses are handled by your service.</p>
<p><a class="el" href="structA.html">A</a> pipeline is a chain of request/response handlers that handle upstream (handling request) and downstream (handling response). Once you chain handlers together, it provides an agile way to convert a raw data stream into the desired message type (class) and the inverse &ndash; desired message type to raw data stream.</p>
<p><a class="el" href="structA.html">A</a> handler should do one and only one function - just like the UNIX philisophy. If you have a handler that is doing more than one function than you should split it into individual handlers. This is really important for maintainability and flexibility as its common to change your protocol for one reason or the other.</p>
<p>All shared state within handlers are not thread-safe. Only use shared state that is guarded by a mutex, atomic lock, etc. If you want to use a thread-safe container then it is recommended to use Folly's lock-free data structures, which can be easily imported because they are a dependency of Wangle and are blazing fast.</p>
<h2>Echo Server</h2>
<p>Now onto writing our first service with Wangle: the Echo Server.</p>
<p>Here's the main piece of code in our echo server; it receives a string, prints it to stdout and sends it back downstream in the pipeline. It's really important to add the line delimiter because our pipeline will use a line decoder.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// the main logic of our echo server; receives a string and writes it straight</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;// back</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;class EchoHandler : public HandlerAdapter&lt;std::string&gt; {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; public:</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  virtual void read(Context* ctx, std::string msg) override {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    std::cout &lt;&lt; &quot;handling &quot; &lt;&lt; msg &lt;&lt; std::endl;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    write(ctx, msg + &quot;\r\n&quot;);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  }</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;};</div></div><!-- fragment --><p>This needs to be the final handler in the pipeline. Now the definition of the pipeline is needed to handle the requests and responses.</p>
<div class="fragment"><div class="line"><span class="comment">// where we define the chain of handlers for each messeage received</span></div><div class="line"><span class="keyword">class </span><a class="code" href="classEchoPipelineFactory.html">EchoPipelineFactory</a> : <span class="keyword">public</span> PipelineFactory&lt;EchoPipeline&gt; {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <a class="code" href="classwangle_1_1Pipeline.html#aa0c634cc788fff073a02093442791dd0">EchoPipeline::Ptr</a> <a class="code" href="classEchoPipelineFactory.html#abff986aff1c73ae383a44269bf6fc9fe">newPipeline</a>(std::shared_ptr&lt;AsyncTransportWrapper&gt; sock) {</div><div class="line">    <span class="keyword">auto</span> pipeline = <a class="code" href="classwangle_1_1Pipeline.html#a45b3093b82d7407466ea9a1cb4b43270">EchoPipeline::create</a>();</div><div class="line">    pipeline-&gt;addBack(AsyncSocketHandler(sock));</div><div class="line">    pipeline-&gt;addBack(LineBasedFrameDecoder(8192));</div><div class="line">    pipeline-&gt;addBack(StringCodec());</div><div class="line">    pipeline-&gt;addBack(<a class="code" href="classEchoHandler.html">EchoHandler</a>());</div><div class="line">    pipeline-&gt;finalize();</div><div class="line">    <span class="keywordflow">return</span> pipeline;</div><div class="line">  }</div><div class="line"> };</div></div><!-- fragment --><p>It is <b>very</b> important to be strict in the order of insertion as they are ordered by insertion. The pipeline has 4 handlers:</p>
<ul>
<li><b>AsyncSocketHandler</b><ul>
<li>Upstream: Reads a raw data stream from the socket and converts it into a zero-copy byte buffer.</li>
<li>Downstream: Writes the contents of a zero-copy byte buffer to the underlying socket.</li>
</ul>
</li>
<li><b>LineBasedFrameDecoder</b><ul>
<li>Upstream: receives a zero-copy byte buffer and splits on line-endings</li>
<li>Downstream: just passes the byte buffer to AsyncSocketHandler</li>
</ul>
</li>
<li><b>StringCodec</b><ul>
<li>Upstream: receives a byte buffer and decodes it into a std::string and pass up to the <a class="el" href="classEchoHandler.html">EchoHandler</a>.</li>
<li>Downstream: receives a std::string and encodes it into a byte buffer and pass down to the LineBasedFrameDecoder.</li>
</ul>
</li>
<li><b><a class="el" href="classEchoHandler.html">EchoHandler</a></b><ul>
<li>Upstream: receives a std::string and writes it to the pipeline — which will send the message downstream.</li>
<li>Downstream: receives a std::string and forwards it to StringCodec.</li>
</ul>
</li>
</ul>
<p>Now that all needs to be done is plug the pipeline factory into a ServerBootstrap and that’s pretty much it. Bind a port and wait for it to stop.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;gflags/gflags.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ServerBootstrap_8h.html">wangle/bootstrap/ServerBootstrap.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="AsyncSocketHandler_8h.html">wangle/channel/AsyncSocketHandler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="LineBasedFrameDecoder_8h.html">wangle/codec/LineBasedFrameDecoder.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="StringCodec_8h.html">wangle/codec/StringCodec.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacefolly.html">folly</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacewangle.html">wangle</a>;</div><div class="line"></div><div class="line"><a class="code" href="GFlags_8h.html#a2350cb40fca07ee482649d6c8b558eb5">DEFINE_int32</a>(port, 8080, <span class="stringliteral">&quot;echo server port&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classwangle_1_1Pipeline.html">Pipeline&lt;IOBufQueue&amp;, std::string&gt;</a> <a class="code" href="EchoClient_8cpp.html#af9c61de6b15825a304a23cd29b6782d1">EchoPipeline</a>;</div><div class="line"></div><div class="line"><span class="comment">// the main logic of our echo server; receives a string and writes it straight</span></div><div class="line"><span class="comment">// back</span></div><div class="line"><span class="keyword">class </span>EchoHandler : <span class="keyword">public</span> <a class="code" href="classwangle_1_1HandlerAdapter.html">HandlerAdapter</a>&lt;std::string&gt; {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespacefizz_1_1detail.html#a36dc6280bf4d04bce115a7055a78abac">read</a>(Context* ctx, <a class="code" href="Conv_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> msg)<span class="keyword"> override </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;handling &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</div><div class="line">    <a class="code" href="namespacefizz_1_1detail.html#a40ead2543c07ad500214ec9dd760b706">write</a>(ctx, msg + <span class="stringliteral">&quot;\r\n&quot;</span>);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// where we define the chain of handlers for each message received</span></div><div class="line"><span class="keyword">class </span>EchoPipelineFactory : <span class="keyword">public</span> <a class="code" href="classwangle_1_1PipelineFactory.html">PipelineFactory</a>&lt;EchoPipeline&gt; {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <a class="code" href="classwangle_1_1Pipeline.html#aa0c634cc788fff073a02093442791dd0">EchoPipeline::Ptr</a> newPipeline(std::shared_ptr&lt;AsyncTransportWrapper&gt; sock) {</div><div class="line">    <span class="keyword">auto</span> pipeline = <a class="code" href="classwangle_1_1Pipeline.html#a45b3093b82d7407466ea9a1cb4b43270">EchoPipeline::create</a>();</div><div class="line">    pipeline-&gt;addBack(<a class="code" href="classwangle_1_1AsyncSocketHandler.html">AsyncSocketHandler</a>(sock));</div><div class="line">    pipeline-&gt;addBack(<a class="code" href="classwangle_1_1LineBasedFrameDecoder.html">LineBasedFrameDecoder</a>(8192));</div><div class="line">    pipeline-&gt;addBack(<a class="code" href="classwangle_1_1StringCodec.html">StringCodec</a>());</div><div class="line">    pipeline-&gt;addBack(EchoHandler());</div><div class="line">    pipeline-&gt;finalize();</div><div class="line">    <span class="keywordflow">return</span> pipeline;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="test_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** <a class="code" href="SmallLocksBenchmark_8cpp.html#af2efa898e9eed6fe6715279cb1ec35b0">argv</a>) {</div><div class="line">  gflags::ParseCommandLineFlags(&amp;argc, &amp;argv, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classwangle_1_1ServerBootstrap.html">ServerBootstrap&lt;EchoPipeline&gt;</a> server;</div><div class="line">  server.<a class="code" href="classwangle_1_1ServerBootstrap.html#a5d11ae2956da87fbb915f8f4ceb6159c">childPipeline</a>(std::make_shared&lt;EchoPipelineFactory&gt;());</div><div class="line">  server.<a class="code" href="classwangle_1_1ServerBootstrap.html#ae47d4fa61849e52689a3b0d7d300fa58">bind</a>(FLAGS_port);</div><div class="line">  server.<a class="code" href="classwangle_1_1ServerBootstrap.html#a6e644e40f873dd4e4ecc66d11615fdc4">waitForStop</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>We've written an asynchronous C++ server in under 48 LOC.</p>
<h2>Echo Client</h2>
<p>The code for the echo client is very similar to the Echo Server. Here is the main echo handler.</p>
<div class="fragment"><div class="line"><span class="comment">// the handler for receiving messages back from the server</span></div><div class="line"><span class="keyword">class </span><a class="code" href="classEchoHandler.html">EchoHandler</a> : <span class="keyword">public</span> HandlerAdapter&lt;std::string&gt; {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classwangle_1_1HandlerAdapter.html#a4460e0996a43c6344fc4bbeecc00781b">read</a>(<a class="code" href="classwangle_1_1HandlerAdapter.html#a5be1553a6694cf313ec6b1269a888cbb">Context</a>* ctx, <a class="code" href="Conv_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> msg)<span class="keyword"> override </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;received back: &quot;</span> &lt;&lt; msg;</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classwangle_1_1Handler.html#a23464ca2246187f35affaef6eb3d56a7">readException</a>(<a class="code" href="classwangle_1_1HandlerAdapter.html#a5be1553a6694cf313ec6b1269a888cbb">Context</a>* ctx, exception_wrapper e)<span class="keyword"> override </span>{</div><div class="line">    std::cout &lt;&lt; <a class="code" href="namespacefolly.html#acb103e15fafef3561273c07f9f9d705d">exceptionStr</a>(e) &lt;&lt; std::endl;</div><div class="line">    <a class="code" href="classwangle_1_1Handler.html#ac83a9d2432a59793ab7392f57dd17918">close</a>(ctx);</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classwangle_1_1Handler.html#a6a6e60eef72535ead17764a6e8713cd7">readEOF</a>(<a class="code" href="classwangle_1_1HandlerAdapter.html#a5be1553a6694cf313ec6b1269a888cbb">Context</a>* ctx)<span class="keyword"> override </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;EOF received :(&quot;</span> &lt;&lt; std::endl;</div><div class="line">    <a class="code" href="classwangle_1_1Handler.html#ac83a9d2432a59793ab7392f57dd17918">close</a>(ctx);</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>Notice that we override other methods — readException and readEOF. There are few other methods that can be overriden. If you need to handle a particular event, just override the corresponding virtual method.</p>
<p>Now onto the client’s pipeline factory. It is identical the server’s pipeline factory apart from _EventBaseHandler_ — which handles writing data from an event loop thread.</p>
<div class="fragment"><div class="line"><span class="comment">// chains the handlers together to define the response pipeline</span></div><div class="line"><span class="keyword">class </span><a class="code" href="classEchoPipelineFactory.html">EchoPipelineFactory</a> : <span class="keyword">public</span> PipelineFactory&lt;EchoPipeline&gt; {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <a class="code" href="classwangle_1_1Pipeline.html#aa0c634cc788fff073a02093442791dd0">EchoPipeline::Ptr</a> <a class="code" href="classwangle_1_1PipelineFactory.html#a497bea0fa737959be573fcb8362d3c51">newPipeline</a>(std::shared_ptr&lt;AsyncTransportWrapper&gt; sock) {</div><div class="line">    <span class="keyword">auto</span> pipeline = <a class="code" href="classwangle_1_1Pipeline.html#a45b3093b82d7407466ea9a1cb4b43270">EchoPipeline::create</a>();</div><div class="line">    pipeline-&gt;addBack(AsyncSocketHandler(sock));</div><div class="line">    pipeline-&gt;addBack(</div><div class="line">       EventBaseHandler()); <span class="comment">// ensure we can write from any thread</span></div><div class="line">    pipeline-&gt;addBack(LineBasedFrameDecoder(8192, <span class="keyword">false</span>));</div><div class="line">    pipeline-&gt;addBack(StringCodec());</div><div class="line">    pipeline-&gt;addBack(<a class="code" href="classEchoHandler.html">EchoHandler</a>());</div><div class="line">    pipeline-&gt;finalize();</div><div class="line">    <span class="keywordflow">return</span> pipeline;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>What does it looks like when it is all put together for the client?</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;gflags/gflags.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ClientBootstrap_8h.html">wangle/bootstrap/ClientBootstrap.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="AsyncSocketHandler_8h.html">wangle/channel/AsyncSocketHandler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="EventBaseHandler_8h.html">wangle/channel/EventBaseHandler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="LineBasedFrameDecoder_8h.html">wangle/codec/LineBasedFrameDecoder.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="StringCodec_8h.html">wangle/codec/StringCodec.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacefolly.html">folly</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacewangle.html">wangle</a>;</div><div class="line"></div><div class="line"><a class="code" href="GFlags_8h.html#a2350cb40fca07ee482649d6c8b558eb5">DEFINE_int32</a>(port, 8080, <span class="stringliteral">&quot;echo server port&quot;</span>);</div><div class="line"><a class="code" href="GFlags_8h.html#ad4c219d4bfccbad3275aef7ed336c559">DEFINE_string</a>(host, <span class="stringliteral">&quot;::1&quot;</span>, <span class="stringliteral">&quot;echo server address&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classwangle_1_1Pipeline.html">Pipeline&lt;folly::IOBufQueue&amp;, std::string&gt;</a> <a class="code" href="EchoClient_8cpp.html#af9c61de6b15825a304a23cd29b6782d1">EchoPipeline</a>;</div><div class="line"></div><div class="line"><span class="comment">// the handler for receiving messages back from the server</span></div><div class="line"><span class="keyword">class </span>EchoHandler : <span class="keyword">public</span> <a class="code" href="classwangle_1_1HandlerAdapter.html">HandlerAdapter</a>&lt;std::string&gt; {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespacefizz_1_1detail.html#a36dc6280bf4d04bce115a7055a78abac">read</a>(Context* ctx, <a class="code" href="Conv_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> msg)<span class="keyword"> override </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;received back: &quot;</span> &lt;&lt; msg;</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> readException(Context* ctx, <a class="code" href="classfolly_1_1exception__wrapper.html">exception_wrapper</a> e)<span class="keyword"> override </span>{</div><div class="line">    std::cout &lt;&lt; <a class="code" href="namespacefolly.html#acb103e15fafef3561273c07f9f9d705d">exceptionStr</a>(e) &lt;&lt; std::endl;</div><div class="line">    <a class="code" href="namespacefolly_1_1netops.html#a27d9201e6386937ffded3bfd86f995aa">close</a>(ctx);</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> readEOF(Context* ctx)<span class="keyword"> override </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;EOF received :(&quot;</span> &lt;&lt; std::endl;</div><div class="line">    <a class="code" href="namespacefolly_1_1netops.html#a27d9201e6386937ffded3bfd86f995aa">close</a>(ctx);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// chains the handlers together to define the response pipeline</span></div><div class="line"><span class="keyword">class </span>EchoPipelineFactory : <span class="keyword">public</span> <a class="code" href="classwangle_1_1PipelineFactory.html">PipelineFactory</a>&lt;EchoPipeline&gt; {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <a class="code" href="classwangle_1_1Pipeline.html#aa0c634cc788fff073a02093442791dd0">EchoPipeline::Ptr</a> newPipeline(std::shared_ptr&lt;AsyncTransportWrapper&gt; sock) {</div><div class="line">    <span class="keyword">auto</span> pipeline = <a class="code" href="classwangle_1_1Pipeline.html#a45b3093b82d7407466ea9a1cb4b43270">EchoPipeline::create</a>();</div><div class="line">    pipeline-&gt;addBack(<a class="code" href="classwangle_1_1AsyncSocketHandler.html">AsyncSocketHandler</a>(sock));</div><div class="line">    pipeline-&gt;addBack(</div><div class="line">        <a class="code" href="classwangle_1_1EventBaseHandler.html">EventBaseHandler</a>()); <span class="comment">// ensure we can write from any thread</span></div><div class="line">    pipeline-&gt;addBack(<a class="code" href="classwangle_1_1LineBasedFrameDecoder.html">LineBasedFrameDecoder</a>(8192, <span class="keyword">false</span>));</div><div class="line">    pipeline-&gt;addBack(<a class="code" href="classwangle_1_1StringCodec.html">StringCodec</a>());</div><div class="line">    pipeline-&gt;addBack(EchoHandler());</div><div class="line">    pipeline-&gt;finalize();</div><div class="line">    <span class="keywordflow">return</span> pipeline;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="test_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">  gflags::ParseCommandLineFlags(&amp;argc, &amp;argv, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classwangle_1_1ClientBootstrap.html">ClientBootstrap&lt;EchoPipeline&gt;</a> client;</div><div class="line">  client.<a class="code" href="classwangle_1_1ClientBootstrap.html#a2bd7eeec619ff961c67b50a8437f9d12">group</a>(std::make_shared&lt;folly::IOThreadPoolExecutor&gt;(1));</div><div class="line">  client.<a class="code" href="classwangle_1_1BaseClientBootstrap.html#a4754c5a6fa01c83be529e69d9394d760">pipelineFactory</a>(std::make_shared&lt;EchoPipelineFactory&gt;());</div><div class="line">  <span class="keyword">auto</span> pipeline = client.<a class="code" href="classwangle_1_1ClientBootstrap.html#ab3324c4a034ab322de0143319f02ceac">connect</a>(<a class="code" href="classfolly_1_1SocketAddress.html">SocketAddress</a>(FLAGS_host, FLAGS_port)).get();</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span> {</div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div><div class="line">      <a class="code" href="Conv_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> line;</div><div class="line">      <a class="code" href="FBStringTestBenchmarks_8cpp_8h.html#aab53918abdd9d731c31cc8983181984a">std::getline</a>(std::cin, line);</div><div class="line">      <span class="keywordflow">if</span> (line == <span class="stringliteral">&quot;&quot;</span>) {</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line"></div><div class="line">      pipeline-&gt;write(line + <span class="stringliteral">&quot;\r\n&quot;</span>).get();</div><div class="line">      <span class="keywordflow">if</span> (line == <span class="stringliteral">&quot;bye&quot;</span>) {</div><div class="line">        pipeline-&gt;close();</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div><div class="line">    std::cout &lt;&lt; <a class="code" href="namespacefolly.html#acb103e15fafef3561273c07f9f9d705d">exceptionStr</a>(e) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>It reads input from stdin in a loop and writes it to the pipeline and it blocks until the response is processed. It blocks by calling .<a class="el" href="namespacefolly_1_1pushmi_1_1operators.html#a3fb4b634ea259cf94b63687a25b3f505">get()</a> from the returned future.</p>
<h2>Summary</h2>
<p>This quick tutorial has shown how to quickly write a basic service in modern C++ using Wangle. You should now know the fundamentals of Wangle and it should give you confidence to write your own service in C++. It is strongly recommend to understand the Service abstraction once you are comfortable with using the Pipeline as you can build sophisticated servers with it. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
