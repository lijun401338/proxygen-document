<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: folly::AtomicUnorderedInsertMap&lt; Key, Value, Hash, KeyEqual, SkipKeyValueDeletion, Atom, IndexType, Allocator &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structfolly_1_1AtomicUnorderedInsertMap.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="structfolly_1_1AtomicUnorderedInsertMap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">folly::AtomicUnorderedInsertMap&lt; Key, Value, Hash, KeyEqual, SkipKeyValueDeletion, Atom, IndexType, Allocator &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap_1_1ConstIterator.html">ConstIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html">Slot</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aef357877c75bcddac9604cc1a065da52"><td class="memItemLeft" align="right" valign="top">typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#aef357877c75bcddac9604cc1a065da52">key_type</a></td></tr>
<tr class="separator:aef357877c75bcddac9604cc1a065da52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145e85a5040dc7d7d371709585aaf50f"><td class="memItemLeft" align="right" valign="top">typedef Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a145e85a5040dc7d7d371709585aaf50f">mapped_type</a></td></tr>
<tr class="separator:a145e85a5040dc7d7d371709585aaf50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae935b2a3a141e2fd0756b2e390bb15eb"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; Key, Value &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#ae935b2a3a141e2fd0756b2e390bb15eb">value_type</a></td></tr>
<tr class="separator:ae935b2a3a141e2fd0756b2e390bb15eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55008bfa07cf9f15102689ad014247b2"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a55008bfa07cf9f15102689ad014247b2">size_type</a></td></tr>
<tr class="separator:a55008bfa07cf9f15102689ad014247b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637189a7f20e2889f22a2c58c0a3a55b"><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a637189a7f20e2889f22a2c58c0a3a55b">difference_type</a></td></tr>
<tr class="separator:a637189a7f20e2889f22a2c58c0a3a55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6563f7fe0c0e732691656713fc3f15"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structfolly_1_1Hash.html">Hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a1b6563f7fe0c0e732691656713fc3f15">hasher</a></td></tr>
<tr class="separator:a1b6563f7fe0c0e732691656713fc3f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cef714563f90f682d36cc054e4ae65"><td class="memItemLeft" align="right" valign="top">typedef KeyEqual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a48cef714563f90f682d36cc054e4ae65">key_equal</a></td></tr>
<tr class="separator:a48cef714563f90f682d36cc054e4ae65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356609ede717d0a7bd3e48b3cbc8a7be"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#ae935b2a3a141e2fd0756b2e390bb15eb">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a356609ede717d0a7bd3e48b3cbc8a7be">const_reference</a></td></tr>
<tr class="separator:a356609ede717d0a7bd3e48b3cbc8a7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bebe3f75a8062990401e3c8e65a201d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap_1_1ConstIterator.html">folly::AtomicUnorderedInsertMap::ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a4bebe3f75a8062990401e3c8e65a201d">const_iterator</a></td></tr>
<tr class="separator:a4bebe3f75a8062990401e3c8e65a201d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3c2c6dbdd013d6578b92bc745216007b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a3c2c6dbdd013d6578b92bc745216007b">AtomicUnorderedInsertMap</a> (size_t maxSize, float maxLoadFactor=0.8f, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:a3c2c6dbdd013d6578b92bc745216007b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ee6d0b5102b83f7e0006924344898c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#ab0ee6d0b5102b83f7e0006924344898c">~AtomicUnorderedInsertMap</a> ()</td></tr>
<tr class="separator:ab0ee6d0b5102b83f7e0006924344898c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dab52b569e8fab476f24a3667eda8e9"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a6dab52b569e8fab476f24a3667eda8e9"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a4bebe3f75a8062990401e3c8e65a201d">const_iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a6dab52b569e8fab476f24a3667eda8e9">findOrConstruct</a> (const Key &amp;key, <a class="el" href="namespacefolly.html#a4f345dd5f9b26d8dd202c2072badbea8">Func</a> &amp;&amp;func)</td></tr>
<tr class="separator:a6dab52b569e8fab476f24a3667eda8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16e13302551e88ca263efdfe552e997"><td class="memTemplParams" colspan="2">template&lt;class K , class V &gt; </td></tr>
<tr class="memitem:ac16e13302551e88ca263efdfe552e997"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a4bebe3f75a8062990401e3c8e65a201d">const_iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#ac16e13302551e88ca263efdfe552e997">emplace</a> (const K &amp;key, V &amp;&amp;<a class="el" href="namespacefolly.html#af765fccfa9242184196b4906286ada49">value</a>)</td></tr>
<tr class="separator:ac16e13302551e88ca263efdfe552e997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e5a07cad12ab93500d3ba5d0bf8f67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a4bebe3f75a8062990401e3c8e65a201d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a88e5a07cad12ab93500d3ba5d0bf8f67">find</a> (const Key &amp;key) const </td></tr>
<tr class="separator:a88e5a07cad12ab93500d3ba5d0bf8f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b8a99257c2c70f38b15a3897854e1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a4bebe3f75a8062990401e3c8e65a201d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a15b8a99257c2c70f38b15a3897854e1f">cbegin</a> () const </td></tr>
<tr class="separator:a15b8a99257c2c70f38b15a3897854e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b241b7c57010ce9c31cc901db327b48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a4bebe3f75a8062990401e3c8e65a201d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a5b241b7c57010ce9c31cc901db327b48">cend</a> () const </td></tr>
<tr class="separator:a5b241b7c57010ce9c31cc901db327b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:adc84cf3dfc351c132aa3be5a69188379"><td class="memItemLeft" align="right" valign="top">friend&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#adc84cf3dfc351c132aa3be5a69188379">ConstIterator</a></td></tr>
<tr class="separator:adc84cf3dfc351c132aa3be5a69188379"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a4dd2aef08b32dbda3722ad73cfec9302"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: IndexType { <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a4dd2aef08b32dbda3722ad73cfec9302a00125a055494a77d28d71a859e3bd7e1">kMaxAllocationTries</a> = 1000
 }</td></tr>
<tr class="separator:a4dd2aef08b32dbda3722ad73cfec9302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b78eb039cb12dc31ee2a439b3687f49"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49">BucketState</a> : IndexType { <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49a52da358213f42cf4a3c5a49d7bc341f4">EMPTY</a> = 0, 
<a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49a23fa1eef2e52738379ddf160c0902358">CONSTRUCTING</a> = 1, 
<a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49af2c6e81a3eea9a24ed750572fbbc6efd">LINKED</a> = 2
 }</td></tr>
<tr class="separator:a3b78eb039cb12dc31ee2a439b3687f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a1271cf50f435f979877337341b3b5d7e"><td class="memItemLeft" align="right" valign="top">IndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a1271cf50f435f979877337341b3b5d7e">keyToSlotIdx</a> (const Key &amp;key) const </td></tr>
<tr class="separator:a1271cf50f435f979877337341b3b5d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba4340071b29c7d2f654076fb8a56aa"><td class="memItemLeft" align="right" valign="top">IndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#afba4340071b29c7d2f654076fb8a56aa">find</a> (const Key &amp;key, IndexType slot) const </td></tr>
<tr class="separator:afba4340071b29c7d2f654076fb8a56aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55606b1cfb3c3b0f8e601adca272b8ba"><td class="memItemLeft" align="right" valign="top">IndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a55606b1cfb3c3b0f8e601adca272b8ba">allocateNear</a> (IndexType <a class="el" href="ParallelBenchmark_8cpp.html#a7f02a749754f40365411f74cf75d08fa">start</a>)</td></tr>
<tr class="separator:a55606b1cfb3c3b0f8e601adca272b8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fad5584d5a29be5c0363f6f6337f974"><td class="memItemLeft" align="right" valign="top">IndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a5fad5584d5a29be5c0363f6f6337f974">allocationAttempt</a> (IndexType <a class="el" href="ParallelBenchmark_8cpp.html#a7f02a749754f40365411f74cf75d08fa">start</a>, IndexType tries) const </td></tr>
<tr class="separator:a5fad5584d5a29be5c0363f6f6337f974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18bd284e1e769bda86a90b7f0de2737a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a18bd284e1e769bda86a90b7f0de2737a">zeroFillSlots</a> ()</td></tr>
<tr class="separator:a18bd284e1e769bda86a90b7f0de2737a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a85a267cad149b1aef6f1e610bf716136"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a85a267cad149b1aef6f1e610bf716136">mmapRequested_</a></td></tr>
<tr class="separator:a85a267cad149b1aef6f1e610bf716136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e070ff2f0fbd9b659cfecad65560b8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a38e070ff2f0fbd9b659cfecad65560b8">numSlots_</a></td></tr>
<tr class="separator:a38e070ff2f0fbd9b659cfecad65560b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7290e9069fafa49a4d98e30cbcaca506"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a7290e9069fafa49a4d98e30cbcaca506">slotMask_</a></td></tr>
<tr class="memdesc:a7290e9069fafa49a4d98e30cbcaca506"><td class="mdescLeft">&#160;</td><td class="mdescRight">tricky, see keyToSlodIdx  <a href="#a7290e9069fafa49a4d98e30cbcaca506">More...</a><br /></td></tr>
<tr class="separator:a7290e9069fafa49a4d98e30cbcaca506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafda6d155af1b74a66fbfecf6b3cdf2"><td class="memItemLeft" align="right" valign="top">Allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#aaafda6d155af1b74a66fbfecf6b3cdf2">allocator_</a></td></tr>
<tr class="separator:aaafda6d155af1b74a66fbfecf6b3cdf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2e49b3357289b3394a71e942c09f94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html">Slot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">slots_</a></td></tr>
<tr class="separator:aca2e49b3357289b3394a71e942c09f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt;<br />
struct folly::AtomicUnorderedInsertMap&lt; Key, Value, Hash, KeyEqual, SkipKeyValueDeletion, Atom, IndexType, Allocator &gt;</h3>

<p>You're probably reading this because you are looking for an AtomicUnorderedMap&lt;K,V&gt; that is fully general, highly concurrent (for reads, writes, and iteration), and makes no performance compromises. We haven't figured that one out yet. What you will find here is a hash table implementation that sacrifices generality so that it can give you all of the other things.</p>
<p>LIMITATIONS:</p>
<ul>
<li>Insert only (*) - the only write operation supported directly by <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">AtomicUnorderedInsertMap</a> is findOrConstruct. There is a (*) because values aren't moved, so you can roll your own concurrency control for in-place updates of values (see <a class="el" href="structfolly_1_1MutableData.html">MutableData</a> and <a class="el" href="structfolly_1_1MutableAtom.html">MutableAtom</a> below), but the hash table itself doesn't help you.</li>
<li>No resizing - you must specify the capacity up front, and once the hash map gets full you won't be able to insert. Insert performance will degrade once the load factor is high. Insert is O(1/(1-actual_load_factor)). Note that this is a pretty strong limitation, because you can't remove existing keys.</li>
<li>2^30 maximum default capacity - by default <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">AtomicUnorderedInsertMap</a> uses uint32_t internal indexes (and steals 2 bits), limiting you to about a billion entries. If you need more you can fill in all of the template params so you change IndexType to uint64_t, or you can use AtomicUnorderedInsertMap64. 64-bit indexes will increase the space over of the map, of course.</li>
</ul>
<p>WHAT YOU GET IN EXCHANGE:</p>
<ul>
<li>Arbitrary key and value types - any K and V that can be used in a std::unordered_map can be used here. In fact, the key and value types don't even have to be copyable or moveable!</li>
<li>Keys and values in the map won't be moved - it is safe to keep pointers or references to the keys and values in the map, because they are never moved or destroyed (until the map itself is destroyed).</li>
<li>Iterators are never invalidated - writes don't invalidate iterators, so you can scan and insert in parallel.</li>
<li>Fast wait-free reads - reads are usually only a single cache miss, even when the hash table is very large. Wait-freedom means that you won't see latency outliers even in the face of concurrent writes.</li>
<li>Lock-free insert - writes proceed in parallel. If a thread in the middle of a write is unlucky and gets suspended, it doesn't block anybody else.</li>
</ul>
<p>COMMENTS ON INSERT-ONLY</p>
<p>This map provides wait-free linearizable reads and lock-free linearizable inserts. Inserted values won't be moved, but no concurrency control is provided for safely updating them. To remind you of that fact they are only provided in const form. This is the only simple safe thing to do while preserving something like the normal std::map iteration form, which requires that iteration be exposed via std::pair (and prevents encapsulation of access to the value).</p>
<p>There are a couple of reasonable policies for doing in-place concurrency control on the values. I am hoping that the policy can be injected via the value type or an extra template param, to keep the core <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">AtomicUnorderedInsertMap</a> insert-only:</p>
<p>CONST: this is the currently implemented strategy, which is simple, performant, and not that expressive. You can always put in a value with a mutable field (see <a class="el" href="structfolly_1_1MutableAtom.html">MutableAtom</a> below), but that doesn't look as pretty as it should.</p>
<p>ATOMIC: for integers and integer-size trivially copyable structs (via an adapter like tao/queues/AtomicStruct) the value can be a std::atomic and read and written atomically.</p>
<p>SEQ-LOCK: attach a counter incremented before and after write. Writers serialize by using CAS to make an even-&gt;odd transition, then odd-&gt;even after the write. Readers grab the value with memcpy, checking sequence value before and after. Readers retry until they see an even sequence number that doesn't change. This works for larger structs, but still requires memcpy to be equivalent to copy assignment, and it is no longer lock-free. It scales very well, because the readers are still invisible (no cache line writes).</p>
<p>LOCK: folly's SharedMutex would be a good choice here.</p>
<p>MEMORY ALLOCATION</p>
<p>Underlying memory is allocated as a big anonymous mmap chunk, which might be cheaper than calloc() and is certainly not more expensive for large maps. If the SkipKeyValueDeletion template param is true then deletion of the map consists of unmapping the backing memory, which is much faster than destructing all of the keys and values. Feel free to override if std::is_trivial_destructor isn't recognizing the triviality of your destructors. </p>

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00144">144</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a4bebe3f75a8062990401e3c8e65a201d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap_1_1ConstIterator.html">folly::AtomicUnorderedInsertMap::ConstIterator</a>  <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::<a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a4bebe3f75a8062990401e3c8e65a201d">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a356609ede717d0a7bd3e48b3cbc8a7be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#ae935b2a3a141e2fd0756b2e390bb15eb">value_type</a>&amp; <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::<a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a356609ede717d0a7bd3e48b3cbc8a7be">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00152">152</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

</div>
</div>
<a class="anchor" id="a637189a7f20e2889f22a2c58c0a3a55b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::<a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a637189a7f20e2889f22a2c58c0a3a55b">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00149">149</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1b6563f7fe0c0e732691656713fc3f15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structfolly_1_1Hash.html">Hash</a> <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::<a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a1b6563f7fe0c0e732691656713fc3f15">hasher</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00150">150</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

</div>
</div>
<a class="anchor" id="a48cef714563f90f682d36cc054e4ae65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KeyEqual <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::<a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a48cef714563f90f682d36cc054e4ae65">key_equal</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00151">151</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

</div>
</div>
<a class="anchor" id="aef357877c75bcddac9604cc1a065da52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Key <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::<a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#aef357877c75bcddac9604cc1a065da52">key_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00145">145</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

</div>
</div>
<a class="anchor" id="a145e85a5040dc7d7d371709585aaf50f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Value <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::<a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a145e85a5040dc7d7d371709585aaf50f">mapped_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00146">146</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

</div>
</div>
<a class="anchor" id="a55008bfa07cf9f15102689ad014247b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::<a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a55008bfa07cf9f15102689ad014247b2">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00148">148</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae935b2a3a141e2fd0756b2e390bb15eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;Key, Value&gt; <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::<a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#ae935b2a3a141e2fd0756b2e390bb15eb">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00147">147</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a4dd2aef08b32dbda3722ad73cfec9302"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : IndexType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a4dd2aef08b32dbda3722ad73cfec9302a00125a055494a77d28d71a859e3bd7e1"></a>kMaxAllocationTries&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00337">337</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;       : IndexType {</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a4dd2aef08b32dbda3722ad73cfec9302a00125a055494a77d28d71a859e3bd7e1">kMaxAllocationTries</a> = 1000, <span class="comment">// after this we throw</span></div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;  };</div><div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a4dd2aef08b32dbda3722ad73cfec9302a00125a055494a77d28d71a859e3bd7e1"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a4dd2aef08b32dbda3722ad73cfec9302a00125a055494a77d28d71a859e3bd7e1">folly::AtomicUnorderedInsertMap::kMaxAllocationTries</a></div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00338">AtomicUnorderedMap.h:338</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3b78eb039cb12dc31ee2a439b3687f49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49">folly::AtomicUnorderedInsertMap::BucketState</a> : IndexType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a3b78eb039cb12dc31ee2a439b3687f49a52da358213f42cf4a3c5a49d7bc341f4"></a>EMPTY&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3b78eb039cb12dc31ee2a439b3687f49a23fa1eef2e52738379ddf160c0902358"></a>CONSTRUCTING&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3b78eb039cb12dc31ee2a439b3687f49af2c6e81a3eea9a24ed750572fbbc6efd"></a>LINKED&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00341">341</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;                   : IndexType {</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49a52da358213f42cf4a3c5a49d7bc341f4">EMPTY</a> = 0,</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49a23fa1eef2e52738379ddf160c0902358">CONSTRUCTING</a> = 1,</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49af2c6e81a3eea9a24ed750572fbbc6efd">LINKED</a> = 2,</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;  };</div><div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a3b78eb039cb12dc31ee2a439b3687f49af2c6e81a3eea9a24ed750572fbbc6efd"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49af2c6e81a3eea9a24ed750572fbbc6efd">folly::AtomicUnorderedInsertMap::LINKED</a></div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00344">AtomicUnorderedMap.h:344</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a3b78eb039cb12dc31ee2a439b3687f49a23fa1eef2e52738379ddf160c0902358"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49a23fa1eef2e52738379ddf160c0902358">folly::AtomicUnorderedInsertMap::CONSTRUCTING</a></div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00343">AtomicUnorderedMap.h:343</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a3b78eb039cb12dc31ee2a439b3687f49a52da358213f42cf4a3c5a49d7bc341f4"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49a52da358213f42cf4a3c5a49d7bc341f4">folly::AtomicUnorderedInsertMap::EMPTY</a></div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00342">AtomicUnorderedMap.h:342</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3c2c6dbdd013d6578b92bc745216007b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::<a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">AtomicUnorderedInsertMap</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxLoadFactor</em> = <code>0.8f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a map that will support the insertion of maxSize key-value pairs without exceeding the max load factor. Load factors of greater than 1 are not supported, and once the actual load factor of the map approaches 1 the insert performance will suffer. The capacity is limited to 2^30 (about a billion) for the default IndexType, beyond which we will throw invalid_argument. </p>

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00207">207</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

<p>References <a class="el" href="PushmiBenchmarks_8cpp_source.html#l00515">f</a>, <a class="el" href="LogLevel_8cpp_source.html#l00030">min</a>, and <a class="el" href="lang_2Bits_8h_source.html#l00149">folly::nextPowTwo()</a>.</p>
<div class="fragment"><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;      : <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aaafda6d155af1b74a66fbfecf6b3cdf2">allocator_</a>(alloc) {</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    <span class="keywordtype">size_t</span> capacity = size_t(maxSize / <a class="code" href="LogLevel_8cpp.html#a7361901234703a521a82885405734c53">std::min</a>(1.0<a class="code" href="PushmiBenchmarks_8cpp.html#ad94c2c2f9fd35a12cc099962b7540071">f</a>, maxLoadFactor) + 128);</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    <span class="keywordtype">size_t</span> avail = <span class="keywordtype">size_t</span>{1} &lt;&lt; (8 * <span class="keyword">sizeof</span>(IndexType) - 2);</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    <span class="keywordflow">if</span> (capacity &gt; avail &amp;&amp; maxSize &lt; avail) {</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;      <span class="comment">// we&#39;ll do our best</span></div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;      capacity = avail;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    }</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    <span class="keywordflow">if</span> (capacity &lt; maxSize || capacity &gt; avail) {</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;      <span class="keywordflow">throw</span> std::invalid_argument(</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;          <span class="stringliteral">&quot;AtomicUnorderedInsertMap capacity must fit in IndexType with 2 bits &quot;</span></div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;          <span class="stringliteral">&quot;left over&quot;</span>);</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    }</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a38e070ff2f0fbd9b659cfecad65560b8">numSlots_</a> = capacity;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a7290e9069fafa49a4d98e30cbcaca506">slotMask_</a> = <a class="code" href="namespacefolly.html#a2cf0e35381650449b689518c5e885f44">folly::nextPowTwo</a>(capacity * 4) - 1;</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;    <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a85a267cad149b1aef6f1e610bf716136">mmapRequested_</a> = <span class="keyword">sizeof</span>(Slot) * capacity;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">slots_</a> = <span class="keyword">reinterpret_cast&lt;</span>Slot*<span class="keyword">&gt;</span>(<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aaafda6d155af1b74a66fbfecf6b3cdf2">allocator_</a>.allocate(<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a85a267cad149b1aef6f1e610bf716136">mmapRequested_</a>));</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a18bd284e1e769bda86a90b7f0de2737a">zeroFillSlots</a>();</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    <span class="comment">// mark the zero-th slot as in-use but not valid, since that happens</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    <span class="comment">// to be our nil value</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">slots_</a>[0].<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html#ab90179dfb15f54ffff359765bc5e7767">stateUpdate</a>(<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49a52da358213f42cf4a3c5a49d7bc341f4">EMPTY</a>, <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49a23fa1eef2e52738379ddf160c0902358">CONSTRUCTING</a>);</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;  }</div><div class="ttc" id="PushmiBenchmarks_8cpp_html_ad94c2c2f9fd35a12cc099962b7540071"><div class="ttname"><a href="PushmiBenchmarks_8cpp.html#ad94c2c2f9fd35a12cc099962b7540071">f</a></div><div class="ttdeci">auto f</div><div class="ttdef"><b>Definition:</b> <a href="PushmiBenchmarks_8cpp_source.html#l00515">PushmiBenchmarks.cpp:515</a></div></div>
<div class="ttc" id="namespacefolly_html_a2cf0e35381650449b689518c5e885f44"><div class="ttname"><a href="namespacefolly.html#a2cf0e35381650449b689518c5e885f44">folly::nextPowTwo</a></div><div class="ttdeci">constexpr T nextPowTwo(T const v)</div><div class="ttdef"><b>Definition:</b> <a href="lang_2Bits_8h_source.html#l00149">Bits.h:149</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_aaafda6d155af1b74a66fbfecf6b3cdf2"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#aaafda6d155af1b74a66fbfecf6b3cdf2">folly::AtomicUnorderedInsertMap::allocator_</a></div><div class="ttdeci">Allocator allocator_</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00407">AtomicUnorderedMap.h:407</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot_html_ab90179dfb15f54ffff359765bc5e7767"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html#ab90179dfb15f54ffff359765bc5e7767">folly::AtomicUnorderedInsertMap::Slot::stateUpdate</a></div><div class="ttdeci">void stateUpdate(BucketState before, BucketState after)</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00381">AtomicUnorderedMap.h:381</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a18bd284e1e769bda86a90b7f0de2737a"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a18bd284e1e769bda86a90b7f0de2737a">folly::AtomicUnorderedInsertMap::zeroFillSlots</a></div><div class="ttdeci">void zeroFillSlots()</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00463">AtomicUnorderedMap.h:463</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a38e070ff2f0fbd9b659cfecad65560b8"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a38e070ff2f0fbd9b659cfecad65560b8">folly::AtomicUnorderedInsertMap::numSlots_</a></div><div class="ttdeci">size_t numSlots_</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00402">AtomicUnorderedMap.h:402</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a85a267cad149b1aef6f1e610bf716136"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a85a267cad149b1aef6f1e610bf716136">folly::AtomicUnorderedInsertMap::mmapRequested_</a></div><div class="ttdeci">size_t mmapRequested_</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00401">AtomicUnorderedMap.h:401</a></div></div>
<div class="ttc" id="LogLevel_8cpp_html_a7361901234703a521a82885405734c53"><div class="ttname"><a href="LogLevel_8cpp.html#a7361901234703a521a82885405734c53">min</a></div><div class="ttdeci">LogLevel min</div><div class="ttdef"><b>Definition:</b> <a href="LogLevel_8cpp_source.html#l00030">LogLevel.cpp:30</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a3b78eb039cb12dc31ee2a439b3687f49a23fa1eef2e52738379ddf160c0902358"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49a23fa1eef2e52738379ddf160c0902358">folly::AtomicUnorderedInsertMap::CONSTRUCTING</a></div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00343">AtomicUnorderedMap.h:343</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_aca2e49b3357289b3394a71e942c09f94"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">folly::AtomicUnorderedInsertMap::slots_</a></div><div class="ttdeci">Slot * slots_</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00408">AtomicUnorderedMap.h:408</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a3b78eb039cb12dc31ee2a439b3687f49a52da358213f42cf4a3c5a49d7bc341f4"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49a52da358213f42cf4a3c5a49d7bc341f4">folly::AtomicUnorderedInsertMap::EMPTY</a></div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00342">AtomicUnorderedMap.h:342</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a7290e9069fafa49a4d98e30cbcaca506"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a7290e9069fafa49a4d98e30cbcaca506">folly::AtomicUnorderedInsertMap::slotMask_</a></div><div class="ttdeci">size_t slotMask_</div><div class="ttdoc">tricky, see keyToSlodIdx </div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00405">AtomicUnorderedMap.h:405</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab0ee6d0b5102b83f7e0006924344898c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::~<a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">AtomicUnorderedInsertMap</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00234">234</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

<p>References <a class="el" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt_source.html#l00083">i</a>.</p>
<div class="fragment"><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;                              {</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    <span class="keywordflow">if</span> (!SkipKeyValueDeletion) {</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> = 1; <a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> &lt; <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a38e070ff2f0fbd9b659cfecad65560b8">numSlots_</a>; ++<a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>) {</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">slots_</a>[<a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>].<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html#a1148ebaa5ea94234f37076c1cf08b9e4">~Slot</a>();</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;      }</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    }</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aaafda6d155af1b74a66fbfecf6b3cdf2">allocator_</a>.deallocate(reinterpret_cast&lt;char*&gt;(<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">slots_</a>), <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a85a267cad149b1aef6f1e610bf716136">mmapRequested_</a>);</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;  }</div><div class="ttc" id="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt_html_a7e98b8a17c0aad30ba64d47b74e2a6c1"><div class="ttname"><a href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a></div><div class="ttdeci">i</div><div class="ttdef"><b>Definition:</b> <a href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt_source.html#l00083">gtest_output_test_golden_lin.txt:83</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_aaafda6d155af1b74a66fbfecf6b3cdf2"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#aaafda6d155af1b74a66fbfecf6b3cdf2">folly::AtomicUnorderedInsertMap::allocator_</a></div><div class="ttdeci">Allocator allocator_</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00407">AtomicUnorderedMap.h:407</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a38e070ff2f0fbd9b659cfecad65560b8"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a38e070ff2f0fbd9b659cfecad65560b8">folly::AtomicUnorderedInsertMap::numSlots_</a></div><div class="ttdeci">size_t numSlots_</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00402">AtomicUnorderedMap.h:402</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot_html_a1148ebaa5ea94234f37076c1cf08b9e4"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html#a1148ebaa5ea94234f37076c1cf08b9e4">folly::AtomicUnorderedInsertMap::Slot::~Slot</a></div><div class="ttdeci">~Slot()</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00368">AtomicUnorderedMap.h:368</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a85a267cad149b1aef6f1e610bf716136"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a85a267cad149b1aef6f1e610bf716136">folly::AtomicUnorderedInsertMap::mmapRequested_</a></div><div class="ttdeci">size_t mmapRequested_</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00401">AtomicUnorderedMap.h:401</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_aca2e49b3357289b3394a71e942c09f94"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">folly::AtomicUnorderedInsertMap::slots_</a></div><div class="ttdeci">Slot * slots_</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00408">AtomicUnorderedMap.h:408</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a55606b1cfb3c3b0f8e601adca272b8ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IndexType <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::allocateNear </td>
          <td>(</td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a slot and returns its index. Tries to put it near slots_[start]. </p>

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00432">432</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

<p>References <a class="el" href="AtomicUnorderedMap_8h_source.html#l00359">folly::AtomicUnorderedInsertMap&lt; Key, Value, Hash, KeyEqual, SkipKeyValueDeletion, Atom, IndexType, Allocator &gt;::Slot::headAndState_</a>.</p>
<div class="fragment"><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;                                          {</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    <span class="keywordflow">for</span> (IndexType tries = 0; tries &lt; <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a4dd2aef08b32dbda3722ad73cfec9302a00125a055494a77d28d71a859e3bd7e1">kMaxAllocationTries</a>; ++tries) {</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;      <span class="keyword">auto</span> slot = <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a5fad5584d5a29be5c0363f6f6337f974">allocationAttempt</a>(<a class="code" href="ParallelBenchmark_8cpp.html#a7f02a749754f40365411f74cf75d08fa">start</a>, tries);</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;      <span class="keyword">auto</span> prev = <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">slots_</a>[slot].<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html#afd7aae4c621d3c766fc147acc4c3ca12">headAndState_</a>.load(std::memory_order_acquire);</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;      <span class="keywordflow">if</span> ((prev &amp; 3) == <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49a52da358213f42cf4a3c5a49d7bc341f4">EMPTY</a> &amp;&amp;</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;          <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">slots_</a>[slot].headAndState_.compare_exchange_strong(</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;              prev, prev + <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49a23fa1eef2e52738379ddf160c0902358">CONSTRUCTING</a> - <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49a52da358213f42cf4a3c5a49d7bc341f4">EMPTY</a>)) {</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;        <span class="keywordflow">return</span> slot;</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;      }</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;    }</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;    <span class="keywordflow">throw</span> std::bad_alloc();</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;  }</div><div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a3b78eb039cb12dc31ee2a439b3687f49a23fa1eef2e52738379ddf160c0902358"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49a23fa1eef2e52738379ddf160c0902358">folly::AtomicUnorderedInsertMap::CONSTRUCTING</a></div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00343">AtomicUnorderedMap.h:343</a></div></div>
<div class="ttc" id="ParallelBenchmark_8cpp_html_a7f02a749754f40365411f74cf75d08fa"><div class="ttname"><a href="ParallelBenchmark_8cpp.html#a7f02a749754f40365411f74cf75d08fa">start</a></div><div class="ttdeci">auto start</div><div class="ttdef"><b>Definition:</b> <a href="ParallelBenchmark_8cpp_source.html#l00083">ParallelBenchmark.cpp:83</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a5fad5584d5a29be5c0363f6f6337f974"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a5fad5584d5a29be5c0363f6f6337f974">folly::AtomicUnorderedInsertMap::allocationAttempt</a></div><div class="ttdeci">IndexType allocationAttempt(IndexType start, IndexType tries) const </div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00448">AtomicUnorderedMap.h:448</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot_html_afd7aae4c621d3c766fc147acc4c3ca12"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html#afd7aae4c621d3c766fc147acc4c3ca12">folly::AtomicUnorderedInsertMap::Slot::headAndState_</a></div><div class="ttdeci">Atom&lt; IndexType &gt; headAndState_</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00359">AtomicUnorderedMap.h:359</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_aca2e49b3357289b3394a71e942c09f94"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">folly::AtomicUnorderedInsertMap::slots_</a></div><div class="ttdeci">Slot * slots_</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00408">AtomicUnorderedMap.h:408</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a4dd2aef08b32dbda3722ad73cfec9302a00125a055494a77d28d71a859e3bd7e1"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a4dd2aef08b32dbda3722ad73cfec9302a00125a055494a77d28d71a859e3bd7e1">folly::AtomicUnorderedInsertMap::kMaxAllocationTries</a></div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00338">AtomicUnorderedMap.h:338</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a3b78eb039cb12dc31ee2a439b3687f49a52da358213f42cf4a3c5a49d7bc341f4"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49a52da358213f42cf4a3c5a49d7bc341f4">folly::AtomicUnorderedInsertMap::EMPTY</a></div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00342">AtomicUnorderedMap.h:342</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5fad5584d5a29be5c0363f6f6337f974"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IndexType <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::allocationAttempt </td>
          <td>(</td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>tries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the slot we should attempt to allocate after tries failed tries, starting from the specified slot. This is pulled out so we can specialize it differently during deterministic testing </p>

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00448">448</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

<p>References <a class="el" href="Likely_8h_source.html#l00047">LIKELY</a>, <a class="el" href="Random_8h_source.html#l00213">folly::Random::rand32()</a>, and <a class="el" href="Random_8h_source.html#l00263">folly::Random::rand64()</a>.</p>
<div class="fragment"><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;                                                                      {</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="Likely_8h.html#affde14445f49f65ff4f5b592e44ee71a">LIKELY</a>(tries &lt; 8 &amp;&amp; <a class="code" href="ParallelBenchmark_8cpp.html#a7f02a749754f40365411f74cf75d08fa">start</a> + tries &lt; <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a38e070ff2f0fbd9b659cfecad65560b8">numSlots_</a>)) {</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;      <span class="keywordflow">return</span> IndexType(<a class="code" href="ParallelBenchmark_8cpp.html#a7f02a749754f40365411f74cf75d08fa">start</a> + tries);</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;      IndexType rv;</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;      <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(IndexType) &lt;= 4) {</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;        rv = IndexType(<a class="code" href="classfolly_1_1Random.html#a3174852323fb3668d33b487f17fe7adc">folly::Random::rand32</a>(<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a38e070ff2f0fbd9b659cfecad65560b8">numSlots_</a>));</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;      } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;        rv = IndexType(<a class="code" href="classfolly_1_1Random.html#adc938dafb30c22c229689f65247b1deb">folly::Random::rand64</a>(<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a38e070ff2f0fbd9b659cfecad65560b8">numSlots_</a>));</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;      }</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;      assert(rv &lt; <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a38e070ff2f0fbd9b659cfecad65560b8">numSlots_</a>);</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;      <span class="keywordflow">return</span> rv;</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;    }</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;  }</div><div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a38e070ff2f0fbd9b659cfecad65560b8"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a38e070ff2f0fbd9b659cfecad65560b8">folly::AtomicUnorderedInsertMap::numSlots_</a></div><div class="ttdeci">size_t numSlots_</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00402">AtomicUnorderedMap.h:402</a></div></div>
<div class="ttc" id="Likely_8h_html_affde14445f49f65ff4f5b592e44ee71a"><div class="ttname"><a href="Likely_8h.html#affde14445f49f65ff4f5b592e44ee71a">LIKELY</a></div><div class="ttdeci">#define LIKELY(x)</div><div class="ttdef"><b>Definition:</b> <a href="Likely_8h_source.html#l00047">Likely.h:47</a></div></div>
<div class="ttc" id="ParallelBenchmark_8cpp_html_a7f02a749754f40365411f74cf75d08fa"><div class="ttname"><a href="ParallelBenchmark_8cpp.html#a7f02a749754f40365411f74cf75d08fa">start</a></div><div class="ttdeci">auto start</div><div class="ttdef"><b>Definition:</b> <a href="ParallelBenchmark_8cpp_source.html#l00083">ParallelBenchmark.cpp:83</a></div></div>
<div class="ttc" id="classfolly_1_1Random_html_a3174852323fb3668d33b487f17fe7adc"><div class="ttname"><a href="classfolly_1_1Random.html#a3174852323fb3668d33b487f17fe7adc">folly::Random::rand32</a></div><div class="ttdeci">static uint32_t rand32()</div><div class="ttdef"><b>Definition:</b> <a href="Random_8h_source.html#l00213">Random.h:213</a></div></div>
<div class="ttc" id="classfolly_1_1Random_html_adc938dafb30c22c229689f65247b1deb"><div class="ttname"><a href="classfolly_1_1Random.html#adc938dafb30c22c229689f65247b1deb">folly::Random::rand64</a></div><div class="ttdeci">static uint64_t rand64()</div><div class="ttdef"><b>Definition:</b> <a href="Random_8h_source.html#l00263">Random.h:263</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a15b8a99257c2c70f38b15a3897854e1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a4bebe3f75a8062990401e3c8e65a201d">const_iterator</a> <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00324">324</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;                                {</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    IndexType slot = <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a38e070ff2f0fbd9b659cfecad65560b8">numSlots_</a> - 1;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;    <span class="keywordflow">while</span> (slot &gt; 0 &amp;&amp; <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">slots_</a>[slot].<a class="code" href="http__parser_8c.html#adc6e5733fc3c22f0a7b2914188c49c90">state</a>() != <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49af2c6e81a3eea9a24ed750572fbbc6efd">LINKED</a>) {</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;      --slot;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    }</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#adc84cf3dfc351c132aa3be5a69188379">ConstIterator</a>(*<span class="keyword">this</span>, slot);</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;  }</div><div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a38e070ff2f0fbd9b659cfecad65560b8"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a38e070ff2f0fbd9b659cfecad65560b8">folly::AtomicUnorderedInsertMap::numSlots_</a></div><div class="ttdeci">size_t numSlots_</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00402">AtomicUnorderedMap.h:402</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a3b78eb039cb12dc31ee2a439b3687f49af2c6e81a3eea9a24ed750572fbbc6efd"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49af2c6e81a3eea9a24ed750572fbbc6efd">folly::AtomicUnorderedInsertMap::LINKED</a></div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00344">AtomicUnorderedMap.h:344</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_aca2e49b3357289b3394a71e942c09f94"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">folly::AtomicUnorderedInsertMap::slots_</a></div><div class="ttdeci">Slot * slots_</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00408">AtomicUnorderedMap.h:408</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_adc84cf3dfc351c132aa3be5a69188379"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#adc84cf3dfc351c132aa3be5a69188379">folly::AtomicUnorderedInsertMap::ConstIterator</a></div><div class="ttdeci">friend ConstIterator</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00199">AtomicUnorderedMap.h:199</a></div></div>
<div class="ttc" id="http__parser_8c_html_adc6e5733fc3c22f0a7b2914188c49c90"><div class="ttname"><a href="http__parser_8c.html#adc6e5733fc3c22f0a7b2914188c49c90">state</a></div><div class="ttdeci">state</div><div class="ttdef"><b>Definition:</b> <a href="http__parser_8c_source.html#l00272">http_parser.c:272</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5b241b7c57010ce9c31cc901db327b48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a4bebe3f75a8062990401e3c8e65a201d">const_iterator</a> <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00332">332</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

<p>Referenced by <a class="el" href="AtomicUnorderedMapTest_8cpp_source.html#l00201">TEST()</a>.</p>
<div class="fragment"><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                              {</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#adc84cf3dfc351c132aa3be5a69188379">ConstIterator</a>(*<span class="keyword">this</span>, 0);</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;  }</div><div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_adc84cf3dfc351c132aa3be5a69188379"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#adc84cf3dfc351c132aa3be5a69188379">folly::AtomicUnorderedInsertMap::ConstIterator</a></div><div class="ttdeci">friend ConstIterator</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00199">AtomicUnorderedMap.h:199</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac16e13302551e88ca263efdfe552e997"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
<div class="memtemplate">
template&lt;class K , class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a4bebe3f75a8062990401e3c8e65a201d">const_iterator</a>, bool&gt; <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This isn't really emplace, but it is what we need to test. Eventually we can duplicate all of the std::pair constructor forms, including a recursive tuple forwarding template <a href="http://functionalcpp.wordpress.com/2013/08/28/tuple-forwarding/">http://functionalcpp.wordpress.com/2013/08/28/tuple-forwarding/</a>). </p>

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00315">315</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

<p>References <a class="el" href="LockFreeRingBufferTest_8cpp_source.html#l00096">folly::value()</a>, and <a class="el" href="fizz_2build___2gtest_2src_2gtest_2googlemock_2include_2gmock_2gmock-matchers_8h_source.html#l04347">testing::Value()</a>.</p>

<p>Referenced by <a class="el" href="AtomicUnorderedMapTest_8cpp_source.html#l00366">BENCHMARK()</a>, <a class="el" href="AtomicUnorderedMapTest_8cpp_source.html#l00156">TEST()</a>, and <a class="el" href="AtomicUnorderedMapTest_8cpp_source.html#l00178">TYPED_TEST()</a>.</p>
<div class="fragment"><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                                                                 {</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a6dab52b569e8fab476f24a3667eda8e9">findOrConstruct</a>(</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;        key, [&amp;](<span class="keywordtype">void</span>* raw) { <span class="keyword">new</span> (raw) <a class="code" href="namespacetesting.html#ae44c50a3a7f0a46f05c8a0b0592b4a62">Value</a>(std::forward&lt;V&gt;(<a class="code" href="namespacefolly.html#af765fccfa9242184196b4906286ada49">value</a>)); });</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;  }</div><div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a6dab52b569e8fab476f24a3667eda8e9"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a6dab52b569e8fab476f24a3667eda8e9">folly::AtomicUnorderedInsertMap::findOrConstruct</a></div><div class="ttdeci">std::pair&lt; const_iterator, bool &gt; findOrConstruct(const Key &amp;key, Func &amp;&amp;func)</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00263">AtomicUnorderedMap.h:263</a></div></div>
<div class="ttc" id="namespacetesting_html_ae44c50a3a7f0a46f05c8a0b0592b4a62"><div class="ttname"><a href="namespacetesting.html#ae44c50a3a7f0a46f05c8a0b0592b4a62">testing::Value</a></div><div class="ttdeci">bool Value(const T &amp;value, M matcher)</div><div class="ttdef"><b>Definition:</b> <a href="fizz_2build___2gtest_2src_2gtest_2googlemock_2include_2gmock_2gmock-matchers_8h_source.html#l04347">gmock-matchers.h:4347</a></div></div>
<div class="ttc" id="namespacefolly_html_af765fccfa9242184196b4906286ada49"><div class="ttname"><a href="namespacefolly.html#af765fccfa9242184196b4906286ada49">folly::value</a></div><div class="ttdeci">uint64_t value(const typename LockFreeRingBuffer&lt; T, Atom &gt;::Cursor &amp;rbcursor)</div><div class="ttdef"><b>Definition:</b> <a href="LockFreeRingBufferTest_8cpp_source.html#l00096">LockFreeRingBufferTest.cpp:96</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a88e5a07cad12ab93500d3ba5d0bf8f67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a4bebe3f75a8062990401e3c8e65a201d">const_iterator</a> <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00320">320</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

<p>Referenced by <a class="el" href="AtomicUnorderedMapTest_8cpp_source.html#l00366">BENCHMARK()</a>, <a class="el" href="AtomicUnorderedMapTest_8cpp_source.html#l00188">TEST()</a>, and <a class="el" href="AtomicUnorderedMapTest_8cpp_source.html#l00178">TYPED_TEST()</a>.</p>
<div class="fragment"><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;                                            {</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#adc84cf3dfc351c132aa3be5a69188379">ConstIterator</a>(*<span class="keyword">this</span>, <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a88e5a07cad12ab93500d3ba5d0bf8f67">find</a>(key, <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a1271cf50f435f979877337341b3b5d7e">keyToSlotIdx</a>(key)));</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;  }</div><div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a1271cf50f435f979877337341b3b5d7e"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a1271cf50f435f979877337341b3b5d7e">folly::AtomicUnorderedInsertMap::keyToSlotIdx</a></div><div class="ttdeci">IndexType keyToSlotIdx(const Key &amp;key) const </div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00410">AtomicUnorderedMap.h:410</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_adc84cf3dfc351c132aa3be5a69188379"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#adc84cf3dfc351c132aa3be5a69188379">folly::AtomicUnorderedInsertMap::ConstIterator</a></div><div class="ttdeci">friend ConstIterator</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00199">AtomicUnorderedMap.h:199</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a88e5a07cad12ab93500d3ba5d0bf8f67"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a88e5a07cad12ab93500d3ba5d0bf8f67">folly::AtomicUnorderedInsertMap::find</a></div><div class="ttdeci">const_iterator find(const Key &amp;key) const </div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00320">AtomicUnorderedMap.h:320</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afba4340071b29c7d2f654076fb8a56aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IndexType <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00419">419</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

<p>References <a class="el" href="Base-inl_8h_source.html#l02553">folly::gen::first</a>, <a class="el" href="AtomicUnorderedMap_8h_source.html#l00359">folly::AtomicUnorderedInsertMap&lt; Key, Value, Hash, KeyEqual, SkipKeyValueDeletion, Atom, IndexType, Allocator &gt;::Slot::headAndState_</a>, and <a class="el" href="AtomicUnorderedMap_8h_source.html#l00362">folly::AtomicUnorderedInsertMap&lt; Key, Value, Hash, KeyEqual, SkipKeyValueDeletion, Atom, IndexType, Allocator &gt;::Slot::next_</a>.</p>
<div class="fragment"><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;                                                       {</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    KeyEqual ke = {};</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    <span class="keyword">auto</span> hs = <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">slots_</a>[slot].<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html#afd7aae4c621d3c766fc147acc4c3ca12">headAndState_</a>.load(std::memory_order_acquire);</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;    <span class="keywordflow">for</span> (slot = hs &gt;&gt; 2; slot != 0; slot = <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">slots_</a>[slot].<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html#afb70766bb70978b27a485098ff7e25b5">next_</a>) {</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;      <span class="keywordflow">if</span> (ke(key, <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">slots_</a>[slot].keyValue().<a class="code" href="namespacefolly_1_1gen.html#af220ef9930b641e74fa9588a0bcffb8c">first</a>)) {</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;        <span class="keywordflow">return</span> slot;</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;      }</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    }</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;  }</div><div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot_html_afd7aae4c621d3c766fc147acc4c3ca12"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html#afd7aae4c621d3c766fc147acc4c3ca12">folly::AtomicUnorderedInsertMap::Slot::headAndState_</a></div><div class="ttdeci">Atom&lt; IndexType &gt; headAndState_</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00359">AtomicUnorderedMap.h:359</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_aca2e49b3357289b3394a71e942c09f94"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">folly::AtomicUnorderedInsertMap::slots_</a></div><div class="ttdeci">Slot * slots_</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00408">AtomicUnorderedMap.h:408</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot_html_afb70766bb70978b27a485098ff7e25b5"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html#afb70766bb70978b27a485098ff7e25b5">folly::AtomicUnorderedInsertMap::Slot::next_</a></div><div class="ttdeci">IndexType next_</div><div class="ttdoc">The next bucket in the chain. </div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00362">AtomicUnorderedMap.h:362</a></div></div>
<div class="ttc" id="namespacefolly_1_1gen_html_af220ef9930b641e74fa9588a0bcffb8c"><div class="ttname"><a href="namespacefolly_1_1gen.html#af220ef9930b641e74fa9588a0bcffb8c">folly::gen::first</a></div><div class="ttdeci">constexpr detail::First first</div><div class="ttdef"><b>Definition:</b> <a href="Base-inl_8h_source.html#l02553">Base-inl.h:2553</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6dab52b569e8fab476f24a3667eda8e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a4bebe3f75a8062990401e3c8e65a201d">const_iterator</a>, bool&gt; <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::findOrConstruct </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacefolly.html#a4f345dd5f9b26d8dd202c2072badbea8">Func</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches for the key, returning (iter,false) if it is found. If it is not found calls the functor Func with a void* argument that is raw storage suitable for placement construction of a Value (see raw_value_type), then returns (iter,true). May call Func and then return (iter,false) if there are other concurrent writes, in which case the newly constructed value will be immediately destroyed.</p>
<p>This function does not block other readers or writers. If there are other concurrent writes, many parallel calls to func may happen and only the first one to complete will win. The values constructed by the other calls to func will be destroyed.</p>
<p>Usage:</p>
<p><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html#a3c2c6dbdd013d6578b92bc745216007b">AtomicUnorderedInsertMap&lt;std::string,std::string&gt;</a> memo;</p>
<p>auto value = memo.findOrConstruct(key, [=](void* raw) { new (raw) std::string(computation(key)); })-&gt;first; </p>

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00263">263</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

<p>References <a class="el" href="fizz_2build___2gtest_2src_2gtest_2googlemock_2include_2gmock_2gmock-matchers_8h_source.html#l04322">testing::Key()</a>.</p>
<div class="fragment"><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;                                                                             {</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    <span class="keyword">auto</span> <span class="keyword">const</span> slot = <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a1271cf50f435f979877337341b3b5d7e">keyToSlotIdx</a>(key);</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;    <span class="keyword">auto</span> prev = <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">slots_</a>[slot].<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html#afd7aae4c621d3c766fc147acc4c3ca12">headAndState_</a>.load(std::memory_order_acquire);</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    <span class="keyword">auto</span> existing = <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a88e5a07cad12ab93500d3ba5d0bf8f67">find</a>(key, slot);</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    <span class="keywordflow">if</span> (existing != 0) {</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;      <span class="keywordflow">return</span> std::make_pair(<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#adc84cf3dfc351c132aa3be5a69188379">ConstIterator</a>(*<span class="keyword">this</span>, existing), <span class="keyword">false</span>);</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    }</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    <span class="keyword">auto</span> idx = <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a55606b1cfb3c3b0f8e601adca272b8ba">allocateNear</a>(slot);</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    <span class="keyword">new</span> (&amp;<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">slots_</a>[idx].<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html#acb6a4a2c0700a53eafbd62ebca146de1">keyValue</a>().first) <a class="code" href="namespacetesting.html#a8f48cc347b4b3fa9a6f13aa41573e4af">Key</a>(key);</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    func(static_cast&lt;void*&gt;(&amp;<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">slots_</a>[idx].keyValue().second));</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;      <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">slots_</a>[idx].<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html#afb70766bb70978b27a485098ff7e25b5">next_</a> = prev &gt;&gt; 2;</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;      <span class="comment">// we can merge the head update and the CONSTRUCTING -&gt; LINKED update</span></div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;      <span class="comment">// into a single CAS if slot == idx (which should happen often)</span></div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;      <span class="keyword">auto</span> after = idx &lt;&lt; 2;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;      <span class="keywordflow">if</span> (slot == idx) {</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;        after += <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49af2c6e81a3eea9a24ed750572fbbc6efd">LINKED</a>;</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;      } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;        after += (prev &amp; 3);</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;      }</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">slots_</a>[slot].headAndState_.compare_exchange_strong(prev, after)) {</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;        <span class="comment">// success</span></div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        <span class="keywordflow">if</span> (idx != slot) {</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;          <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">slots_</a>[idx].<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html#ab90179dfb15f54ffff359765bc5e7767">stateUpdate</a>(<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49a23fa1eef2e52738379ddf160c0902358">CONSTRUCTING</a>, <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49af2c6e81a3eea9a24ed750572fbbc6efd">LINKED</a>);</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        }</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;        <span class="keywordflow">return</span> std::make_pair(<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#adc84cf3dfc351c132aa3be5a69188379">ConstIterator</a>(*<span class="keyword">this</span>, idx), <span class="keyword">true</span>);</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;      }</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;      <span class="comment">// compare_exchange_strong updates its first arg on failure, so</span></div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;      <span class="comment">// there is no need to reread prev</span></div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;      existing = <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a88e5a07cad12ab93500d3ba5d0bf8f67">find</a>(key, slot);</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;      <span class="keywordflow">if</span> (existing != 0) {</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;        <span class="comment">// our allocated key and value are no longer needed</span></div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;        <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">slots_</a>[idx].<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html#acb6a4a2c0700a53eafbd62ebca146de1">keyValue</a>().first.~Key();</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;        <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">slots_</a>[idx].<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html#acb6a4a2c0700a53eafbd62ebca146de1">keyValue</a>().second.~Value();</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">slots_</a>[idx].<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html#ab90179dfb15f54ffff359765bc5e7767">stateUpdate</a>(<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49a23fa1eef2e52738379ddf160c0902358">CONSTRUCTING</a>, <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49a52da358213f42cf4a3c5a49d7bc341f4">EMPTY</a>);</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;        <span class="keywordflow">return</span> std::make_pair(<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#adc84cf3dfc351c132aa3be5a69188379">ConstIterator</a>(*<span class="keyword">this</span>, existing), <span class="keyword">false</span>);</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;      }</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    }</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;  }</div><div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a1271cf50f435f979877337341b3b5d7e"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a1271cf50f435f979877337341b3b5d7e">folly::AtomicUnorderedInsertMap::keyToSlotIdx</a></div><div class="ttdeci">IndexType keyToSlotIdx(const Key &amp;key) const </div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00410">AtomicUnorderedMap.h:410</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot_html_ab90179dfb15f54ffff359765bc5e7767"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html#ab90179dfb15f54ffff359765bc5e7767">folly::AtomicUnorderedInsertMap::Slot::stateUpdate</a></div><div class="ttdeci">void stateUpdate(BucketState before, BucketState after)</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00381">AtomicUnorderedMap.h:381</a></div></div>
<div class="ttc" id="namespacetesting_html_a8f48cc347b4b3fa9a6f13aa41573e4af"><div class="ttname"><a href="namespacetesting.html#a8f48cc347b4b3fa9a6f13aa41573e4af">testing::Key</a></div><div class="ttdeci">internal::KeyMatcher&lt; M &gt; Key(M inner_matcher)</div><div class="ttdef"><b>Definition:</b> <a href="fizz_2build___2gtest_2src_2gtest_2googlemock_2include_2gmock_2gmock-matchers_8h_source.html#l04322">gmock-matchers.h:4322</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a55606b1cfb3c3b0f8e601adca272b8ba"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a55606b1cfb3c3b0f8e601adca272b8ba">folly::AtomicUnorderedInsertMap::allocateNear</a></div><div class="ttdeci">IndexType allocateNear(IndexType start)</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00432">AtomicUnorderedMap.h:432</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a3b78eb039cb12dc31ee2a439b3687f49af2c6e81a3eea9a24ed750572fbbc6efd"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49af2c6e81a3eea9a24ed750572fbbc6efd">folly::AtomicUnorderedInsertMap::LINKED</a></div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00344">AtomicUnorderedMap.h:344</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a3b78eb039cb12dc31ee2a439b3687f49a23fa1eef2e52738379ddf160c0902358"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49a23fa1eef2e52738379ddf160c0902358">folly::AtomicUnorderedInsertMap::CONSTRUCTING</a></div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00343">AtomicUnorderedMap.h:343</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot_html_afd7aae4c621d3c766fc147acc4c3ca12"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html#afd7aae4c621d3c766fc147acc4c3ca12">folly::AtomicUnorderedInsertMap::Slot::headAndState_</a></div><div class="ttdeci">Atom&lt; IndexType &gt; headAndState_</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00359">AtomicUnorderedMap.h:359</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_aca2e49b3357289b3394a71e942c09f94"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">folly::AtomicUnorderedInsertMap::slots_</a></div><div class="ttdeci">Slot * slots_</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00408">AtomicUnorderedMap.h:408</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a3b78eb039cb12dc31ee2a439b3687f49a52da358213f42cf4a3c5a49d7bc341f4"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a3b78eb039cb12dc31ee2a439b3687f49a52da358213f42cf4a3c5a49d7bc341f4">folly::AtomicUnorderedInsertMap::EMPTY</a></div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00342">AtomicUnorderedMap.h:342</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_adc84cf3dfc351c132aa3be5a69188379"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#adc84cf3dfc351c132aa3be5a69188379">folly::AtomicUnorderedInsertMap::ConstIterator</a></div><div class="ttdeci">friend ConstIterator</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00199">AtomicUnorderedMap.h:199</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot_html_afb70766bb70978b27a485098ff7e25b5"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html#afb70766bb70978b27a485098ff7e25b5">folly::AtomicUnorderedInsertMap::Slot::next_</a></div><div class="ttdeci">IndexType next_</div><div class="ttdoc">The next bucket in the chain. </div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00362">AtomicUnorderedMap.h:362</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot_html_acb6a4a2c0700a53eafbd62ebca146de1"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html#acb6a4a2c0700a53eafbd62ebca146de1">folly::AtomicUnorderedInsertMap::Slot::keyValue</a></div><div class="ttdeci">value_type &amp; keyValue()</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00386">AtomicUnorderedMap.h:386</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a88e5a07cad12ab93500d3ba5d0bf8f67"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a88e5a07cad12ab93500d3ba5d0bf8f67">folly::AtomicUnorderedInsertMap::find</a></div><div class="ttdeci">const_iterator find(const Key &amp;key) const </div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00320">AtomicUnorderedMap.h:320</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1271cf50f435f979877337341b3b5d7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IndexType <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::keyToSlotIdx </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00410">410</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

<p>References <a class="el" href="Hazptr_8h_source.html#l00116">h</a>.</p>
<div class="fragment"><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;                                               {</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    <span class="keywordtype">size_t</span> <a class="code" href="Hazptr_8h.html#ab25155a2370ac096e61dc7e39e2816df">h</a> = <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a1b6563f7fe0c0e732691656713fc3f15">hasher</a>()(key);</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    h &amp;= <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a7290e9069fafa49a4d98e30cbcaca506">slotMask_</a>;</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    <span class="keywordflow">while</span> (h &gt;= <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a38e070ff2f0fbd9b659cfecad65560b8">numSlots_</a>) {</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;      h -= <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a38e070ff2f0fbd9b659cfecad65560b8">numSlots_</a>;</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;    }</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="Hazptr_8h.html#ab25155a2370ac096e61dc7e39e2816df">h</a>;</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;  }</div><div class="ttc" id="Hazptr_8h_html_ab25155a2370ac096e61dc7e39e2816df"><div class="ttname"><a href="Hazptr_8h.html#ab25155a2370ac096e61dc7e39e2816df">h</a></div><div class="ttdeci">*than *hazptr_holder h</div><div class="ttdef"><b>Definition:</b> <a href="Hazptr_8h_source.html#l00116">Hazptr.h:116</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a38e070ff2f0fbd9b659cfecad65560b8"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a38e070ff2f0fbd9b659cfecad65560b8">folly::AtomicUnorderedInsertMap::numSlots_</a></div><div class="ttdeci">size_t numSlots_</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00402">AtomicUnorderedMap.h:402</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a1b6563f7fe0c0e732691656713fc3f15"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a1b6563f7fe0c0e732691656713fc3f15">folly::AtomicUnorderedInsertMap::hasher</a></div><div class="ttdeci">Hash hasher</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00150">AtomicUnorderedMap.h:150</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a7290e9069fafa49a4d98e30cbcaca506"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a7290e9069fafa49a4d98e30cbcaca506">folly::AtomicUnorderedInsertMap::slotMask_</a></div><div class="ttdeci">size_t slotMask_</div><div class="ttdoc">tricky, see keyToSlodIdx </div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00405">AtomicUnorderedMap.h:405</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a18bd284e1e769bda86a90b7f0de2737a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::zeroFillSlots </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00463">463</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

<p>References <a class="el" href="ConcurrentHashMapTest_8cpp_source.html#l00301">Atom</a>, <a class="el" href="fizz_2build___2gtest_2src_2gtest_2googlemock_2include_2gmock_2gmock-matchers_8h_source.html#l04322">testing::Key()</a>, <a class="el" href="ConstexprMathBenchmark_8cpp_source.html#l00190">uint64_t</a>, <a class="el" href="Conv_8cpp_source.html#l00050">value</a>, and <a class="el" href="fizz_2build___2gtest_2src_2gtest_2googlemock_2include_2gmock_2gmock-matchers_8h_source.html#l04347">testing::Value()</a>.</p>
<div class="fragment"><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;                       {</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;    <span class="keyword">using</span> <a class="code" href="structfolly_1_1detail_1_1GivesZeroFilledMemory.html">folly::detail::GivesZeroFilledMemory</a>;</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="Conv_8cpp.html#a2f6ac1714c34743067351b0d2a64162b">GivesZeroFilledMemory&lt;Allocator&gt;::value</a>) {</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;      memset(<a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">slots_</a>, 0, <a class="code" href="structfolly_1_1AtomicUnorderedInsertMap.html#a85a267cad149b1aef6f1e610bf716136">mmapRequested_</a>);</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;    }</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;  }</div><div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_a85a267cad149b1aef6f1e610bf716136"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#a85a267cad149b1aef6f1e610bf716136">folly::AtomicUnorderedInsertMap::mmapRequested_</a></div><div class="ttdeci">size_t mmapRequested_</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00401">AtomicUnorderedMap.h:401</a></div></div>
<div class="ttc" id="Conv_8cpp_html_a2f6ac1714c34743067351b0d2a64162b"><div class="ttname"><a href="Conv_8cpp.html#a2f6ac1714c34743067351b0d2a64162b">value</a></div><div class="ttdeci">static const char *const value</div><div class="ttdef"><b>Definition:</b> <a href="Conv_8cpp_source.html#l00050">Conv.cpp:50</a></div></div>
<div class="ttc" id="structfolly_1_1AtomicUnorderedInsertMap_html_aca2e49b3357289b3394a71e942c09f94"><div class="ttname"><a href="structfolly_1_1AtomicUnorderedInsertMap.html#aca2e49b3357289b3394a71e942c09f94">folly::AtomicUnorderedInsertMap::slots_</a></div><div class="ttdeci">Slot * slots_</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMap_8h_source.html#l00408">AtomicUnorderedMap.h:408</a></div></div>
<div class="ttc" id="structfolly_1_1detail_1_1GivesZeroFilledMemory_html"><div class="ttname"><a href="structfolly_1_1detail_1_1GivesZeroFilledMemory.html">folly::detail::GivesZeroFilledMemory</a></div><div class="ttdef"><b>Definition:</b> <a href="AtomicUnorderedMapUtils_8h_source.html#l00074">AtomicUnorderedMapUtils.h:74</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aaafda6d155af1b74a66fbfecf6b3cdf2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Allocator <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::allocator_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00407">407</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

</div>
</div>
<a class="anchor" id="adc84cf3dfc351c132aa3be5a69188379"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::<a class="el" href="structfolly_1_1AtomicUnorderedInsertMap_1_1ConstIterator.html">ConstIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00199">199</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

</div>
</div>
<a class="anchor" id="a85a267cad149b1aef6f1e610bf716136"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::mmapRequested_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00401">401</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

</div>
</div>
<a class="anchor" id="a38e070ff2f0fbd9b659cfecad65560b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::numSlots_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00402">402</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7290e9069fafa49a4d98e30cbcaca506"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::slotMask_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>tricky, see keyToSlodIdx </p>

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00405">405</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

</div>
</div>
<a class="anchor" id="aca2e49b3357289b3394a71e942c09f94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, bool SkipKeyValueDeletion = (boost::has_trivial_destructor&lt;Key&gt;::value &amp;&amp;         boost::has_trivial_destructor&lt;Value&gt;::value), template&lt; typename &gt; class Atom = std::atomic, typename IndexType = uint32_t, typename Allocator = folly::detail::MMapAlloc&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap_1_1Slot.html">Slot</a>* <a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">folly::AtomicUnorderedInsertMap</a>&lt; Key, Value, <a class="el" href="structfolly_1_1Hash.html">Hash</a>, KeyEqual, SkipKeyValueDeletion, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, IndexType, Allocator &gt;::slots_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="AtomicUnorderedMap_8h_source.html#l00408">408</a> of file <a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>proxygen/folly/folly/<a class="el" href="AtomicUnorderedMap_8h_source.html">AtomicUnorderedMap.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefolly.html">folly</a></li><li class="navelem"><a class="el" href="structfolly_1_1AtomicUnorderedInsertMap.html">AtomicUnorderedInsertMap</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
