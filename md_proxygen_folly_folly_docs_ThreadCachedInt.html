<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: `folly/ThreadCachedInt.h`</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_proxygen_folly_folly_docs_ThreadCachedInt.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">`folly/ThreadCachedInt.h` </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>High-performance atomic increment using thread caching.</p>
<p><code>folly/ThreadCachedInt.h</code> introduces a integer class designed for high performance increments from multiple threads simultaneously without loss of precision. It has two read modes, <code>readFast</code> gives a potentially stale value with one load, and <code>readFull</code> gives the exact value, but is much slower, as discussed below.</p>
<h3>Performance</h3>
<hr/>
<p>Increment performance is up to 10x greater than <code>std::atomic_fetch_add</code> in high contention environments. See <code>folly/test/ThreadCachedIntTest.h</code> for more comprehensive benchmarks.</p>
<p><code>readFast</code> is as fast as a single load.</p>
<p><code>readFull</code>, on the other hand, requires acquiring a mutex and iterating through a list to accumulate the values of all the thread local counters, so is significantly slower than <code>readFast</code>.</p>
<h3>Usage</h3>
<hr/>
<p>Create an instance and increment it with <code>increment</code> or the operator overloads. Read the value with <code>readFast</code> for quick, potentially stale data, or <code>readFull</code> for a more expensive but precise result. There are additional convenience functions as well, such as <code>set</code>.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;ThreadCachedInt&lt;int64_t&gt; val;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;EXPECT_EQ(0, val.readFast());</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;++val;                        // increment in thread local counter only</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;EXPECT_EQ(0, val.readFast()); // increment has not been flushed</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;EXPECT_EQ(1, val.readFull()); // accumulates all thread local counters</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;val.set(2);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;EXPECT_EQ(2, val.readFast());</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;EXPECT_EQ(2, val.readFull());</div></div><!-- fragment --><h3>Implementation</h3>
<hr/>
<p><code><a class="el" href="classfolly_1_1ThreadCachedInt.html">folly::ThreadCachedInt</a></code> uses <code><a class="el" href="classfolly_1_1ThreadLocal.html">folly::ThreadLocal</a></code> to store thread specific objects that each have a local counter. When incrementing, the thread local instance is incremented. If the local counter passes the cache size, the value is flushed to the global counter with an atomic increment. It is this global counter that is read with <code>readFast</code> via a simple load, but will not count any of the updates that haven't been flushed.</p>
<p>In order to read the exact value, <code>ThreadCachedInt</code> uses the extended <code>readAllThreads()</code> API of <code><a class="el" href="classfolly_1_1ThreadLocal.html">folly::ThreadLocal</a></code> to iterate through all the references to all the associated thread local object instances. This currently requires acquiring a global mutex and iterating through the references, accumulating the counters along with the global counter. This also means that the first use of the object from a new thread will acquire the mutex in order to insert the thread local reference into the list. By default, there is one global mutex per integer type used in <code>ThreadCachedInt</code>. If you plan on using a lot of <code>ThreadCachedInt</code>s in your application, considering breaking up the global mutex by introducing additional <code>Tag</code> template parameters.</p>
<p><code>set</code> simply sets the global counter value, and marks all the thread local instances as needing to be reset. When iterating with <code>readFull</code>, thread local counters that have been marked as reset are skipped. When incrementing, thread local counters marked for reset are set to zero and unmarked for reset.</p>
<p>Upon destruction, thread local counters are flushed to the parent so that counts are not lost after increments in temporary threads. This requires grabbing the global mutex to make sure the parent itself wasn't destroyed in another thread already.</p>
<h3>Alternate Implementations</h3>
<hr/>
<p>There are of course many ways to skin a cat, and you may notice there is a partial alternate implementation in <code><a class="el" href="ThreadCachedIntTest_8cpp.html">folly/test/ThreadCachedIntTest.cpp</a></code> that provides similar performance. <code><a class="el" href="structShardedAtomicInt.html">ShardedAtomicInt</a></code> simply uses an array of <code>std::atomic&lt;int64_t&gt;</code>'s and hashes threads across them to do low-contention atomic increments, and <code>readFull</code> just sums up all the ints.</p>
<p>This sounds great, but in order to get the contention low enough to get similar performance as ThreadCachedInt with 24 threads, <code><a class="el" href="structShardedAtomicInt.html">ShardedAtomicInt</a></code> needs about 2000 ints to hash across. This uses about 20x more memory, and the lock-free <code>readFull</code> has to sum up all 2048 ints, which ends up being a about 50x slower than <code>ThreadCachedInt</code> in low contention situations, which is hopefully the common case since it's designed for high-write, low read access patterns. Performance of <code>readFull</code> is about the same speed as <code>ThreadCachedInt</code> in high contention environments.</p>
<p>Depending on the operating conditions, it may make more sense to use one implementation over the other. For example, a lower contention environment will probably be able to use a <code><a class="el" href="structShardedAtomicInt.html">ShardedAtomicInt</a></code> with a much smaller array without hurting performance, while improving memory consumption and perf of <code>readFull</code>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
