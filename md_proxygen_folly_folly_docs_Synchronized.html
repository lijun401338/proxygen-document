<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: `folly/Synchronized.h`</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_proxygen_folly_folly_docs_Synchronized.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">`folly/Synchronized.h` </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><code>folly/Synchronized.h</code> introduces a simple abstraction for mutex- based concurrency. It replaces convoluted, unwieldy, and just plain wrong code with simple constructs that are easy to get right and difficult to get wrong.</p>
<h3>Motivation</h3>
<p>Many of our multithreaded C++ programs use shared data structures associated with locks. This follows the time-honored adage of mutex-based concurrency control "associate mutexes with data, not code". Consider the following example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;class RequestHandler {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  ...</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  RequestQueue requestQueue_;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  SharedMutex requestQueueMutex_;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  std::map&lt;std::string, Endpoint&gt; requestEndpoints_;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  SharedMutex requestEndpointsMutex_;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  HandlerState workState_;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  SharedMutex workStateMutex_;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  ...</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;};</div></div><!-- fragment --><p>Whenever the code needs to read or write some of the protected data, it acquires the mutex for reading or for reading and writing. For example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void RequestHandler::processRequest(const Request&amp; request) {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  stop_watch&lt;&gt; watch;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  checkRequestValidity(request);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  SharedMutex::WriteHolder lock(requestQueueMutex_);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  requestQueue_.push_back(request);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  stats_-&gt;addStatValue(&quot;requestEnqueueLatency&quot;, watch.elapsed());</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  LOG(INFO) &lt;&lt; &quot;enqueued request ID &quot; &lt;&lt; request.getID();</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --><p>However, the correctness of the technique is entirely predicated on convention. Developers manipulating these data members must take care to explicitly acquire the correct lock for the data they wish to access. There is no ostensible error for code that:</p>
<ul>
<li>manipulates a piece of data without acquiring its lock first</li>
<li>acquires a different lock instead of the intended one</li>
<li>acquires a lock in read mode but modifies the guarded data structure</li>
<li>acquires a lock in read-write mode although it only has <code>const</code> access to the guarded data</li>
</ul>
<h3>Introduction to <code>folly/Synchronized.h</code></h3>
<p>The same code sample could be rewritten with <code>Synchronized</code> as follows:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;class RequestHandler {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  ...</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  Synchronized&lt;RequestQueue&gt; requestQueue_;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  Synchronized&lt;std::map&lt;std::string, Endpoint&gt;&gt; requestEndpoints_;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  Synchronized&lt;HandlerState&gt; workState_;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  ...</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;};</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;void RequestHandler::processRequest(const Request&amp; request) {</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  stop_watch&lt;&gt; watch;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  checkRequestValidity(request);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  requestQueue_.wlock()-&gt;push_back(request);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  stats_-&gt;addStatValue(&quot;requestEnqueueLatency&quot;, watch.elapsed());</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  LOG(INFO) &lt;&lt; &quot;enqueued request ID &quot; &lt;&lt; request.getID();</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;}</div></div><!-- fragment --><p>The rewrite does at maximum efficiency what needs to be done: acquires the lock associated with the <code>RequestQueue</code> object, writes to the queue, and releases the lock immediately thereafter.</p>
<p>On the face of it, that's not much to write home about, and not an obvious improvement over the previous state of affairs. But the features at work invisible in the code above are as important as those that are visible:</p>
<ul>
<li>Unlike before, the data and the mutex protecting it are inextricably encapsulated together.</li>
<li>If you tried to use <code>requestQueue_</code> without acquiring the lock you wouldn't be able to; it is virtually impossible to access the queue without acquiring the correct lock.</li>
<li>The lock is released immediately after the insert operation is performed, and is not held for operations that do not need it.</li>
</ul>
<p>If you need to perform several operations while holding the lock, <code>Synchronized</code> provides several options for doing this.</p>
<p>The <code><a class="el" href="namespacefolly_1_1detail.html#a5f33a5a02c2e1470bc6c268c8a8a183f">wlock()</a></code> method (or <code><a class="el" href="namespacefolly_1_1detail.html#a387acec4cb2d7df1e6bab13521d27e60">lock()</a></code> if you have a non-shared mutex type) returns a <code>LockedPtr</code> object that can be stored in a variable. The lock will be held for as long as this object exists, similar to a <code>std::unique_lock</code>. This object can be used as if it were a pointer to the underlying locked object:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  auto lockedQueue = requestQueue_.wlock();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  lockedQueue-&gt;push_back(request1);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  lockedQueue-&gt;push_back(request2);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --><p>The <code><a class="el" href="namespacefolly_1_1detail.html#a25f59e233ee60f719c0bc9c8e4aa5564">rlock()</a></code> function is similar to <code><a class="el" href="namespacefolly_1_1detail.html#a5f33a5a02c2e1470bc6c268c8a8a183f">wlock()</a></code>, but acquires a shared lock rather than an exclusive lock.</p>
<p>We recommend explicitly opening a new nested scope whenever you store a <code>LockedPtr</code> object, to help visibly delineate the critical section, and to ensure that the <code>LockedPtr</code> is destroyed as soon as it is no longer needed.</p>
<p>Alternatively, <code>Synchronized</code> also provides mechanisms to run a function while holding the lock. This makes it possible to use lambdas to define brief critical sections:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void RequestHandler::processRequest(const Request&amp; request) {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  stop_watch&lt;&gt; watch;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  checkRequestValidity(request);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  requestQueue_.withWLock([&amp;](auto&amp; queue) {</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    // withWLock() automatically holds the lock for the</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    // duration of this lambda function</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    queue.push_back(request);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  });</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  stats_-&gt;addStatValue(&quot;requestEnqueueLatency&quot;, watch.elapsed());</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  LOG(INFO) &lt;&lt; &quot;enqueued request ID &quot; &lt;&lt; request.getID();</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --><p>One advantage of the <code>withWLock()</code> approach is that it forces a new scope to be used for the critical section, making the critical section more obvious in the code, and helping to encourage code that releases the lock as soon as possible.</p>
<h3>Template class <code>Synchronized&lt;T&gt;</code></h3>
<h4>Template Parameters</h4>
<p><code>Synchronized</code> is a template with two parameters, the data type and a mutex type: <code>Synchronized&lt;T, Mutex&gt;</code>.</p>
<p>If not specified, the mutex type defaults to <code><a class="el" href="namespacefolly.html#ae7e470db39b3e07bb689bc4af72fdf0c">folly::SharedMutex</a></code>. However, any mutex type supported by <code><a class="el" href="structfolly_1_1LockTraits.html">folly::LockTraits</a></code> can be used instead. <code><a class="el" href="structfolly_1_1LockTraits.html">folly::LockTraits</a></code> can be specialized to support other custom mutex types that it does not know about out of the box. See <code>folly/LockTraitsBoost.h</code> for an example of how to support additional mutex types.</p>
<p><code>Synchronized</code> provides slightly different APIs when instantiated with a shared mutex type or an upgrade mutex type then with a plain exclusive mutex. If instantiated with either of the two mutex types above (either through having a member called lock_shared() or specializing <code>LockTraits</code> as in <code>folly/LockTraitsBoost.h</code>) the <code>Synchronized</code> object has corresponding <code>wlock</code>, <code>rlock</code> or <code>ulock</code> methods to acquire different lock types. When using a shared or upgrade mutex type, these APIs ensure that callers make an explicit choice to acquire a shared, exclusive or upgrade lock and that callers do not unintentionally lock the mutex in the incorrect mode. The <code><a class="el" href="namespacefolly_1_1detail.html#a25f59e233ee60f719c0bc9c8e4aa5564">rlock()</a></code> APIs only provide <code>const</code> access to the underlying data type, ensuring that it cannot be modified when only holding a shared lock.</p>
<h4>Constructors</h4>
<p>The default constructor default-initializes the data and its associated mutex.</p>
<p>The copy constructor locks the source for reading and copies its data into the target. (The target is not locked as an object under construction is only accessed by one thread.)</p>
<p>Finally, <code>Synchronized&lt;T&gt;</code> defines an explicit constructor that takes an object of type <code>T</code> and copies it. For example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// Default constructed</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Synchronized&lt;map&lt;string, int&gt;&gt; syncMap1;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;// Copy constructed</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;Synchronized&lt;map&lt;string, int&gt;&gt; syncMap2(syncMap1);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;// Initializing from an existing map</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;map&lt;string, int&gt; init;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;init[&quot;world&quot;] = 42;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;Synchronized&lt;map&lt;string, int&gt;&gt; syncMap3(init);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;EXPECT_EQ(syncMap3-&gt;size(), 1);</div></div><!-- fragment --><h4>Assignment, swap, and copying</h4>
<p>The copy assignment operator copies the underlying source data into a temporary with the source mutex locked, and then move the temporary into the destination data with the destination mutex locked. This technique avoids the need to lock both mutexes at the same time. Mutexes are not copied or moved.</p>
<p>The move assignment operator assumes the source object is a true rvalue and does lock lock the source mutex. It moves the source data into the destination data with the destination mutex locked.</p>
<p><code>swap</code> acquires locks on both mutexes in increasing order of object address, and then swaps the underlying data. This avoids potential deadlock, which may otherwise happen should one thread do <code>a = b</code> while another thread does <code>b = a</code>.</p>
<p>The data copy assignment operator copies the parameter into the destination data while the destination mutex is locked.</p>
<p>The data move assignment operator moves the parameter into the destination data while the destination mutex is locked.</p>
<p>To get a copy of the guarded data, there are two methods available: <code>void copy(T*)</code> and <code>T <a class="el" href="namespacefolly.html#ac4b2f1383a59507925358ddd5b1badb1">copy()</a></code>. The first copies data to a provided target and the second returns a copy by value. Both operations are done under a read lock. Example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Synchronized&lt;vector&lt;string&gt;&gt; syncVec1, syncVec2;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;vector&lt;string&gt; vec;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;// Assign</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;syncVec1 = syncVec2;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;// Assign straight from vector</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;syncVec1 = vec;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;// Swap</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;syncVec1.swap(syncVec2);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;// Swap with vector</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;syncVec1.swap(vec);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;// Copy to given target</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;syncVec1.copy(&amp;vec);</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;// Get a copy by value</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;auto copy = syncVec1.copy();</div></div><!-- fragment --><h4><code><a class="el" href="namespacefolly_1_1detail.html#a387acec4cb2d7df1e6bab13521d27e60">lock()</a></code></h4>
<p>If the mutex type used with <code>Synchronized</code> is a simple exclusive mutex type (as opposed to a shared mutex), <code>Synchronized&lt;T&gt;</code> provides a <code><a class="el" href="namespacefolly_1_1detail.html#a387acec4cb2d7df1e6bab13521d27e60">lock()</a></code> method that returns a <code>LockedPtr&lt;T&gt;</code> to access the data while holding the lock.</p>
<p>The <code>LockedPtr</code> object returned by <code><a class="el" href="namespacefolly_1_1detail.html#a387acec4cb2d7df1e6bab13521d27e60">lock()</a></code> holds the lock for as long as it exists. Whenever possible, prefer declaring a separate inner scope for storing this variable, to make sure the <code>LockedPtr</code> is destroyed as soon as the lock is no longer needed:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void fun(Synchronized&lt;vector&lt;string&gt;, std::mutex&gt;&amp; vec) {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    auto locked = vec.lock();</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    locked-&gt;push_back(&quot;hello&quot;);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    locked-&gt;push_back(&quot;world&quot;);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  }</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  LOG(INFO) &lt;&lt; &quot;successfully added greeting&quot;;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --><h4><code><a class="el" href="namespacefolly_1_1detail.html#a5f33a5a02c2e1470bc6c268c8a8a183f">wlock()</a></code> and <code><a class="el" href="namespacefolly_1_1detail.html#a25f59e233ee60f719c0bc9c8e4aa5564">rlock()</a></code></h4>
<p>If the mutex type used with <code>Synchronized</code> is a shared mutex type, <code>Synchronized&lt;T&gt;</code> provides a <code><a class="el" href="namespacefolly_1_1detail.html#a5f33a5a02c2e1470bc6c268c8a8a183f">wlock()</a></code> method that acquires an exclusive lock, and an <code><a class="el" href="namespacefolly_1_1detail.html#a25f59e233ee60f719c0bc9c8e4aa5564">rlock()</a></code> method that acquires a shared lock.</p>
<p>The <code>LockedPtr</code> returned by <code><a class="el" href="namespacefolly_1_1detail.html#a25f59e233ee60f719c0bc9c8e4aa5564">rlock()</a></code> only provides const access to the internal data, to ensure that it cannot be modified while only holding a shared lock.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;int computeSum(const Synchronized&lt;vector&lt;int&gt;&gt;&amp; vec) {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  int sum = 0;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  auto locked = vec.rlock();</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  for (int n : *locked) {</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    sum += n;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  }</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  return sum;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;void doubleValues(Synchronized&lt;vector&lt;int&gt;&gt;&amp; vec) {</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  auto locked = vec.wlock();</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  for (int&amp; n : *locked) {</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    n *= 2;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  }</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;}</div></div><!-- fragment --><p>This example brings us to a cautionary discussion. The <code>LockedPtr</code> object returned by <code><a class="el" href="namespacefolly_1_1detail.html#a387acec4cb2d7df1e6bab13521d27e60">lock()</a></code>, <code><a class="el" href="namespacefolly_1_1detail.html#a5f33a5a02c2e1470bc6c268c8a8a183f">wlock()</a></code>, or <code><a class="el" href="namespacefolly_1_1detail.html#a25f59e233ee60f719c0bc9c8e4aa5564">rlock()</a></code> only holds the lock as long as it exists. This object makes it difficult to access the data without holding the lock, but not impossible. In particular you should never store a raw pointer or reference to the internal data for longer than the lifetime of the <code>LockedPtr</code> object.</p>
<p>For instance, if we had written the following code in the examples above, this would have continued accessing the vector after the lock had been released:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// No. NO. NO!</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;for (int&amp; n : *vec.wlock()) {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  n *= 2;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div></div><!-- fragment --><p>The <code><a class="el" href="namespacefolly_1_1detail.html#a5f33a5a02c2e1470bc6c268c8a8a183f">vec.wlock()</a></code> return value is destroyed in this case as soon as the internal range iterators are created. The range iterators point into the vector's data, but lock is released immediately, before executing the loop body.</p>
<p>Needless to say, this is a crime punishable by long debugging nights.</p>
<p>Range-based for loops are slightly subtle about the lifetime of objects used in the initializer statement. Most other problematic use cases are a bit easier to spot than this, since the lifetime of the <code>LockedPtr</code> is more explicitly visible.</p>
<h4><code>withLock()</code></h4>
<p>As an alternative to the <code><a class="el" href="namespacefolly_1_1detail.html#a387acec4cb2d7df1e6bab13521d27e60">lock()</a></code> API, <code>Synchronized</code> also provides a <code>withLock()</code> method that executes a function or lambda expression while holding the lock. The function receives a reference to the data as its only argument.</p>
<p>This has a few benefits compared to <code><a class="el" href="namespacefolly_1_1detail.html#a387acec4cb2d7df1e6bab13521d27e60">lock()</a></code>:</p>
<ul>
<li>The lambda expression requires its own nested scope, making critical sections more visible in the code. Callers are recommended to define a new scope when using <code><a class="el" href="namespacefolly_1_1detail.html#a387acec4cb2d7df1e6bab13521d27e60">lock()</a></code> if they choose to, but this is not required. <code>withLock()</code> ensures that a new scope must always be defined.</li>
<li>Because a new scope is required, <code>withLock()</code> also helps encourage users to release the lock as soon as possible. Because the critical section scope is easily visible in the code, it is harder to accidentally put extraneous code inside the critical section without realizing it.</li>
<li>The separate lambda scope makes it more difficult to store raw pointers or references to the protected data and continue using those pointers outside the critical section.</li>
</ul>
<p>For example, <code>withLock()</code> makes the range-based for loop mistake from above much harder to accidentally run into:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;vec.withLock([](auto&amp; locked) {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  for (int&amp; n : locked) {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    n *= 2;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  }</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;});</div></div><!-- fragment --><p>This code does not have the same problem as the counter-example with <code><a class="el" href="namespacefolly_1_1detail.html#a5f33a5a02c2e1470bc6c268c8a8a183f">wlock()</a></code> above, since the lock is held for the duration of the loop.</p>
<p>When using <code>Synchronized</code> with a shared mutex type, it provides separate <code>withWLock()</code> and <code>withRLock()</code> methods instead of <code>withLock()</code>.</p>
<h4><code><a class="el" href="namespacefolly_1_1detail.html#a0cc52a143d79e84c7a97cc753a176422">ulock()</a></code> and <code>withULockPtr()</code></h4>
<p><code>Synchronized</code> also supports upgrading and downgrading mutex lock levels as long as the mutex type used to instantiate the <code>Synchronized</code> type has the same interface as the mutex types in the C++ standard library, or if <code>LockTraits</code> is specialized for the mutex type and the specialization is visible. See below for an intro to upgrade mutexes.</p>
<p>An upgrade lock can be acquired as usual either with the <code><a class="el" href="namespacefolly_1_1detail.html#a0cc52a143d79e84c7a97cc753a176422">ulock()</a></code> method or the <code>withULockPtr()</code> method as so</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  // only const access allowed to the underlying object when an upgrade lock</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  // is acquired</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  auto ulock = vec.ulock();</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  auto newSize = ulock-&gt;size();</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;auto newSize = vec.withULockPtr([](auto ulock) {</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  // only const access allowed to the underlying object when an upgrade lock</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  // is acquired</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  return ulock-&gt;size();</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;});</div></div><!-- fragment --><p>An upgrade lock acquired via <code><a class="el" href="namespacefolly_1_1detail.html#a0cc52a143d79e84c7a97cc753a176422">ulock()</a></code> or <code>withULockPtr()</code> can be upgraded or downgraded by calling any of the following methods on the <code>LockedPtr</code> proxy</p>
<ul>
<li><code>moveFromUpgradeToWrite()</code></li>
<li><code>moveFromWriteToUpgrade()</code></li>
<li><code>moveFromWriteToRead()</code></li>
<li><code>moveFromUpgradeToRead()</code></li>
</ul>
<p>Calling these leaves the <code>LockedPtr</code> object on which the method was called in an invalid <code>null</code> state and returns another LockedPtr proxy holding the specified lock. The upgrade or downgrade is done atomically - the <code>Synchronized</code> object is never in an unlocked state during the lock state transition. For example</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;auto ulock = obj.ulock();</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;if (ulock-&gt;needsUpdate()) {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  auto wlock = ulock.moveFromUpgradeToWrite();</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  // ulock is now null</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  wlock-&gt;updateObj();</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div></div><!-- fragment --><p>This "move" can also occur in the context of a <code>withULockPtr()</code> (<code>withWLockPtr()</code> or <code>withRLockPtr()</code> work as well!) function as so</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;auto newSize = obj.withULockPtr([](auto ulock) {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  if (ulock-&gt;needsUpdate()) {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    // release upgrade lock get write lock atomically</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    auto wlock = ulock.moveFromUpgradeToWrite();</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    // ulock is now null</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    wlock-&gt;updateObj();</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    // release write lock and acquire read lock atomically</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    auto rlock = wlock.moveFromWriteToRead();</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    // wlock is now null</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    return rlock-&gt;newSize();</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  } else {</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    // release upgrade lock and acquire read lock atomically</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    auto rlock = ulock.moveFromUpgradeToRead();</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    // ulock is now null</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    return rlock-&gt;newSize();</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;  }</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;});</div></div><!-- fragment --><h4>Intro to upgrade mutexes:</h4>
<p>An upgrade mutex is a shared mutex with an extra state called <code>upgrade</code> and an atomic state transition from <code>upgrade</code> to <code>unique</code>. The <code>upgrade</code> state is more powerful than the <code>shared</code> state but less powerful than the <code>unique</code> state.</p>
<p>An upgrade lock permits only const access to shared state for doing reads. It does not permit mutable access to shared state for doing writes. Only a unique lock permits mutable access for doing writes.</p>
<p>An upgrade lock may be held concurrently with any number of shared locks on the same mutex. An upgrade lock is exclusive with other upgrade locks and unique locks on the same mutex - only one upgrade lock or unique lock may be held at a time.</p>
<p>The upgrade mutex solves the problem of doing a read of shared state and then optionally doing a write to shared state efficiently under contention. Consider this scenario with a shared mutex:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct MyObect {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  bool isUpdateRequired() const;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  void doUpdate();</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;};</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;struct MyContainingObject {</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  folly::Synchronized&lt;MyObject&gt; sync;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  void mightHappenConcurrently() {</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    // first check</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    if (!sync.rlock()-&gt;isUpdateRequired()) {</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;      return;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    }</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    sync.withWLock([&amp;](auto&amp; state) {</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;      // second check</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;      if (!state.isUpdateRequired()) {</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        return;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;      }</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;      state.doUpdate();</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    });</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;  }</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;};</div></div><!-- fragment --><p>Here, the second <code>isUpdateRequired</code> check happens under a unique lock. This means that the second check cannot be done concurrently with other threads doing first <code>isUpdateRequired</code> checks under the shared lock, even though the second check, like the first check, is read-only and requires only const access to the shared state.</p>
<p>This may even introduce unnecessary blocking under contention. Since the default mutex type, <code><a class="el" href="namespacefolly.html#ae7e470db39b3e07bb689bc4af72fdf0c">folly::SharedMutex</a></code>, has write priority, the unique lock protecting the second check may introduce unnecessary blocking to all the other threads that are attempting to acquire a shared lock to protect the first check. This problem is called reader starvation.</p>
<p>One solution is to use a shared mutex type with read priority, such as <code><a class="el" href="namespacefolly.html#ad53d7922c37faf1172d958c35a012087">folly::SharedMutexReadPriority</a></code>. That can introduce less blocking under contention to the other threads attemping to acquire a shared lock to do the first check. However, that may backfire and cause threads which are attempting to acquire a unique lock (for the second check) to stall, waiting for a moment in time when there are no shared locks held on the mutex, a moment in time that may never even happen. This problem is called writer starvation.</p>
<p>Starvation is a tricky problem to solve in general. But we can partially side- step it in our case.</p>
<p>An alternative solution is to use an upgrade lock for the second check. Threads attempting to acquire an upgrade lock for the second check do not introduce unnecessary blocking to all other threads that are attempting to acquire a shared lock for the first check. Only after the second check passes, and the upgrade lock transitions atomically from an upgrade lock to a unique lock, does the unique lock introduce <em>necessary</em> blocking to the other threads attempting to acquire a shared lock. With this solution, unlike the solution without the upgrade lock, the second check may be done concurrently with all other first checks rather than blocking or being blocked by them.</p>
<p>The example would then look like:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct MyObect {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  bool isUpdateRequired() const;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  void doUpdate();</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;};</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;struct MyContainingObject {</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  folly::Synchronized&lt;MyObject&gt; sync;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  void mightHappenConcurrently() {</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    // first check</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    if (!sync.rlock()-&gt;isUpdateRequired()) {</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;      return;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    }</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    sync.withULockPtr([&amp;](auto ulock) {</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;      // second check</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;      if (!ulock-&gt;isUpdateRequired()) {</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        return;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;      }</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;      auto wlock = ulock.moveFromUpgradeToWrite();</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;      wlock-&gt;doUpdate();</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    });</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  }</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;};</div></div><!-- fragment --><p>Note: Some shared mutex implementations offer an atomic state transition from <code>shared</code> to <code>unique</code> and some upgrade mutex implementations offer an atomic state transition from <code>shared</code> to <code>upgrade</code>. These atomic state transitions are dangerous, however, and can deadlock when done concurrently on the same mutex. For example, if threads <a class="el" href="structA.html">A</a> and <a class="el" href="structB.html">B</a> both hold shared locks on a mutex and are both attempting to transition atomically from shared to upgrade locks, the threads are deadlocked. Likewise if they are both attempting to transition atomically from shared to unique locks, or one is attempting to transition atomically from shared to upgrade while the other is attempting to transition atomically from shared to unique. Therefore, <code>LockTraits</code> does not expose either of these dangerous atomic state transitions even when the underlying mutex type supports them. Likewise, <code>Synchronized</code>'s <code>LockedPtr</code> proxies do not expose these dangerous atomic state transitions either.</p>
<h4>Timed Locking</h4>
<p>When <code>Synchronized</code> is used with a mutex type that supports timed lock acquisition, <code><a class="el" href="namespacefolly_1_1detail.html#a387acec4cb2d7df1e6bab13521d27e60">lock()</a></code>, <code><a class="el" href="namespacefolly_1_1detail.html#a5f33a5a02c2e1470bc6c268c8a8a183f">wlock()</a></code>, and <code><a class="el" href="namespacefolly_1_1detail.html#a25f59e233ee60f719c0bc9c8e4aa5564">rlock()</a></code> can all take an optional <code>std::chrono::duration</code> argument. This argument specifies a timeout to use for acquiring the lock. If the lock is not acquired before the timeout expires, a null <code>LockedPtr</code> object will be returned. Callers must explicitly check the return value before using it:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void fun(Synchronized&lt;vector&lt;string&gt;&gt;&amp; vec) {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    auto locked = vec.lock(10ms);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    if (!locked) {</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;      throw std::runtime_error(&quot;failed to acquire lock&quot;);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    }</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    locked-&gt;push_back(&quot;hello&quot;);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    locked-&gt;push_back(&quot;world&quot;);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  }</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  LOG(INFO) &lt;&lt; &quot;successfully added greeting&quot;;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --><h4><code>unlock()</code> and <code>scopedUnlock()</code></h4>
<p><code>Synchronized</code> is a good mechanism for enforcing scoped synchronization, but it has the inherent limitation that it requires the critical section to be, well, scoped. Sometimes the code structure requires a fleeting "escape" from the iron fist of synchronization, while still inside the critical section scope.</p>
<p>One common pattern is releasing the lock early on error code paths, prior to logging an error message. The <code>LockedPtr</code> class provides an <code>unlock()</code> method that makes this possible:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Synchronized&lt;map&lt;int, string&gt;&gt; dic;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;...</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;{</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  auto locked = dic.rlock();</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  auto iter = locked-&gt;find(0);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  if (iter == locked.end()) {</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    locked.unlock();  // don&#39;t hold the lock while logging</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    LOG(ERROR) &lt;&lt; &quot;key 0 not found&quot;;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    return false;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  }</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  processValue(*iter);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;LOG(INFO) &lt;&lt; &quot;succeeded&quot;;</div></div><!-- fragment --><p>For more complex nested control flow scenarios, <code>scopedUnlock()</code> returns an object that will release the lock for as long as it exists, and will reacquire the lock when it goes out of scope.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Synchronized&lt;map&lt;int, string&gt;&gt; dic;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;...</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;{</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  auto locked = dic.wlock();</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  auto iter = locked-&gt;find(0);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  if (iter == locked-&gt;end()) {</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    {</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;      auto unlocker = locked.scopedUnlock();</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;      LOG(INFO) &lt;&lt; &quot;Key 0 not found, inserting it.&quot;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    }</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    locked-&gt;emplace(0, &quot;zero&quot;);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  } else {</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    *iter = &quot;zero&quot;;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  }</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;}</div></div><!-- fragment --><p>Clearly <code>scopedUnlock()</code> comes with specific caveats and liabilities. You must assume that during the <code>scopedUnlock()</code> section, other threads might have changed the protected structure in arbitrary ways. In the example above, you cannot use the iterator <code>iter</code> and you cannot assume that the key <code>0</code> is not in the map; another thread might have inserted it while you were bragging on <code>LOG(INFO)</code>.</p>
<p>Whenever a <code>LockedPtr</code> object has been unlocked, whether with <code>unlock()</code> or <code>scopedUnlock()</code>, it will behave as if it is null. <code>isNull()</code> will return true. Dereferencing an unlocked <code>LockedPtr</code> is not allowed and will result in undefined behavior.</p>
<h4><code>Synchronized</code> and <code>std::condition_variable</code></h4>
<p>When used with a <code>std::mutex</code>, <code>Synchronized</code> supports using a <code>std::condition_variable</code> with its internal mutex. This allows a <code>condition_variable</code> to be used to wait for a particular change to occur in the internal data.</p>
<p>The <code>LockedPtr</code> returned by <code>Synchronized&lt;T, std::mutex&gt;<a class="el" href="namespacefolly_1_1detail.html#a387acec4cb2d7df1e6bab13521d27e60">lock()</a></code> has a <code>getUniqueLock()</code> method that returns a reference to a <code>std::unique_lock&lt;std::mutex&gt;</code>, which can be given to the <code>std::condition_variable</code>:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Synchronized&lt;vector&lt;string&gt;, std::mutex&gt; vec;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;std::condition_variable emptySignal;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;// Assuming some other thread will put data on vec and signal</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;// emptySignal, we can then wait on it as follows:</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;auto locked = vec.lock();</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;emptySignal.wait(locked.getUniqueLock(),</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;                 [&amp;] { return !locked-&gt;empty(); });</div></div><!-- fragment --><h3><code><a class="el" href="namespacefolly.html#afe413a7e07aa5e223b429ca3c4e887f8">acquireLocked()</a></code></h3>
<p>Sometimes locking just one object won't be able to cut the mustard. Consider a function that needs to lock two <code>Synchronized</code> objects at the same time - for example, to copy some data from one to the other. At first sight, it looks like sequential <code><a class="el" href="namespacefolly_1_1detail.html#a5f33a5a02c2e1470bc6c268c8a8a183f">wlock()</a></code> calls will work just fine:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void fun(Synchronized&lt;vector&lt;int&gt;&gt;&amp; a, Synchronized&lt;vector&lt;int&gt;&gt;&amp; b) {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  auto lockedA = a.wlock();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  auto lockedB = b.wlock();</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  ... use lockedA and lockedB ...</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --><p>This code compiles and may even run most of the time, but embeds a deadly peril: if one threads call <code>fun(x, y)</code> and another thread calls <code>fun(y, x)</code>, then the two threads are liable to deadlocking as each thread will be waiting for a lock the other is holding. This issue is a classic that applies regardless of the fact the objects involved have the same type.</p>
<p>This classic problem has a classic solution: all threads must acquire locks in the same order. The actual order is not important, just the fact that the order is the same in all threads. Many libraries simply acquire mutexes in increasing order of their address, which is what we'll do, too. The <code><a class="el" href="namespacefolly.html#afe413a7e07aa5e223b429ca3c4e887f8">acquireLocked()</a></code> function takes care of all details of proper locking of two objects and offering their innards. It returns a <code>std::tuple</code> of <code>LockedPtr</code>s:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void fun(Synchronized&lt;vector&lt;int&gt;&gt;&amp; a, Synchronized&lt;vector&lt;int&gt;&gt;&amp; b) {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  auto ret = folly::acquireLocked(a, b);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  auto&amp; lockedA = std::get&lt;0&gt;(ret);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  auto&amp; lockedB = std::get&lt;1&gt;(ret);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  ... use lockedA and lockedB ...</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --><p>Note that C++ 17 introduces (structured binding syntax)[(<a href="http://wg21.link/P0144r2">http://wg21.link/P0144r2</a>)] which will make the returned tuple more convenient to use:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void fun(Synchronized&lt;vector&lt;int&gt;&gt;&amp; a, Synchronized&lt;vector&lt;int&gt;&gt;&amp; b) {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  auto [lockedA, lockedB] = folly::acquireLocked(a, b);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  ... use lockedA and lockedB ...</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div></div><!-- fragment --><p>An <code><a class="el" href="namespacefolly.html#ac5bec7561d4f7c4187da9e1c7fc4693e">acquireLockedPair()</a></code> function is also available, which returns a <code>std::pair</code> instead of a <code>std::tuple</code>. This is more convenient to use in many situations, until compiler support for structured bindings is more widely available.</p>
<h3>Synchronizing several data items with one mutex</h3>
<p>The library is geared at protecting one object of a given type with a mutex. However, sometimes we'd like to protect two or more members with the same mutex. Consider for example a bidirectional map, i.e. a map that holds an <code>int</code> to <code>string</code> mapping and also the converse <code>string</code> to <code>int</code> mapping. The two maps would need to be manipulated simultaneously. There are at least two designs that come to mind.</p>
<h4>Using a nested <code>struct</code></h4>
<p>You can easily pack the needed data items in a little struct. For example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;class Server {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  struct BiMap {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    map&lt;int, string&gt; direct;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    map&lt;string, int&gt; inverse;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  };</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  Synchronized&lt;BiMap&gt; bimap_;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  ...</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;};</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;...</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;bimap_.withLock([](auto&amp; locked) {</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  locked.direct[0] = &quot;zero&quot;;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  locked.inverse[&quot;zero&quot;] = 0;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;});</div></div><!-- fragment --><p>With this code in tow you get to use <code>bimap_</code> just like any other <code>Synchronized</code> object, without much effort.</p>
<h4>Using <code>std::tuple</code></h4>
<p>If you won't stop short of using a spaceship-era approach, <code>std::tuple</code> is there for you. The example above could be rewritten for the same functionality like this:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;class Server {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  Synchronized&lt;tuple&lt;map&lt;int, string&gt;, map&lt;string, int&gt;&gt;&gt; bimap_;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  ...</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;};</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;...</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;bimap_.withLock([](auto&amp; locked) {</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  get&lt;0&gt;(locked)[0] = &quot;zero&quot;;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  get&lt;1&gt;(locked)[&quot;zero&quot;] = 0;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;});</div></div><!-- fragment --><p>The code uses <code>std::get</code> with compile-time integers to access the fields in the tuple. The relative advantages and disadvantages of using a local struct vs. <code>std::tuple</code> are quite obvious - in the first case you need to invest in the definition, in the second case you need to put up with slightly more verbose and less clear access syntax.</p>
<h3>Summary</h3>
<p><code>Synchronized</code> and its supporting tools offer you a simple, robust paradigm for mutual exclusion-based concurrency. Instead of manually pairing data with the mutexes that protect it and relying on convention to use them appropriately, you can benefit of encapsulation and typechecking to offload a large part of that task and to provide good guarantees. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
