<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: `folly/Benchmark.h`</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_proxygen_folly_folly_docs_Benchmark.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">`folly/Benchmark.h` </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><code>folly/Benchmark.h</code> provides a simple framework for writing and executing benchmarks. Currently the framework targets only single-threaded testing (though you can internally use fork-join parallelism and measure total run time).</p>
<p>To use this library, you need to be using gcc 4.6 or later. Include <code>folly/Benchmark.h</code> and make sure <code>folly/benchmark.cpp</code> is part of the build (either directly or packaged with a library).</p>
<h3>Overview</h3>
<hr/>
<p>Using <code>folly/Benchmark.h</code> is very simple. Here's an example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#include &lt;folly/Benchmark.h&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#include &lt;folly/container/Foreach.h&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;#include &lt;vector&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;using namespace std;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;using namespace folly;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;BENCHMARK(insertFrontVector) {</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  // Let&#39;s insert 100 elements at the front of a vector</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  vector&lt;int&gt; v;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  FOR_EACH_RANGE (i, 0, 100) {</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    v.insert(v.begin(), i);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  }</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;BENCHMARK(insertBackVector) {</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  // Let&#39;s insert 100 elements at the back of a vector</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  vector&lt;int&gt; v;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  FOR_EACH_RANGE (i, 0, 100) {</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    v.insert(v.end(), i);</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;  }</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;}</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;int main() {</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;  runBenchmarks();</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;}</div></div><!-- fragment --><p>Compiling and running this code produces to the standard output:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;===============================================================================</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;test.cpp                                              relative ns/iter  iters/s</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;===============================================================================</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;insertFrontVector                                                3.84K  260.38K</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;insertBackVector                                                 1.61K  622.75K</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;===============================================================================</div></div><!-- fragment --><p>Let's worry about the empty column "relative" later. The table contains, for each benchmark, the time spent per call and the converse number of calls per second. Numbers are represented in metric notation (K for thousands, M for millions etc). As expected, in this example the second function is much faster (fewer ns/iter and more iters/s).</p>
<p>The macro <code>BENCHMARK</code> introduces a function and also adds it to an internal array containing all benchmarks in the system. The defined function takes no arguments and returns <code>void</code>.</p>
<p>The framework calls the function many times to collect statistics about it. Sometimes the function itself would want to do that iteration&mdash;for example how about inserting <code>n</code> elements instead of 100 elements? To do the iteration internally, use <code>BENCHMARK</code> with two parameters. The second parameter is the number of iterations and is passed by the framework down to the function. The type of the count is implicitly <code>unsigned</code>. Consider a slightly reworked example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#include &lt;folly/Benchmark.h&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#include &lt;folly/container/Foreach.h&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;#include &lt;vector&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;using namespace std;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;using namespace folly;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;BENCHMARK(insertFrontVector, n) {</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  vector&lt;int&gt; v;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  FOR_EACH_RANGE (i, 0, n) {</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    v.insert(v.begin(), i);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  }</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;BENCHMARK(insertBackVector, n) {</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  vector&lt;int&gt; v;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  FOR_EACH_RANGE (i, 0, n) {</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    v.insert(v.end(), i);</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  }</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;}</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;int main() {</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  runBenchmarks();</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;}</div></div><!-- fragment --><p>The produced numbers are substantially different:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;===============================================================================</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Benchmark                                             relative ns/iter  iters/s</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;===============================================================================</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;insertFrontVector                                               39.92    25.05M</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;insertBackVector                                                 3.46   288.89M</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;===============================================================================</div></div><!-- fragment --><p>Now the numbers indicate the speed of one single insertion because the framework assumed the user-defined function used internal iteration (which it does). So inserting at the back of a vector is more than 10 times faster than inserting at the front! Speaking of comparisons...</p>
<h3>Baselines</h3>
<hr/>
<p>Choosing one or more good baselines is a crucial activity in any measurement. Without a baseline there is little information to derive from the sheer numbers. If, for example, you do experimentation with algorithms, a good baseline is often an established approach (e.g. the built-in <code>std::sort</code> for sorting). Essentially all experimental numbers should be compared against some baseline.</p>
<p>To support baseline-driven measurements, <code>folly/Benchmark.h</code> defines <code>BENCHMARK_RELATIVE</code>, which works much like <code>BENCHMARK</code>, except it considers the most recent lexically-ocurring <code>BENCHMARK</code> a baseline, and fills the "relative" column. Say, for example, we want to use front insertion for a vector as a baseline and see how back insertion compares with it:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#include &lt;folly/Benchmark.h&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#include &lt;folly/container/Foreach.h&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;#include &lt;vector&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;using namespace std;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;using namespace folly;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;BENCHMARK(insertFrontVector, n) {</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  vector&lt;int&gt; v;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  FOR_EACH_RANGE (i, 0, n) {</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    v.insert(v.begin(), i);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  }</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;BENCHMARK_RELATIVE(insertBackVector, n) {</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  vector&lt;int&gt; v;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  FOR_EACH_RANGE (i, 0, n) {</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    v.insert(v.end(), i);</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  }</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;}</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;int main() {</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  runBenchmarks();</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;}</div></div><!-- fragment --><p>This program prints something like:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;===============================================================================</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Benchmark                                             relative ns/iter  iters/s</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;===============================================================================</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;insertFrontVector                                               42.65    23.45M</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;insertBackVector                                     1208.24%    3.53   283.30M</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;===============================================================================</div></div><!-- fragment --><p>showing the 1208.24% relative speed advantage of inserting at the back compared to front. The scale is chosen in such a way that 100% means identical speed, numbers smaller than 100% indicate the benchmark is slower than the baseline, and numbers greater than 100% indicate the benchmark is faster. For example, if you see 42% that means the speed of the benchmark is 0.42 of the baseline speed. If you see 123%, it means the benchmark is 23% or 1.23 times faster.</p>
<p>To close the current benchmark group and start another, simply use <code>BENCHMARK</code> again.</p>
<h3>Ars Gratia Artis</h3>
<hr/>
<p>If you want to draw a horizontal line of dashes (e.g. at the end of a group or for whatever reason), use <code><a class="el" href="Benchmark_8h.html#ad1a51c4a45b1b79ecd3dcb2dd8202cc5">BENCHMARK_DRAW_LINE()</a></code>. The line fulfills a purely aesthetic role; it doesn't interact with measurements in any way.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;BENCHMARK(foo) {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  Foo foo;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  foo.doSomething();</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;BENCHMARK_DRAW_LINE();</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;BENCHMARK(bar) {</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  Bar bar;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  bar.doSomething();</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --><h3>Suspending a benchmark</h3>
<hr/>
<p>Sometimes benchmarking code must do some preparation work that is physically inside the benchmark function, but should not take part to its time budget. To temporarily suspend the benchmark, use the pseudo-statement <code>BENCHMARK_SUSPEND</code> as follows:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;BENCHMARK(insertBackVector, n) {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  vector&lt;int&gt; v;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  BENCHMARK_SUSPEND {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    v.reserve(n);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  }</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  FOR_EACH_RANGE (i, 0, n) {</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    v.insert(v.end(), i);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  }</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --><p>The preallocation effected with <code>v.reserve(n)</code> will not count toward the total run time of the benchmark.</p>
<p>Only the main thread should call <code>BENCHMARK_SUSPEND</code> (and of course it should not call it while other threads are doing actual work). This is because the timer is application-global.</p>
<p>If the scope introduced by <code>BENCHMARK_SUSPEND</code> is not desired, you may want to "manually" use the <code>BenchmarkSuspender</code> type. Constructing such an object suspends time measurement, and destroying it resumes the measurement. If you want to resume time measurement before the destructor, call <code>dismiss</code> against the <code>BenchmarkSuspender</code> object. The previous example could have been written like this:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;BENCHMARK(insertBackVector, n) {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  BenchmarkSuspender braces;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  vector&lt;int&gt; v;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  v.reserve(n);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  braces.dismiss();</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  FOR_EACH_RANGE (i, 0, n) {</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    v.insert(v.end(), i);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  }</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --><h3><code>doNotOptimizeAway</code></h3>
<hr/>
<p>Finally, the small utility function <code>doNotOptimizeAway</code> prevents compiler optimizations that may interfere with benchmarking . Call doNotOptimizeAway(var) against variables that you use for benchmarking but otherwise are useless. The compiler tends to do a good job at eliminating unused variables, and this function fools it into thinking a variable is in fact needed. Example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;BENCHMARK(fpOps, n) {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  double d = 1;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  FOR_EACH_RANGE (i, 1, n) {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    d += i;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    d -= i;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    d *= i;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    d /= i;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  }</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  doNotOptimizeAway(d);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;}</div></div><!-- fragment --><h3><a class="el" href="structA.html">A</a> look under the hood</h3>
<hr/>
<p><code>folly/Benchmark.h</code> has a simple, systematic approach to collecting timings.</p>
<p>First, it organizes measurements in several large epochs, and takes the minimum over all epochs. Taking the minimum gives the closest result to the real runtime. Benchmark timings are not a regular random variable that fluctuates around an average. Instead, the real time we're looking for is one to which there's a variety of additive noise (i.e. there is no noise that could actually shorten the benchmark time below its real value). In theory, taking an infinite amount of samples and keeping the minimum is the actual time that needs measuring. That's why the accuracy of benchmarking increases with the number of epochs.</p>
<p>Clearly, in real functioning there will also be noise and a variety of effects caused by the running context. But the noise during the benchmark (straight setup, simple looping) is a poor model for the noise in the real application. So taking the minimum across several epochs is the most informative result.</p>
<p>Inside each epoch, the function measured is iterated an increasing number of times until the total runtime is large enough to make noise negligible. At that point the time is collected, and the time per iteration is computed. As mentioned, the minimum time per iteration over all epochs is the final result.</p>
<p>The timer function used is <code>clock_gettime</code> with the <code>CLOCK_REALTIME</code> clock id. Note that you must use a recent Linux kernel (2.6.38 or newer), otherwise the resolution of <code>CLOCK_REALTIME</code> is inadequate. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
