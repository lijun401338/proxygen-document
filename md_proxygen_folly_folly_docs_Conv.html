<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: `folly/Conv.h`</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_proxygen_folly_folly_docs_Conv.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">`folly/Conv.h` </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><code>folly/Conv.h</code> is a one-stop-shop for converting values across types. Its main features are simplicity of the API (only the names <code>to</code> and <code>toAppend</code> must be memorized), speed (folly is significantly faster, sometimes by an order of magnitude, than comparable APIs), and correctness.</p>
<h3>Synopsis</h3>
<hr/>
<p>All examples below are assume to have included <code>folly/Conv.h</code> and issued <code>using namespace folly;</code> You will need:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// To format as text and append to a string, use toAppend.</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;fbstring str;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;toAppend(2.5, &amp;str);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;CHECK_EQ(str, &quot;2.5&quot;);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;// Multiple arguments are okay, too. Just put the pointer to string at the end.</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;toAppend(&quot; is &quot;, 2, &quot; point &quot;, 5, &amp;str);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;CHECK_EQ(str, &quot;2.5 is 2 point 5&quot;);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;// You don&#39;t need to use fbstring (although it&#39;s much faster for conversions and in general).</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;std::string stdStr;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;toAppend(&quot;Pi is about &quot;, 22.0 / 7, &amp;stdStr);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;// In general, just use to&lt;TargetType&gt;(sourceValue). It returns its result by value.</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;stdStr = to&lt;std::string&gt;(&quot;Variadic &quot;, &quot;arguments also accepted.&quot;);</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;// to&lt;fbstring&gt; is 2.5x faster than to&lt;std::string&gt; for typical workloads.</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;str = to&lt;fbstring&gt;(&quot;Variadic &quot;, &quot;arguments also accepted.&quot;);</div></div><!-- fragment --><h3>Integral-to-integral conversion</h3>
<hr/>
<p>Using <code>to&lt;Target&gt;(value)</code> to convert one integral type to another will behave as follows:</p>
<ul>
<li>If the target type can accommodate all possible values of the source value, the value is implicitly converted. No further action is taken. Example:</li>
</ul>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;short x;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;unsigned short y;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;...</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;auto a = to&lt;int&gt;(x); // zero overhead conversion</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;auto b = to&lt;int&gt;(y); // zero overhead conversion</div></div><!-- fragment --><ul>
<li>Otherwise, <code>to</code> inserts bounds checks and throws <code>std::range_error</code> if the target type cannot accommodate the source value. Example:</li>
</ul>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;short x;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;unsigned short y;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;long z;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;...</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;x = 123;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;auto a = to&lt;unsigned short&gt;(x); // fine</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;x = -1;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;a = to&lt;unsigned short&gt;(x); // THROWS</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;z = 2000000000;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;auto b = to&lt;int&gt;(z); // fine</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;z += 1000000000;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;b = to&lt;int&gt;(z); // THROWS</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;auto b = to&lt;unsigned int&gt;(z); // fine</div></div><!-- fragment --><h3>Anything-to-string conversion</h3>
<hr/>
<p>As mentioned, there are two primitives for converting anything to string: <code>to</code> and <code>toAppend</code>. They support the same set of source types, literally by definition (<code>to</code> is implemented in terms of <code>toAppend</code> for all types). The call <code>toAppend(value, &amp;str)</code> formats and appends <code>value</code> to <code>str</code> whereas <code>to&lt;StringType&gt;(value)</code> formats <code>value</code> as a <code>StringType</code> and returns the result by value. Currently, the supported <code>StringType</code>s are <code>std::string</code> and <code>fbstring</code></p>
<p>Both <code>toAppend</code> and <code>to</code> with a string type as a target support variadic arguments. Each argument is converted in turn. For <code>toAppend</code> the last argument in a variadic list must be the address of a supported string type (no need to specify the string type as a template argument).</p>
<h4>Integral-to-string conversion</h4>
<p>Nothing special here - integrals are converted to strings in decimal format, with a '-' prefix for negative values. Example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;auto a = to&lt;fbstring&gt;(123);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;assert(a == &quot;123&quot;);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;a = to&lt;fbstring&gt;(-456);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;assert(a == &quot;-456&quot;);</div></div><!-- fragment --><p>The conversion implementation is aggressively optimized. It converts two digits at a time assisted by fixed-size tables. Converting a <code>long</code> to an <code>fbstring</code> is 3.6x faster than using <code>boost::lexical_cast</code> and 2.5x faster than using <code>sprintf</code> even though the latter is used in conjunction with a stack-allocated constant-size buffer.</p>
<p>Note that converting integral types to <code>fbstring</code> has a particular advantage compared to converting to <code>std::string</code> No integral type (&lt;= 64 bits) has more than 20 decimal digits including sign. Since <code>fbstring</code> employs the small string optimization for up to 23 characters, converting an integral to <code>fbstring</code> is guaranteed to not allocate memory, resulting in significant speed and memory locality gains. Benchmarks reveal a 2x gain on a typical workload.</p>
<h4><code>char</code> to string conversion</h4>
<p>Although <code>char</code> is technically an integral type, most of the time you want the string representation of <code>'a'</code> to be <code>"a"</code>, not <code>96</code> That's why <code>folly/Conv.h</code> handles <code>char</code> as a special case that does the expected thing. Note that <code>signed char</code> and <code>unsigned char</code> are still considered integral types.</p>
<h4>Floating point to string conversion</h4>
<p><code>folly/Conv.h</code> uses <a href="http://code.google.com/p/double-conversion/">V8's double conversion</a> routines. They are accurate and fast; on typical workloads, <code>to&lt;fbstring&gt;(doubleValue)</code> is 1.9x faster than <code>sprintf</code> and 5.5x faster than <code>boost::lexical_cast</code> (It is also 1.3x faster than <code>to&lt;std::string&gt;(doubleValue)</code></p>
<h4><code>const char*</code> to string conversion</h4>
<p>For completeness, <code>folly/Conv.h</code> supports <code>const char*</code> including i.e. string literals. The "conversion" consists, of course, of the string itself. Example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;auto s = to&lt;fbstring&gt;(&quot;Hello, world&quot;);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;assert(s == &quot;Hello, world&quot;);</div></div><!-- fragment --><h4>Anything from string conversion (i.e. parsing)</h4>
<hr/>
<p><code>folly/Conv.h</code> includes three kinds of parsing routines:</p>
<ul>
<li><code>to&lt;Type&gt;(const char* begin, const char* end)</code> rigidly converts the range [begin, end) to <code>Type</code> These routines have drastic restrictions (e.g. allow no leading or trailing whitespace) and are intended as an efficient back-end for more tolerant routines.</li>
<li><code>to&lt;Type&gt;(stringy)</code> converts <code>stringy</code> to <code>Type</code> Value <code>stringy</code> may be of type <code>const char*</code>, <code>StringPiece</code>, <code>std::string</code>, or <code>fbstring</code> (Technically, the requirement is that <code>stringy</code> implicitly converts to a <code>StringPiece</code></li>
<li><code>to&lt;Type&gt;(&amp;stringPiece)</code> parses with progress information: given <code>stringPiece</code> of type <code>StringPiece</code> it parses as much as possible from it as type <code>Type</code> and alters <code>stringPiece</code> to remove the munched characters. This is easiest clarified by an example:</li>
</ul>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;fbstring s = &quot; 1234 angels on a pin&quot;;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;StringPiece pc(s);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;auto x = to&lt;int&gt;(&amp;pc);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;assert(x == 1234);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;assert(pc == &quot; angels on a pin&quot;;</div></div><!-- fragment --><p>Note how the routine ate the leading space but not the trailing one.</p>
<h4>Parsing integral types</h4>
<p>Parsing integral types is unremarkable - decimal format is expected, optional `'+'<code>or</code>'-'<code>sign for signed types, but no optional</code>'+'<code>is allowed for unsigned types. The one remarkable element is speed - parsing typical</code>long<code>values is 6x faster than </code>sscanf<code>.</code>folly/Conv.h` uses aggressive loop unrolling and table-assisted SIMD-style code arrangement that avoids integral division (slow) and data dependencies across operations (ILP-unfriendly). Example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;fbstring str = &quot;  12345  &quot;;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;assert(to&lt;int&gt;(str) == 12345);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;str = &quot;  12345six seven eight&quot;;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;StringPiece pc(str);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;assert(to&lt;int&gt;(&amp;pc) == 12345);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;assert(str == &quot;six seven eight&quot;);</div></div><!-- fragment --><h4>Parsing floating-point types</h4>
<p><code>folly/Conv.h</code> uses, again, <a href="http://code.google.com/p/double-conversion/">V8's double-conversion</a> routines as back-end. The speed is 3x faster than <code>sscanf</code> and 1.7x faster than in-home routines such as <code>parse&lt;double&gt;</code> But the more important detail is accuracy - even if you do code a routine that works faster than <code>to&lt;double&gt;</code> chances are it is incorrect and will fail in a variety of corner cases. Using <code>to&lt;double&gt;</code> is strongly recommended.</p>
<p>Note that if the string "NaN" (with any capitalization) is passed to <code>to&lt;double&gt;</code> then <code>NaN</code> is returned, which can be tested for as follows:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;fbstring str = &quot;nan&quot;; // &quot;NaN&quot;, &quot;NAN&quot;, etc.</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;double d = to&lt;double&gt;(str);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;if (std::isnan(d)) {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  // string was a valid representation of the double value NaN</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --><p>Note that passing "-NaN" (with any capitalization) to <code>to&lt;double&gt;</code> also returns <code>NaN</code>.</p>
<p>Note that if the strings "inf" or "infinity" (with any capitalization) are passed to <code>to&lt;double&gt;</code> then <code>infinity</code> is returned, which can be tested for as follows:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;fbstring str = &quot;inf&quot;; // &quot;Inf&quot;, &quot;INF&quot;, &quot;infinity&quot;, &quot;Infinity&quot;, etc.</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;double d = to&lt;double&gt;(str);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;if (std::isinf(d)) {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  // string was a valid representation of one of the double values +Infinity</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  // or -Infinity</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --><p>Note that passing "-inf" or "-infinity" (with any capitalization) to <code>to&lt;double&gt;</code> returns <code>-infinity</code> rather than <code>+infinity</code>. The sign of the <code>infinity</code> can be tested for as follows:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;fbstring str = &quot;-inf&quot;; // or &quot;inf&quot;, &quot;-Infinity&quot;, &quot;+Infinity&quot;, etc.</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;double d = to&lt;double&gt;(str);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;if (d == std::numeric_limits&lt;double&gt;::infinity()) {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  // string was a valid representation of the double value +Infinity</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;} else if (d == -std::numeric_limits&lt;double&gt;::infinity()) {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  // string was a valid representation of the double value -Infinity</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --><p>Note that if an unparseable string is passed to <code>to&lt;double&gt;</code> then an exception is thrown, rather than <code>NaN</code> being returned. This can be tested for as follows:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;fbstring str = &quot;not-a-double&quot;; // Or &quot;1.1.1&quot;, &quot;&quot;, &quot;$500.00&quot;, etc.</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;double d;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;try {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  d = to&lt;double&gt;(str);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;} catch (const std::range_error &amp;) {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  // string could not be parsed</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --><p>Note that the empty string (<code>""</code>) is an unparseable value, and will cause <code>to&lt;double&gt;</code> to throw an exception.</p>
<h4>Non-throwing interfaces</h4>
<p><code>tryTo&lt;T&gt;</code> is the non-throwing variant of <code>to&lt;T&gt;</code>. It returns an <code>Expected&lt;T, ConversionCode&gt;</code>. You can think of <code>Expected</code> as like an <code>Optional&lt;T&gt;</code>, but if the conversion failed, <code>Expected</code> stores an error code instead of a <code>T</code>.</p>
<p><code>tryTo&lt;T&gt;</code> has similar performance as <code>to&lt;T&gt;</code> when the conversion is successful. On the error path, you can expect <code>tryTo&lt;T&gt;</code> to be roughly three orders of magnitude faster than the throwing <code>to&lt;T&gt;</code> and to completely avoid any lock contention arising from stack unwinding.</p>
<p>Here is how to use non-throwing conversions:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;auto t1 = tryTo&lt;int&gt;(str);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;if (t1.hasValue()) {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  use(t1.value());</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div></div><!-- fragment --><p><code>Expected</code> has a composability feature to make the above pattern simpler.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;tryTo&lt;int&gt;(str).then([](int i) { use(i); });</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
