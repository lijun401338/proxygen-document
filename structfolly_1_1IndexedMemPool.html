<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structfolly_1_1IndexedMemPool.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="structfolly_1_1IndexedMemPool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structfolly_1_1IndexedMemPool.png" usemap="#folly::IndexedMemPool_3C_20T_2C_20NumLocalLists_5F_2C_20LocalListLimit_5F_2C_20Atom_2C_20Traits_20_3E_map" alt=""/>
  <map id="folly::IndexedMemPool_3C_20T_2C_20NumLocalLists_5F_2C_20LocalListLimit_5F_2C_20Atom_2C_20Traits_20_3E_map" name="folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt;_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool_1_1LocalList.html">LocalList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool_1_1Slot.html">Slot</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool_1_1TaggedPtr.html">TaggedPtr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac0e99c90c5be51024f0d212695d8b860"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="structfolly_1_1IndexedMemPool.html#ac0e99c90c5be51024f0d212695d8b860aec01e4ff6a7b8dcb5201fdf00805226d">NumLocalLists</a> = NumLocalLists_, 
<a class="el" href="structfolly_1_1IndexedMemPool.html#ac0e99c90c5be51024f0d212695d8b860a2caa5effafbb6651c4f648091c78b31b">LocalListLimit</a> = LocalListLimit_
 }</td></tr>
<tr class="separator:ac0e99c90c5be51024f0d212695d8b860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87187fb2eb39c00082508e7f1587998f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#a87187fb2eb39c00082508e7f1587998f">value_type</a></td></tr>
<tr class="separator:a87187fb2eb39c00082508e7f1587998f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeeae756d8e52f9583cc3a84f62e4644"><td class="memItemLeft" align="right" valign="top">typedef std::unique_ptr&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, <a class="el" href="structfolly_1_1detail_1_1IndexedMemPoolRecycler.html">detail::IndexedMemPoolRecycler</a>&lt; <a class="el" href="structfolly_1_1IndexedMemPool.html">IndexedMemPool</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#abeeae756d8e52f9583cc3a84f62e4644">UniquePtr</a></td></tr>
<tr class="separator:abeeae756d8e52f9583cc3a84f62e4644"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a08662eaf85787266e6e8ad9909c38423"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#a08662eaf85787266e6e8ad9909c38423">IndexedMemPool</a> (<a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> <a class="el" href="structfolly_1_1IndexedMemPool.html#a0d751f8f1540725aa89df02f3b1a2870">capacity</a>)</td></tr>
<tr class="separator:a08662eaf85787266e6e8ad9909c38423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45a8a3711be812a2b3b4e9434486790"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#ae45a8a3711be812a2b3b4e9434486790">~IndexedMemPool</a> ()</td></tr>
<tr class="memdesc:ae45a8a3711be812a2b3b4e9434486790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys all of the contained elements.  <a href="#ae45a8a3711be812a2b3b4e9434486790">More...</a><br /></td></tr>
<tr class="separator:ae45a8a3711be812a2b3b4e9434486790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d751f8f1540725aa89df02f3b1a2870"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#a0d751f8f1540725aa89df02f3b1a2870">capacity</a> ()</td></tr>
<tr class="separator:a0d751f8f1540725aa89df02f3b1a2870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3462c05eb457f0accc512d55ad14017"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#ac3462c05eb457f0accc512d55ad14017">maxAllocatedIndex</a> () const </td></tr>
<tr class="separator:ac3462c05eb457f0accc512d55ad14017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ad5aa9bc8b6b5eddbbfd93fecf71a5"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a26ad5aa9bc8b6b5eddbbfd93fecf71a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#a26ad5aa9bc8b6b5eddbbfd93fecf71a5">allocIndex</a> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:a26ad5aa9bc8b6b5eddbbfd93fecf71a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470733cf19aeae3fc83b826bfbaa2086"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a470733cf19aeae3fc83b826bfbaa2086"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structfolly_1_1IndexedMemPool.html#abeeae756d8e52f9583cc3a84f62e4644">UniquePtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#a470733cf19aeae3fc83b826bfbaa2086">allocElem</a> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:a470733cf19aeae3fc83b826bfbaa2086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf4646be9fd0a8eabb4356fb31d04a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#a8bf4646be9fd0a8eabb4356fb31d04a7">recycleIndex</a> (<a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> idx)</td></tr>
<tr class="memdesc:a8bf4646be9fd0a8eabb4356fb31d04a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives up ownership previously granted by alloc()  <a href="#a8bf4646be9fd0a8eabb4356fb31d04a7">More...</a><br /></td></tr>
<tr class="separator:a8bf4646be9fd0a8eabb4356fb31d04a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99f91ab6b82f5cbe57ae0494117a268"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#ae99f91ab6b82f5cbe57ae0494117a268">operator[]</a> (<a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> idx)</td></tr>
<tr class="memdesc:ae99f91ab6b82f5cbe57ae0494117a268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the pooled element referenced by idx.  <a href="#ae99f91ab6b82f5cbe57ae0494117a268">More...</a><br /></td></tr>
<tr class="separator:ae99f91ab6b82f5cbe57ae0494117a268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac067ef099f71f4fe14e34b1ea7135ce1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#ac067ef099f71f4fe14e34b1ea7135ce1">operator[]</a> (<a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> idx) const </td></tr>
<tr class="memdesc:ac067ef099f71f4fe14e34b1ea7135ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the pooled element referenced by idx.  <a href="#ac067ef099f71f4fe14e34b1ea7135ce1">More...</a><br /></td></tr>
<tr class="separator:ac067ef099f71f4fe14e34b1ea7135ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24f1367d1ed263e3f810cb5322a0a30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#af24f1367d1ed263e3f810cb5322a0a30">locateElem</a> (const <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a> *elem) const </td></tr>
<tr class="separator:af24f1367d1ed263e3f810cb5322a0a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b91e16f6e73a440a776fab01041157"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#a61b91e16f6e73a440a776fab01041157">isAllocated</a> (<a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> idx) const </td></tr>
<tr class="memdesc:a61b91e16f6e73a440a776fab01041157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff idx has been alloc()ed and not <a class="el" href="structfolly_1_1IndexedMemPool.html#a8bf4646be9fd0a8eabb4356fb31d04a7" title="Gives up ownership previously granted by alloc() ">recycleIndex()</a>ed.  <a href="#a61b91e16f6e73a440a776fab01041157">More...</a><br /></td></tr>
<tr class="separator:a61b91e16f6e73a440a776fab01041157"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afef094566f6ab4631e220c46e8e24e89"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#afef094566f6ab4631e220c46e8e24e89">maxIndexForCapacity</a> (<a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> <a class="el" href="structfolly_1_1IndexedMemPool.html#a0d751f8f1540725aa89df02f3b1a2870">capacity</a>)</td></tr>
<tr class="separator:afef094566f6ab4631e220c46e8e24e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4eb509a23dfe5cfa47c4d6390d8168"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#a7a4eb509a23dfe5cfa47c4d6390d8168">capacityForMaxIndex</a> (<a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> maxIndex)</td></tr>
<tr class="separator:a7a4eb509a23dfe5cfa47c4d6390d8168"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a66ebc64f81b4d965c230a6dd1ede1521"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#a66ebc64f81b4d965c230a6dd1ede1521">kSlotSize</a> = <a class="el" href="namespacefolly.html#a7c631f0179944e4771e98d398db760dd">sizeof</a>(<a class="el" href="structfolly_1_1IndexedMemPool_1_1Slot.html">Slot</a>)</td></tr>
<tr class="separator:a66ebc64f81b4d965c230a6dd1ede1521"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a1f196b7dcd5f4322313b983307fa1be1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#a1f196b7dcd5f4322313b983307fa1be1">slotIndex</a> (<a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> idx) const </td></tr>
<tr class="separator:a1f196b7dcd5f4322313b983307fa1be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bed1acb2c122bd20384b31b201bf2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfolly_1_1IndexedMemPool_1_1Slot.html">Slot</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">slot</a> (<a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> idx)</td></tr>
<tr class="separator:a54bed1acb2c122bd20384b31b201bf2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a92f08af2d6bf594771881006094d5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structfolly_1_1IndexedMemPool_1_1Slot.html">Slot</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#a84a92f08af2d6bf594771881006094d5">slot</a> (<a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> idx) const </td></tr>
<tr class="separator:a84a92f08af2d6bf594771881006094d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcee8e1f9fb4bcec8deae1b686dc7307"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#abcee8e1f9fb4bcec8deae1b686dc7307">globalPush</a> (<a class="el" href="structfolly_1_1IndexedMemPool_1_1Slot.html">Slot</a> &amp;<a class="el" href="StringKeyedBenchmark_8cpp.html#aa7f1a46e86fabf3df0ec876cd34220c2">s</a>, <a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> <a class="el" href="structfolly_1_1IndexedMemPool.html#a77c13722bca3b74a0fc4c8dfc5264110">localHead</a>)</td></tr>
<tr class="separator:abcee8e1f9fb4bcec8deae1b686dc7307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac891d55dbb470b95ea9f16980ddba99c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#ac891d55dbb470b95ea9f16980ddba99c">localPush</a> (<a class="el" href="classfolly_1_1AtomicStruct.html">AtomicStruct</a>&lt; <a class="el" href="structfolly_1_1IndexedMemPool_1_1TaggedPtr.html">TaggedPtr</a>, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a> &gt; &amp;head, <a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> idx)</td></tr>
<tr class="separator:ac891d55dbb470b95ea9f16980ddba99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fdb4eb5d938e018e553bb2f4c1f941d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#a8fdb4eb5d938e018e553bb2f4c1f941d">globalPop</a> ()</td></tr>
<tr class="separator:a8fdb4eb5d938e018e553bb2f4c1f941d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df3894e3276c9d0eeba6a6af5d89240"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#a1df3894e3276c9d0eeba6a6af5d89240">localPop</a> (<a class="el" href="classfolly_1_1AtomicStruct.html">AtomicStruct</a>&lt; <a class="el" href="structfolly_1_1IndexedMemPool_1_1TaggedPtr.html">TaggedPtr</a>, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a> &gt; &amp;head)</td></tr>
<tr class="separator:a1df3894e3276c9d0eeba6a6af5d89240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c13722bca3b74a0fc4c8dfc5264110"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfolly_1_1AtomicStruct.html">AtomicStruct</a>&lt; <a class="el" href="structfolly_1_1IndexedMemPool_1_1TaggedPtr.html">TaggedPtr</a>, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#a77c13722bca3b74a0fc4c8dfc5264110">localHead</a> ()</td></tr>
<tr class="separator:a77c13722bca3b74a0fc4c8dfc5264110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69be5560e3908957a2855388350bbbe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#a69be5560e3908957a2855388350bbbe9">markAllocated</a> (<a class="el" href="structfolly_1_1IndexedMemPool_1_1Slot.html">Slot</a> &amp;<a class="el" href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">slot</a>)</td></tr>
<tr class="separator:a69be5560e3908957a2855388350bbbe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:abcd1a5d8cc16433d2da9f6179cdee914"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#abcd1a5d8cc16433d2da9f6179cdee914">mmapLength_</a></td></tr>
<tr class="separator:abcd1a5d8cc16433d2da9f6179cdee914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0e8b2087c4fbf6ffc4edc84d0c9ad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#a8c0e8b2087c4fbf6ffc4edc84d0c9ad8">actualCapacity_</a></td></tr>
<tr class="separator:a8c0e8b2087c4fbf6ffc4edc84d0c9ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de3d071fbddfc1dae27a23e52b55b6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>&lt; <a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#a5de3d071fbddfc1dae27a23e52b55b6e">size_</a></td></tr>
<tr class="separator:a5de3d071fbddfc1dae27a23e52b55b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ce967c5980255616eb717751234215"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfolly_1_1IndexedMemPool_1_1Slot.html">Slot</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#a87ce967c5980255616eb717751234215">slots_</a></td></tr>
<tr class="separator:a87ce967c5980255616eb717751234215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273ddc208d0f0426b92263c0ca2ea94d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfolly_1_1IndexedMemPool_1_1LocalList.html">LocalList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#a273ddc208d0f0426b92263c0ca2ea94d">local_</a> [<a class="el" href="structfolly_1_1IndexedMemPool.html#ac0e99c90c5be51024f0d212695d8b860aec01e4ff6a7b8dcb5201fdf00805226d">NumLocalLists</a>]</td></tr>
<tr class="separator:a273ddc208d0f0426b92263c0ca2ea94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fe1c0e0a1b1f933451b10930a7f9e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfolly_1_1AtomicStruct.html">AtomicStruct</a>&lt; <a class="el" href="structfolly_1_1IndexedMemPool_1_1TaggedPtr.html">TaggedPtr</a>, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1IndexedMemPool.html#ad2fe1c0e0a1b1f933451b10930a7f9e3">globalHead_</a></td></tr>
<tr class="separator:ad2fe1c0e0a1b1f933451b10930a7f9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt;<br />
struct folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt;</h3>

<p>Instances of <a class="el" href="structfolly_1_1IndexedMemPool.html">IndexedMemPool</a> dynamically allocate and then pool their element type (T), returning 4-byte integer indices that can be passed to the pool's operator[] method to access or obtain pointers to the actual elements. The memory backing items returned from the pool will always be readable, even if items have been returned to the pool. These two features are useful for lock-free algorithms. The indexing behavior makes it easy to build tagged pointer-like-things, since a large number of elements can be managed using fewer bits than a full pointer. The access-after-free behavior makes it safe to read from T-s even after they have been recycled, since it is guaranteed that the memory won't have been returned to the OS and unmapped (the algorithm must still use a mechanism to validate that the read was correct, but it doesn't have to worry about page faults), and if the elements use internal sequence numbers it can be guaranteed that there won't be an ABA match due to the element being overwritten with a different type that has the same bit pattern.</p>
<p>The object lifecycle strategy is controlled by the Traits parameter. One strategy, implemented by IndexedMemPoolTraitsEagerRecycle, is to construct objects when they are allocated from the pool and destroy them when they are recycled. In this mode allocIndex and allocElem have emplace-like semantics. In another strategy, implemented by IndexedMemPoolTraitsLazyRecycle, objects are default-constructed the first time they are removed from the pool, and deleted when the pool itself is deleted. By default the first mode is used for non-trivial T, and the second is used for trivial T. Clients can customize the object lifecycle by providing their own Traits implementation. See <a class="el" href="structfolly_1_1IndexedMemPoolTraits.html">IndexedMemPoolTraits</a> for a Traits example.</p>
<p>IMPORTANT: Space for extra elements is allocated to account for those that are inaccessible because they are in other local lists, so the actual number of items that can be allocated ranges from capacity to capacity + (NumLocalLists_-1)*LocalListLimit_. This is important if you are trying to maximize the capacity of the pool while constraining the bit size of the resulting pointers, because the pointers will actually range up to the boosted capacity. See maxIndexForCapacity and capacityForMaxIndex.</p>
<p>To avoid contention, NumLocalLists_ free lists of limited (less than or equal to LocalListLimit_) size are maintained, and each thread retrieves and returns entries from its associated local list. If the local list becomes too large then elements are placed in bulk in a global free list. This allows items to be efficiently recirculated from consumers to producers. <a class="el" href="structfolly_1_1AccessSpreader.html">AccessSpreader</a> is used to access the local lists, so there is no performance advantage to having more local lists than L1 caches.</p>
<p>The pool mmap-s the entire necessary address space when the pool is constructed, but delays element construction. This means that only elements that are actually returned to the caller get paged into the process's resident set (RSS). </p>

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00159">159</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="abeeae756d8e52f9583cc3a84f62e4644"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::unique_ptr&lt;<a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, <a class="el" href="structfolly_1_1detail_1_1IndexedMemPoolRecycler.html">detail::IndexedMemPoolRecycler</a>&lt;<a class="el" href="structfolly_1_1IndexedMemPool.html">IndexedMemPool</a>&gt; &gt; <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::<a class="el" href="structfolly_1_1IndexedMemPool.html#abeeae756d8e52f9583cc3a84f62e4644">UniquePtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00163">163</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a87187fb2eb39c00082508e7f1587998f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a> <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::<a class="el" href="structfolly_1_1IndexedMemPool.html#a87187fb2eb39c00082508e7f1587998f">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00160">160</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="ac0e99c90c5be51024f0d212695d8b860"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ac0e99c90c5be51024f0d212695d8b860aec01e4ff6a7b8dcb5201fdf00805226d"></a>NumLocalLists&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac0e99c90c5be51024f0d212695d8b860a2caa5effafbb6651c4f648091c78b31b"></a>LocalListLimit&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00166">166</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;       {</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    <a class="code" href="structfolly_1_1IndexedMemPool.html#ac0e99c90c5be51024f0d212695d8b860aec01e4ff6a7b8dcb5201fdf00805226d">NumLocalLists</a> = NumLocalLists_,</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    <a class="code" href="structfolly_1_1IndexedMemPool.html#ac0e99c90c5be51024f0d212695d8b860a2caa5effafbb6651c4f648091c78b31b">LocalListLimit</a> = LocalListLimit_,</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;  };</div><div class="ttc" id="structfolly_1_1IndexedMemPool_html_ac0e99c90c5be51024f0d212695d8b860a2caa5effafbb6651c4f648091c78b31b"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#ac0e99c90c5be51024f0d212695d8b860a2caa5effafbb6651c4f648091c78b31b">folly::IndexedMemPool::LocalListLimit</a></div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00168">IndexedMemPool.h:168</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_ac0e99c90c5be51024f0d212695d8b860aec01e4ff6a7b8dcb5201fdf00805226d"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#ac0e99c90c5be51024f0d212695d8b860aec01e4ff6a7b8dcb5201fdf00805226d">folly::IndexedMemPool::NumLocalLists</a></div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00167">IndexedMemPool.h:167</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a08662eaf85787266e6e8ad9909c38423"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::<a class="el" href="structfolly_1_1IndexedMemPool.html">IndexedMemPool</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a pool that can allocate at least <em>capacity</em> elements, even if all the local lists are full </p>

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00192">192</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

<p>References <a class="el" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt_source.html#l00083">i</a>, and <a class="el" href="Conv_8cpp_source.html#l00050">value</a>.</p>
<div class="fragment"><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;      : <a class="code" href="structfolly_1_1IndexedMemPool.html#a8c0e8b2087c4fbf6ffc4edc84d0c9ad8">actualCapacity_</a>(<a class="code" href="structfolly_1_1IndexedMemPool.html#afef094566f6ab4631e220c46e8e24e89">maxIndexForCapacity</a>(<a class="code" href="structfolly_1_1IndexedMemPool.html#a0d751f8f1540725aa89df02f3b1a2870">capacity</a>)),</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        <a class="code" href="structfolly_1_1IndexedMemPool.html#a5de3d071fbddfc1dae27a23e52b55b6e">size_</a>(0),</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;        <a class="code" href="structfolly_1_1IndexedMemPool.html#ad2fe1c0e0a1b1f933451b10930a7f9e3">globalHead_</a>(TaggedPtr{}) {</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> needed = <span class="keyword">sizeof</span>(Slot) * (<a class="code" href="structfolly_1_1IndexedMemPool.html#a8c0e8b2087c4fbf6ffc4edc84d0c9ad8">actualCapacity_</a> + 1);</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    <span class="keywordtype">size_t</span> pagesize = size_t(sysconf(_SC_PAGESIZE));</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <a class="code" href="structfolly_1_1IndexedMemPool.html#abcd1a5d8cc16433d2da9f6179cdee914">mmapLength_</a> = ((needed - 1) &amp; ~(pagesize - 1)) + pagesize;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    assert(needed &lt;= <a class="code" href="structfolly_1_1IndexedMemPool.html#abcd1a5d8cc16433d2da9f6179cdee914">mmapLength_</a> &amp;&amp; <a class="code" href="structfolly_1_1IndexedMemPool.html#abcd1a5d8cc16433d2da9f6179cdee914">mmapLength_</a> &lt; needed + pagesize);</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    assert((<a class="code" href="structfolly_1_1IndexedMemPool.html#abcd1a5d8cc16433d2da9f6179cdee914">mmapLength_</a> % pagesize) == 0);</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    <a class="code" href="structfolly_1_1IndexedMemPool.html#a87ce967c5980255616eb717751234215">slots_</a> = <span class="keyword">static_cast&lt;</span>Slot*<span class="keyword">&gt;</span>(mmap(</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        <span class="keyword">nullptr</span>,</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        <a class="code" href="structfolly_1_1IndexedMemPool.html#abcd1a5d8cc16433d2da9f6179cdee914">mmapLength_</a>,</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;        PROT_READ | PROT_WRITE,</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        MAP_PRIVATE | MAP_ANONYMOUS,</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        -1,</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        0));</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="structfolly_1_1IndexedMemPool.html#a87ce967c5980255616eb717751234215">slots_</a> == MAP_FAILED) {</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;      assert(errno == ENOMEM);</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;      <span class="keywordflow">throw</span> std::bad_alloc();</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    }</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    <span class="comment">// Atom is expected to be std::atomic, which is trivially</span></div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    <span class="comment">// constructible, so we can avoid explicitly initializing the</span></div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    <span class="comment">// slots which would cause the whole mapped area to be paged in.</span></div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    <span class="comment">// TODO: Switch to is_trivially_constructible once support</span></div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    <span class="comment">// for GCC 4.9 is dropped for this file.</span></div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    <span class="keywordflow">if</span> <span class="comment">/* constexpr */</span> (!std::is_trivial&lt;Atom&lt;uint32_t&gt;&gt;<a class="code" href="namespacefolly.html#af765fccfa9242184196b4906286ada49">::value</a>) {</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> = 1; <a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> &lt; <a class="code" href="structfolly_1_1IndexedMemPool.html#a8c0e8b2087c4fbf6ffc4edc84d0c9ad8">actualCapacity_</a> + 1; <a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>++) {</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;        <span class="comment">// Atom is enforced above to be nothrow-default-constructible</span></div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;        <span class="keyword">new</span> (&amp;<a class="code" href="structfolly_1_1IndexedMemPool.html#a87ce967c5980255616eb717751234215">slots_</a>[<a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>].<a class="code" href="structfolly_1_1IndexedMemPool_1_1Slot.html#aaf1baf437986cfeff7fa9cf5f66210b5">localNext</a>) Atom&lt;uint32_t&gt;;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;        <span class="keyword">new</span> (&amp;<a class="code" href="structfolly_1_1IndexedMemPool.html#a87ce967c5980255616eb717751234215">slots_</a>[<a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>].<a class="code" href="structfolly_1_1IndexedMemPool_1_1Slot.html#a5579128d24f15779795c377dcc58fe7e">globalNext</a>) Atom&lt;uint32_t&gt;;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;      }</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    }</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;  }</div><div class="ttc" id="structfolly_1_1IndexedMemPool_html_a8c0e8b2087c4fbf6ffc4edc84d0c9ad8"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a8c0e8b2087c4fbf6ffc4edc84d0c9ad8">folly::IndexedMemPool::actualCapacity_</a></div><div class="ttdeci">uint32_t actualCapacity_</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00393">IndexedMemPool.h:393</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a5de3d071fbddfc1dae27a23e52b55b6e"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a5de3d071fbddfc1dae27a23e52b55b6e">folly::IndexedMemPool::size_</a></div><div class="ttdeci">Atom&lt; uint32_t &gt; size_</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00399">IndexedMemPool.h:399</a></div></div>
<div class="ttc" id="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt_html_a7e98b8a17c0aad30ba64d47b74e2a6c1"><div class="ttname"><a href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a></div><div class="ttdeci">i</div><div class="ttdef"><b>Definition:</b> <a href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt_source.html#l00083">gtest_output_test_golden_lin.txt:83</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_1_1Slot_html_a5579128d24f15779795c377dcc58fe7e"><div class="ttname"><a href="structfolly_1_1IndexedMemPool_1_1Slot.html#a5579128d24f15779795c377dcc58fe7e">folly::IndexedMemPool::Slot::globalNext</a></div><div class="ttdeci">Atom&lt; uint32_t &gt; globalNext</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00330">IndexedMemPool.h:330</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_ad2fe1c0e0a1b1f933451b10930a7f9e3"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#ad2fe1c0e0a1b1f933451b10930a7f9e3">folly::IndexedMemPool::globalHead_</a></div><div class="ttdeci">AtomicStruct&lt; TaggedPtr, Atom &gt; globalHead_</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00413">IndexedMemPool.h:413</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_1_1Slot_html_aaf1baf437986cfeff7fa9cf5f66210b5"><div class="ttname"><a href="structfolly_1_1IndexedMemPool_1_1Slot.html#aaf1baf437986cfeff7fa9cf5f66210b5">folly::IndexedMemPool::Slot::localNext</a></div><div class="ttdeci">Atom&lt; uint32_t &gt; localNext</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00329">IndexedMemPool.h:329</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_abcd1a5d8cc16433d2da9f6179cdee914"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#abcd1a5d8cc16433d2da9f6179cdee914">folly::IndexedMemPool::mmapLength_</a></div><div class="ttdeci">size_t mmapLength_</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00387">IndexedMemPool.h:387</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_afef094566f6ab4631e220c46e8e24e89"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#afef094566f6ab4631e220c46e8e24e89">folly::IndexedMemPool::maxIndexForCapacity</a></div><div class="ttdeci">static constexpr uint32_t maxIndexForCapacity(uint32_t capacity)</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00178">IndexedMemPool.h:178</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a0d751f8f1540725aa89df02f3b1a2870"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a0d751f8f1540725aa89df02f3b1a2870">folly::IndexedMemPool::capacity</a></div><div class="ttdeci">uint32_t capacity()</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00245">IndexedMemPool.h:245</a></div></div>
<div class="ttc" id="namespacefolly_html_af765fccfa9242184196b4906286ada49"><div class="ttname"><a href="namespacefolly.html#af765fccfa9242184196b4906286ada49">folly::value</a></div><div class="ttdeci">uint64_t value(const typename LockFreeRingBuffer&lt; T, Atom &gt;::Cursor &amp;rbcursor)</div><div class="ttdef"><b>Definition:</b> <a href="LockFreeRingBufferTest_8cpp_source.html#l00096">LockFreeRingBufferTest.cpp:96</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a87ce967c5980255616eb717751234215"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a87ce967c5980255616eb717751234215">folly::IndexedMemPool::slots_</a></div><div class="ttdeci">Slot * slots_</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00403">IndexedMemPool.h:403</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae45a8a3711be812a2b3b4e9434486790"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::~<a class="el" href="structfolly_1_1IndexedMemPool.html">IndexedMemPool</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys all of the contained elements. </p>

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00229">229</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

<p>References <a class="el" href="ssl_2Init_8cpp_source.html#l00059">folly::ssl::cleanup()</a>, <a class="el" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt_source.html#l00083">i</a>, and <a class="el" href="ConstexprMathBenchmark_8cpp_source.html#l00186">uint32_t</a>.</p>
<div class="fragment"><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;                    {</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    <span class="keyword">using</span> <a class="code" href="namespacefolly.html#aa6586b3b6d50072e6d811e4fe0239610">A</a> = Atom&lt;uint32_t&gt;;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> <a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> = <a class="code" href="structfolly_1_1IndexedMemPool.html#ac3462c05eb457f0accc512d55ad14017">maxAllocatedIndex</a>(); <a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> &gt; 0; --<a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>) {</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;      <a class="code" href="namespacefolly_1_1ssl.html#a54c92d3815b48b978a6cf692a25ece02">Traits::cleanup</a>(&amp;<a class="code" href="structfolly_1_1IndexedMemPool.html#a87ce967c5980255616eb717751234215">slots_</a>[<a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>].elem);</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    }</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> <a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> = 1; <a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> &lt; <a class="code" href="structfolly_1_1IndexedMemPool.html#a8c0e8b2087c4fbf6ffc4edc84d0c9ad8">actualCapacity_</a> + 1; <a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>++) {</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;      <a class="code" href="structfolly_1_1IndexedMemPool.html#a87ce967c5980255616eb717751234215">slots_</a>[<a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>].<a class="code" href="structfolly_1_1IndexedMemPool_1_1Slot.html#aaf1baf437986cfeff7fa9cf5f66210b5">localNext</a>.~A();</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;      <a class="code" href="structfolly_1_1IndexedMemPool.html#a87ce967c5980255616eb717751234215">slots_</a>[<a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>].<a class="code" href="structfolly_1_1IndexedMemPool_1_1Slot.html#a5579128d24f15779795c377dcc58fe7e">globalNext</a>.~A();</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    }</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    munmap(<a class="code" href="structfolly_1_1IndexedMemPool.html#a87ce967c5980255616eb717751234215">slots_</a>, <a class="code" href="structfolly_1_1IndexedMemPool.html#abcd1a5d8cc16433d2da9f6179cdee914">mmapLength_</a>);</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;  }</div><div class="ttc" id="structfolly_1_1IndexedMemPool_html_a8c0e8b2087c4fbf6ffc4edc84d0c9ad8"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a8c0e8b2087c4fbf6ffc4edc84d0c9ad8">folly::IndexedMemPool::actualCapacity_</a></div><div class="ttdeci">uint32_t actualCapacity_</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00393">IndexedMemPool.h:393</a></div></div>
<div class="ttc" id="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt_html_a7e98b8a17c0aad30ba64d47b74e2a6c1"><div class="ttname"><a href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a></div><div class="ttdeci">i</div><div class="ttdef"><b>Definition:</b> <a href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt_source.html#l00083">gtest_output_test_golden_lin.txt:83</a></div></div>
<div class="ttc" id="namespacefolly_html_aa6586b3b6d50072e6d811e4fe0239610"><div class="ttname"><a href="namespacefolly.html#aa6586b3b6d50072e6d811e4fe0239610">folly::A</a></div><div class="ttdeci">std::unique_ptr&lt; int &gt; A</div><div class="ttdef"><b>Definition:</b> <a href="ThenCompileTest_8h_source.html#l00026">ThenCompileTest.h:26</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_1_1Slot_html_a5579128d24f15779795c377dcc58fe7e"><div class="ttname"><a href="structfolly_1_1IndexedMemPool_1_1Slot.html#a5579128d24f15779795c377dcc58fe7e">folly::IndexedMemPool::Slot::globalNext</a></div><div class="ttdeci">Atom&lt; uint32_t &gt; globalNext</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00330">IndexedMemPool.h:330</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_ac3462c05eb457f0accc512d55ad14017"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#ac3462c05eb457f0accc512d55ad14017">folly::IndexedMemPool::maxAllocatedIndex</a></div><div class="ttdeci">uint32_t maxAllocatedIndex() const </div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00251">IndexedMemPool.h:251</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_1_1Slot_html_aaf1baf437986cfeff7fa9cf5f66210b5"><div class="ttname"><a href="structfolly_1_1IndexedMemPool_1_1Slot.html#aaf1baf437986cfeff7fa9cf5f66210b5">folly::IndexedMemPool::Slot::localNext</a></div><div class="ttdeci">Atom&lt; uint32_t &gt; localNext</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00329">IndexedMemPool.h:329</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_abcd1a5d8cc16433d2da9f6179cdee914"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#abcd1a5d8cc16433d2da9f6179cdee914">folly::IndexedMemPool::mmapLength_</a></div><div class="ttdeci">size_t mmapLength_</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00387">IndexedMemPool.h:387</a></div></div>
<div class="ttc" id="ConstexprMathBenchmark_8cpp_html_a09a1e304d66d35dd47daffee9731edaa"><div class="ttname"><a href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a></div><div class="ttdeci">uint32_t</div><div class="ttdef"><b>Definition:</b> <a href="ConstexprMathBenchmark_8cpp_source.html#l00186">ConstexprMathBenchmark.cpp:186</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a87ce967c5980255616eb717751234215"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a87ce967c5980255616eb717751234215">folly::IndexedMemPool::slots_</a></div><div class="ttdeci">Slot * slots_</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00403">IndexedMemPool.h:403</a></div></div>
<div class="ttc" id="namespacefolly_1_1ssl_html_a54c92d3815b48b978a6cf692a25ece02"><div class="ttname"><a href="namespacefolly_1_1ssl.html#a54c92d3815b48b978a6cf692a25ece02">folly::ssl::cleanup</a></div><div class="ttdeci">void cleanup()</div><div class="ttdef"><b>Definition:</b> <a href="ssl_2Init_8cpp_source.html#l00059">Init.cpp:59</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a470733cf19aeae3fc83b826bfbaa2086"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfolly_1_1IndexedMemPool.html#abeeae756d8e52f9583cc3a84f62e4644">UniquePtr</a> <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::allocElem </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If an element is available, returns a std::unique_ptr to it that will recycle the element to the pool when it is reclaimed, otherwise returns a null (falsy) std::unique_ptr. Passes a pointer to the element to Traits::onAllocate before the slot is marked as allocated. </p>

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00279">279</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

<p>References <a class="el" href="StaticSingletonManager_8cpp_source.html#l00038">ptr</a>, and <a class="el" href="http__parser_8c_source.html#l00233">T</a>.</p>

<p>Referenced by <a class="el" href="IndexedMemPoolTest_8cpp_source.html#l00376">TEST()</a>, and <a class="el" href="IndexedMemPoolTest_8cpp_source.html#l00349">testTraits()</a>.</p>
<div class="fragment"><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;                                      {</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;    <span class="keyword">auto</span> idx = <a class="code" href="structfolly_1_1IndexedMemPool.html#a26ad5aa9bc8b6b5eddbbfd93fecf71a5">allocIndex</a>(std::forward&lt;Args&gt;(args)...);</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    <a class="code" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>* <a class="code" href="StaticSingletonManager_8cpp.html#a53a30bc00154d79fa155f60e2dfabf5f">ptr</a> = idx == 0 ? <span class="keyword">nullptr</span> : &amp;<a class="code" href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">slot</a>(idx).<a class="code" href="structfolly_1_1IndexedMemPool_1_1Slot.html#aa3b598e8676295ba6667fb6880531dff">elem</a>;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="structfolly_1_1IndexedMemPool.html#abeeae756d8e52f9583cc3a84f62e4644">UniquePtr</a>(ptr, <span class="keyword">typename</span> UniquePtr::deleter_type(<span class="keyword">this</span>));</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;  }</div><div class="ttc" id="StaticSingletonManager_8cpp_html_a53a30bc00154d79fa155f60e2dfabf5f"><div class="ttname"><a href="StaticSingletonManager_8cpp.html#a53a30bc00154d79fa155f60e2dfabf5f">ptr</a></div><div class="ttdeci">void * ptr</div><div class="ttdef"><b>Definition:</b> <a href="StaticSingletonManager_8cpp_source.html#l00038">StaticSingletonManager.cpp:38</a></div></div>
<div class="ttc" id="namespacefolly_html_a0652a9c51b69e7a13d40ccbcb139bc55"><div class="ttname"><a href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">folly::T</a></div><div class="ttdeci">folly::std T</div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a54bed1acb2c122bd20384b31b201bf2b"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">folly::IndexedMemPool::slot</a></div><div class="ttdeci">Slot &amp; slot(uint32_t idx)</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00424">IndexedMemPool.h:424</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_1_1Slot_html_aa3b598e8676295ba6667fb6880531dff"><div class="ttname"><a href="structfolly_1_1IndexedMemPool_1_1Slot.html#aa3b598e8676295ba6667fb6880531dff">folly::IndexedMemPool::Slot::elem</a></div><div class="ttdeci">T elem</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00328">IndexedMemPool.h:328</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a26ad5aa9bc8b6b5eddbbfd93fecf71a5"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a26ad5aa9bc8b6b5eddbbfd93fecf71a5">folly::IndexedMemPool::allocIndex</a></div><div class="ttdeci">uint32_t allocIndex(Args &amp;&amp;...args)</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00264">IndexedMemPool.h:264</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_abeeae756d8e52f9583cc3a84f62e4644"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#abeeae756d8e52f9583cc3a84f62e4644">folly::IndexedMemPool::UniquePtr</a></div><div class="ttdeci">std::unique_ptr&lt; T, detail::IndexedMemPoolRecycler&lt; IndexedMemPool &gt; &gt; UniquePtr</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00163">IndexedMemPool.h:163</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a26ad5aa9bc8b6b5eddbbfd93fecf71a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::allocIndex </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds a slot with a non-zero index, emplaces a T there if we're using the eager recycle lifecycle mode, and returns the index, or returns 0 if no elements are available. Passes a pointer to the element to Traits::onAllocate before the slot is marked as allocated. </p>

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00264">264</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

<p>References <a class="el" href="fizz_2build___2gtest_2src_2gtest_2googlemock_2include_2gmock_2gmock-generated-matchers_8h_source.html#l00481">testing::Args()</a>, <a class="el" href="IndexedMemPool_8h_source.html#l00328">folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt;::Slot::elem</a>, and <a class="el" href="StringKeyedBenchmark_8cpp_source.html#l00048">s</a>.</p>

<p>Referenced by <a class="el" href="LifoSem_8h_source.html#l00551">folly::detail::LifoSemBase&lt; BatonType, Atom &gt;::allocateNode()</a>, <a class="el" href="FlatCombining_8h_source.html#l00379">folly::FlatCombining&lt; FcSimpleExample&lt; Mutex, Atom &gt;, Mutex, Atom &gt;::allocRec()</a>, and <a class="el" href="IndexedMemPoolTest_8cpp_source.html#l00148">TEST()</a>.</p>
<div class="fragment"><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;                                      {</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;    <span class="keyword">auto</span> idx = <a class="code" href="structfolly_1_1IndexedMemPool.html#a1df3894e3276c9d0eeba6a6af5d89240">localPop</a>(<a class="code" href="structfolly_1_1IndexedMemPool.html#a77c13722bca3b74a0fc4c8dfc5264110">localHead</a>());</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    <span class="keywordflow">if</span> (idx != 0) {</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;      Slot&amp; <a class="code" href="StringKeyedBenchmark_8cpp.html#aa7f1a46e86fabf3df0ec876cd34220c2">s</a> = <a class="code" href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">slot</a>(idx);</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;      Traits::onAllocate(&amp;s.elem, std::forward&lt;Args&gt;(args)...);</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;      <a class="code" href="structfolly_1_1IndexedMemPool.html#a69be5560e3908957a2855388350bbbe9">markAllocated</a>(s);</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    }</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    <span class="keywordflow">return</span> idx;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;  }</div><div class="ttc" id="structfolly_1_1IndexedMemPool_html_a77c13722bca3b74a0fc4c8dfc5264110"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a77c13722bca3b74a0fc4c8dfc5264110">folly::IndexedMemPool::localHead</a></div><div class="ttdeci">AtomicStruct&lt; TaggedPtr, Atom &gt; &amp; localHead()</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00525">IndexedMemPool.h:525</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a69be5560e3908957a2855388350bbbe9"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a69be5560e3908957a2855388350bbbe9">folly::IndexedMemPool::markAllocated</a></div><div class="ttdeci">void markAllocated(Slot &amp;slot)</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00530">IndexedMemPool.h:530</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a54bed1acb2c122bd20384b31b201bf2b"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">folly::IndexedMemPool::slot</a></div><div class="ttdeci">Slot &amp; slot(uint32_t idx)</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00424">IndexedMemPool.h:424</a></div></div>
<div class="ttc" id="StringKeyedBenchmark_8cpp_html_aa7f1a46e86fabf3df0ec876cd34220c2"><div class="ttname"><a href="StringKeyedBenchmark_8cpp.html#aa7f1a46e86fabf3df0ec876cd34220c2">s</a></div><div class="ttdeci">static set&lt; string &gt; s</div><div class="ttdef"><b>Definition:</b> <a href="StringKeyedBenchmark_8cpp_source.html#l00048">StringKeyedBenchmark.cpp:48</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a1df3894e3276c9d0eeba6a6af5d89240"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a1df3894e3276c9d0eeba6a6af5d89240">folly::IndexedMemPool::localPop</a></div><div class="ttdeci">uint32_t localPop(AtomicStruct&lt; TaggedPtr, Atom &gt; &amp;head)</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00487">IndexedMemPool.h:487</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0d751f8f1540725aa89df02f3b1a2870"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a lower bound on the number of elements that may be simultaneously allocated and not yet recycled. Because of the local lists it is possible that more elements than this are returned successfully </p>

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00245">245</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;                      {</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="structfolly_1_1IndexedMemPool.html#a7a4eb509a23dfe5cfa47c4d6390d8168">capacityForMaxIndex</a>(<a class="code" href="structfolly_1_1IndexedMemPool.html#a8c0e8b2087c4fbf6ffc4edc84d0c9ad8">actualCapacity_</a>);</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;  }</div><div class="ttc" id="structfolly_1_1IndexedMemPool_html_a8c0e8b2087c4fbf6ffc4edc84d0c9ad8"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a8c0e8b2087c4fbf6ffc4edc84d0c9ad8">folly::IndexedMemPool::actualCapacity_</a></div><div class="ttdeci">uint32_t actualCapacity_</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00393">IndexedMemPool.h:393</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a7a4eb509a23dfe5cfa47c4d6390d8168"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a7a4eb509a23dfe5cfa47c4d6390d8168">folly::IndexedMemPool::capacityForMaxIndex</a></div><div class="ttdeci">static constexpr uint32_t capacityForMaxIndex(uint32_t maxIndex)</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00186">IndexedMemPool.h:186</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7a4eb509a23dfe5cfa47c4d6390d8168"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::capacityForMaxIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&#160;</td>
          <td class="paramname"><em>maxIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00186">186</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;                                                                   {</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    <span class="keywordflow">return</span> maxIndex - (<a class="code" href="structfolly_1_1IndexedMemPool.html#ac0e99c90c5be51024f0d212695d8b860aec01e4ff6a7b8dcb5201fdf00805226d">NumLocalLists</a> - 1) * <a class="code" href="structfolly_1_1IndexedMemPool.html#ac0e99c90c5be51024f0d212695d8b860a2caa5effafbb6651c4f648091c78b31b">LocalListLimit</a>;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;  }</div><div class="ttc" id="structfolly_1_1IndexedMemPool_html_ac0e99c90c5be51024f0d212695d8b860a2caa5effafbb6651c4f648091c78b31b"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#ac0e99c90c5be51024f0d212695d8b860a2caa5effafbb6651c4f648091c78b31b">folly::IndexedMemPool::LocalListLimit</a></div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00168">IndexedMemPool.h:168</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_ac0e99c90c5be51024f0d212695d8b860aec01e4ff6a7b8dcb5201fdf00805226d"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#ac0e99c90c5be51024f0d212695d8b860aec01e4ff6a7b8dcb5201fdf00805226d">folly::IndexedMemPool::NumLocalLists</a></div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00167">IndexedMemPool.h:167</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8fdb4eb5d938e018e553bb2f4c1f941d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::globalPop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00472">472</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

<p>References <a class="el" href="IndexedMemPool_8h_source.html#l00336">folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt;::TaggedPtr::idx</a>, and <a class="el" href="IndexedMemPool_8h_source.html#l00368">folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt;::TaggedPtr::withIdx()</a>.</p>
<div class="fragment"><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;                       {</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;      TaggedPtr gh = <a class="code" href="structfolly_1_1IndexedMemPool.html#ad2fe1c0e0a1b1f933451b10930a7f9e3">globalHead_</a>.load(std::memory_order_acquire);</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;      <span class="keywordflow">if</span> (gh.idx == 0 ||</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;          <a class="code" href="structfolly_1_1IndexedMemPool.html#ad2fe1c0e0a1b1f933451b10930a7f9e3">globalHead_</a>.compare_exchange_strong(</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;              gh,</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;              gh.withIdx(</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;                  <a class="code" href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">slot</a>(gh.idx).<a class="code" href="structfolly_1_1IndexedMemPool_1_1Slot.html#a5579128d24f15779795c377dcc58fe7e">globalNext</a>.load(std::memory_order_relaxed)))) {</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        <span class="comment">// global list is empty, or pop was successful</span></div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;        <span class="keywordflow">return</span> gh.idx;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;      }</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;    }</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;  }</div><div class="ttc" id="structfolly_1_1IndexedMemPool_1_1Slot_html_a5579128d24f15779795c377dcc58fe7e"><div class="ttname"><a href="structfolly_1_1IndexedMemPool_1_1Slot.html#a5579128d24f15779795c377dcc58fe7e">folly::IndexedMemPool::Slot::globalNext</a></div><div class="ttdeci">Atom&lt; uint32_t &gt; globalNext</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00330">IndexedMemPool.h:330</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_ad2fe1c0e0a1b1f933451b10930a7f9e3"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#ad2fe1c0e0a1b1f933451b10930a7f9e3">folly::IndexedMemPool::globalHead_</a></div><div class="ttdeci">AtomicStruct&lt; TaggedPtr, Atom &gt; globalHead_</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00413">IndexedMemPool.h:413</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a54bed1acb2c122bd20384b31b201bf2b"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">folly::IndexedMemPool::slot</a></div><div class="ttdeci">Slot &amp; slot(uint32_t idx)</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00424">IndexedMemPool.h:424</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abcee8e1f9fb4bcec8deae1b686dc7307"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::globalPush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfolly_1_1IndexedMemPool_1_1Slot.html">Slot</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&#160;</td>
          <td class="paramname"><em>localHead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00434">434</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

<p>References <a class="el" href="IndexedMemPool_8h_source.html#l00330">folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt;::Slot::globalNext</a>, <a class="el" href="IndexedMemPool_8h_source.html#l00336">folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt;::TaggedPtr::idx</a>, and <a class="el" href="IndexedMemPool_8h_source.html#l00368">folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt;::TaggedPtr::withIdx()</a>.</p>
<div class="fragment"><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;                                               {</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;      TaggedPtr gh = <a class="code" href="structfolly_1_1IndexedMemPool.html#ad2fe1c0e0a1b1f933451b10930a7f9e3">globalHead_</a>.load(std::memory_order_acquire);</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;      <a class="code" href="StringKeyedBenchmark_8cpp.html#aa7f1a46e86fabf3df0ec876cd34220c2">s</a>.globalNext.store(gh.idx, std::memory_order_relaxed);</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="structfolly_1_1IndexedMemPool.html#ad2fe1c0e0a1b1f933451b10930a7f9e3">globalHead_</a>.compare_exchange_strong(gh, gh.withIdx(<a class="code" href="structfolly_1_1IndexedMemPool.html#a77c13722bca3b74a0fc4c8dfc5264110">localHead</a>))) {</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;        <span class="comment">// success</span></div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;        <span class="keywordflow">return</span>;</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;      }</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;    }</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;  }</div><div class="ttc" id="structfolly_1_1IndexedMemPool_html_a77c13722bca3b74a0fc4c8dfc5264110"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a77c13722bca3b74a0fc4c8dfc5264110">folly::IndexedMemPool::localHead</a></div><div class="ttdeci">AtomicStruct&lt; TaggedPtr, Atom &gt; &amp; localHead()</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00525">IndexedMemPool.h:525</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_ad2fe1c0e0a1b1f933451b10930a7f9e3"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#ad2fe1c0e0a1b1f933451b10930a7f9e3">folly::IndexedMemPool::globalHead_</a></div><div class="ttdeci">AtomicStruct&lt; TaggedPtr, Atom &gt; globalHead_</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00413">IndexedMemPool.h:413</a></div></div>
<div class="ttc" id="StringKeyedBenchmark_8cpp_html_aa7f1a46e86fabf3df0ec876cd34220c2"><div class="ttname"><a href="StringKeyedBenchmark_8cpp.html#aa7f1a46e86fabf3df0ec876cd34220c2">s</a></div><div class="ttdeci">static set&lt; string &gt; s</div><div class="ttdef"><b>Definition:</b> <a href="StringKeyedBenchmark_8cpp_source.html#l00048">StringKeyedBenchmark.cpp:48</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a61b91e16f6e73a440a776fab01041157"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::isAllocated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true iff idx has been alloc()ed and not <a class="el" href="structfolly_1_1IndexedMemPool.html#a8bf4646be9fd0a8eabb4356fb31d04a7" title="Gives up ownership previously granted by alloc() ">recycleIndex()</a>ed. </p>

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00320">320</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

<p>References <a class="el" href="ConstexprMathBenchmark_8cpp_source.html#l00186">uint32_t</a>.</p>

<p>Referenced by <a class="el" href="IndexedMemPoolTest_8cpp_source.html#l00349">testTraits()</a>.</p>
<div class="fragment"><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;                                       {</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">slot</a>(idx).<a class="code" href="structfolly_1_1IndexedMemPool_1_1Slot.html#aaf1baf437986cfeff7fa9cf5f66210b5">localNext</a>.load(std::memory_order_acquire) == <a class="code" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>(-1);</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;  }</div><div class="ttc" id="structfolly_1_1IndexedMemPool_1_1Slot_html_aaf1baf437986cfeff7fa9cf5f66210b5"><div class="ttname"><a href="structfolly_1_1IndexedMemPool_1_1Slot.html#aaf1baf437986cfeff7fa9cf5f66210b5">folly::IndexedMemPool::Slot::localNext</a></div><div class="ttdeci">Atom&lt; uint32_t &gt; localNext</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00329">IndexedMemPool.h:329</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a54bed1acb2c122bd20384b31b201bf2b"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">folly::IndexedMemPool::slot</a></div><div class="ttdeci">Slot &amp; slot(uint32_t idx)</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00424">IndexedMemPool.h:424</a></div></div>
<div class="ttc" id="ConstexprMathBenchmark_8cpp_html_a09a1e304d66d35dd47daffee9731edaa"><div class="ttname"><a href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a></div><div class="ttdeci">uint32_t</div><div class="ttdef"><b>Definition:</b> <a href="ConstexprMathBenchmark_8cpp_source.html#l00186">ConstexprMathBenchmark.cpp:186</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a77c13722bca3b74a0fc4c8dfc5264110"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfolly_1_1AtomicStruct.html">AtomicStruct</a>&lt;<a class="el" href="structfolly_1_1IndexedMemPool_1_1TaggedPtr.html">TaggedPtr</a>, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>&gt;&amp; <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::localHead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00525">525</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

<p>References <a class="el" href="SynchronizedTest_8cpp_source.html#l00743">current</a>, and <a class="el" href="IndexedMemPool_8h_source.html#l00378">folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt;::LocalList::head</a>.</p>
<div class="fragment"><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;                                             {</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;    <span class="keyword">auto</span> stripe = <a class="code" href="structfolly_1_1AccessSpreader.html#ac608371fb7dd0dfb999e55e50cd52deb">AccessSpreader&lt;Atom&gt;::current</a>(<a class="code" href="structfolly_1_1IndexedMemPool.html#ac0e99c90c5be51024f0d212695d8b860aec01e4ff6a7b8dcb5201fdf00805226d">NumLocalLists</a>);</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="structfolly_1_1IndexedMemPool.html#a273ddc208d0f0426b92263c0ca2ea94d">local_</a>[stripe].<a class="code" href="structfolly_1_1IndexedMemPool_1_1LocalList.html#a34c1b5ad7fd69bfab919fdfc2bc6f2bf">head</a>;</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;  }</div><div class="ttc" id="structfolly_1_1IndexedMemPool_html_a273ddc208d0f0426b92263c0ca2ea94d"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a273ddc208d0f0426b92263c0ca2ea94d">folly::IndexedMemPool::local_</a></div><div class="ttdeci">LocalList local_[NumLocalLists]</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00408">IndexedMemPool.h:408</a></div></div>
<div class="ttc" id="structfolly_1_1AccessSpreader_html_ac608371fb7dd0dfb999e55e50cd52deb"><div class="ttname"><a href="structfolly_1_1AccessSpreader.html#ac608371fb7dd0dfb999e55e50cd52deb">folly::AccessSpreader::current</a></div><div class="ttdeci">static size_t current(size_t numStripes)</div><div class="ttdef"><b>Definition:</b> <a href="CacheLocality_8h_source.html#l00231">CacheLocality.h:231</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_1_1LocalList_html_a34c1b5ad7fd69bfab919fdfc2bc6f2bf"><div class="ttname"><a href="structfolly_1_1IndexedMemPool_1_1LocalList.html#a34c1b5ad7fd69bfab919fdfc2bc6f2bf">folly::IndexedMemPool::LocalList::head</a></div><div class="ttdeci">AtomicStruct&lt; TaggedPtr, Atom &gt; head</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00378">IndexedMemPool.h:378</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_ac0e99c90c5be51024f0d212695d8b860aec01e4ff6a7b8dcb5201fdf00805226d"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#ac0e99c90c5be51024f0d212695d8b860aec01e4ff6a7b8dcb5201fdf00805226d">folly::IndexedMemPool::NumLocalLists</a></div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00167">IndexedMemPool.h:167</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1df3894e3276c9d0eeba6a6af5d89240"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::localPop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfolly_1_1AtomicStruct.html">AtomicStruct</a>&lt; <a class="el" href="structfolly_1_1IndexedMemPool_1_1TaggedPtr.html">TaggedPtr</a>, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00487">487</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

<p>References <a class="el" href="AtomicStruct_8h_source.html#l00093">folly::AtomicStruct&lt; T, Atom &gt;::compare_exchange_strong()</a>, <a class="el" href="Hazptr_8h_source.html#l00116">h</a>, <a class="el" href="IndexedMemPool_8h_source.html#l00336">folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt;::TaggedPtr::idx</a>, <a class="el" href="AtomicStruct_8h_source.html#l00141">folly::AtomicStruct&lt; T, Atom &gt;::load()</a>, <a class="el" href="IndexedMemPool_8h_source.html#l00329">folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt;::Slot::localNext</a>, <a class="el" href="fizz_2build___2gtest_2src_2gtest_2googlemock_2scripts_2generator_2cpp_2ast_8py_source.html#l00058">cpp.ast::next()</a>, <a class="el" href="StringKeyedBenchmark_8cpp_source.html#l00048">s</a>, <a class="el" href="ConstexprMathBenchmark_8cpp_source.html#l00186">uint32_t</a>, <a class="el" href="IndexedMemPool_8h_source.html#l00368">folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt;::TaggedPtr::withIdx()</a>, <a class="el" href="IndexedMemPool_8h_source.html#l00353">folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt;::TaggedPtr::withSize()</a>, and <a class="el" href="IndexedMemPool_8h_source.html#l00363">folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt;::TaggedPtr::withSizeDecr()</a>.</p>
<div class="fragment"><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;                                                         {</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;      TaggedPtr <a class="code" href="Hazptr_8h.html#ab25155a2370ac096e61dc7e39e2816df">h</a> = head.load(std::memory_order_acquire);</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;      <span class="keywordflow">if</span> (h.idx != 0) {</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;        <span class="comment">// local list is non-empty, try to pop</span></div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;        Slot&amp; <a class="code" href="StringKeyedBenchmark_8cpp.html#aa7f1a46e86fabf3df0ec876cd34220c2">s</a> = <a class="code" href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">slot</a>(h.idx);</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;        <span class="keyword">auto</span> <a class="code" href="namespacecpp_1_1ast.html#a25bc7c34a56f66f8e68856ab63c7e990">next</a> = s.localNext.load(std::memory_order_relaxed);</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;        <span class="keywordflow">if</span> (head.compare_exchange_strong(h, h.withIdx(<a class="code" href="namespacecpp_1_1ast.html#a25bc7c34a56f66f8e68856ab63c7e990">next</a>).withSizeDecr())) {</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;          <span class="comment">// success</span></div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;          <span class="keywordflow">return</span> h.idx;</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;        }</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;      }</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;      <a class="code" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> idx = <a class="code" href="structfolly_1_1IndexedMemPool.html#a8fdb4eb5d938e018e553bb2f4c1f941d">globalPop</a>();</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;      <span class="keywordflow">if</span> (idx == 0) {</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;        <span class="comment">// global list is empty, allocate and construct new slot</span></div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="structfolly_1_1IndexedMemPool.html#a5de3d071fbddfc1dae27a23e52b55b6e">size_</a>.load(std::memory_order_relaxed) &gt;= <a class="code" href="structfolly_1_1IndexedMemPool.html#a8c0e8b2087c4fbf6ffc4edc84d0c9ad8">actualCapacity_</a> ||</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;            (idx = ++<a class="code" href="structfolly_1_1IndexedMemPool.html#a5de3d071fbddfc1dae27a23e52b55b6e">size_</a>) &gt; <a class="code" href="structfolly_1_1IndexedMemPool.html#a8c0e8b2087c4fbf6ffc4edc84d0c9ad8">actualCapacity_</a>) {</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;          <span class="comment">// allocation failed</span></div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;          <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;        }</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;        Traits::initialize(&amp;<a class="code" href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">slot</a>(idx).elem);</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;        <span class="keywordflow">return</span> idx;</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;      }</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;      Slot&amp; s = <a class="code" href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">slot</a>(idx);</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;      <span class="keyword">auto</span> <a class="code" href="namespacecpp_1_1ast.html#a25bc7c34a56f66f8e68856ab63c7e990">next</a> = s.localNext.load(std::memory_order_relaxed);</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;      <span class="keywordflow">if</span> (head.compare_exchange_strong(</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;              h, h.withIdx(<a class="code" href="namespacecpp_1_1ast.html#a25bc7c34a56f66f8e68856ab63c7e990">next</a>).withSize(<a class="code" href="structfolly_1_1IndexedMemPool.html#ac0e99c90c5be51024f0d212695d8b860a2caa5effafbb6651c4f648091c78b31b">LocalListLimit</a>))) {</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;        <span class="comment">// global list moved to local list, keep head for us</span></div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;        <span class="keywordflow">return</span> idx;</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;      }</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;      <span class="comment">// local bulk push failed, return idx to the global list and try again</span></div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;      <a class="code" href="structfolly_1_1IndexedMemPool.html#abcee8e1f9fb4bcec8deae1b686dc7307">globalPush</a>(s, idx);</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;    }</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;  }</div><div class="ttc" id="structfolly_1_1IndexedMemPool_html_a8c0e8b2087c4fbf6ffc4edc84d0c9ad8"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a8c0e8b2087c4fbf6ffc4edc84d0c9ad8">folly::IndexedMemPool::actualCapacity_</a></div><div class="ttdeci">uint32_t actualCapacity_</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00393">IndexedMemPool.h:393</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a5de3d071fbddfc1dae27a23e52b55b6e"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a5de3d071fbddfc1dae27a23e52b55b6e">folly::IndexedMemPool::size_</a></div><div class="ttdeci">Atom&lt; uint32_t &gt; size_</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00399">IndexedMemPool.h:399</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_ac0e99c90c5be51024f0d212695d8b860a2caa5effafbb6651c4f648091c78b31b"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#ac0e99c90c5be51024f0d212695d8b860a2caa5effafbb6651c4f648091c78b31b">folly::IndexedMemPool::LocalListLimit</a></div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00168">IndexedMemPool.h:168</a></div></div>
<div class="ttc" id="Hazptr_8h_html_ab25155a2370ac096e61dc7e39e2816df"><div class="ttname"><a href="Hazptr_8h.html#ab25155a2370ac096e61dc7e39e2816df">h</a></div><div class="ttdeci">*than *hazptr_holder h</div><div class="ttdef"><b>Definition:</b> <a href="Hazptr_8h_source.html#l00116">Hazptr.h:116</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_abcee8e1f9fb4bcec8deae1b686dc7307"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#abcee8e1f9fb4bcec8deae1b686dc7307">folly::IndexedMemPool::globalPush</a></div><div class="ttdeci">void globalPush(Slot &amp;s, uint32_t localHead)</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00434">IndexedMemPool.h:434</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a54bed1acb2c122bd20384b31b201bf2b"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">folly::IndexedMemPool::slot</a></div><div class="ttdeci">Slot &amp; slot(uint32_t idx)</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00424">IndexedMemPool.h:424</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a8fdb4eb5d938e018e553bb2f4c1f941d"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a8fdb4eb5d938e018e553bb2f4c1f941d">folly::IndexedMemPool::globalPop</a></div><div class="ttdeci">uint32_t globalPop()</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00472">IndexedMemPool.h:472</a></div></div>
<div class="ttc" id="StringKeyedBenchmark_8cpp_html_aa7f1a46e86fabf3df0ec876cd34220c2"><div class="ttname"><a href="StringKeyedBenchmark_8cpp.html#aa7f1a46e86fabf3df0ec876cd34220c2">s</a></div><div class="ttdeci">static set&lt; string &gt; s</div><div class="ttdef"><b>Definition:</b> <a href="StringKeyedBenchmark_8cpp_source.html#l00048">StringKeyedBenchmark.cpp:48</a></div></div>
<div class="ttc" id="ConstexprMathBenchmark_8cpp_html_a09a1e304d66d35dd47daffee9731edaa"><div class="ttname"><a href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a></div><div class="ttdeci">uint32_t</div><div class="ttdef"><b>Definition:</b> <a href="ConstexprMathBenchmark_8cpp_source.html#l00186">ConstexprMathBenchmark.cpp:186</a></div></div>
<div class="ttc" id="namespacecpp_1_1ast_html_a25bc7c34a56f66f8e68856ab63c7e990"><div class="ttname"><a href="namespacecpp_1_1ast.html#a25bc7c34a56f66f8e68856ab63c7e990">cpp.ast.next</a></div><div class="ttdeci">def next(obj)</div><div class="ttdef"><b>Definition:</b> <a href="fizz_2build___2gtest_2src_2gtest_2googlemock_2scripts_2generator_2cpp_2ast_8py_source.html#l00058">ast.py:58</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac891d55dbb470b95ea9f16980ddba99c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::localPush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfolly_1_1AtomicStruct.html">AtomicStruct</a>&lt; <a class="el" href="structfolly_1_1IndexedMemPool_1_1TaggedPtr.html">TaggedPtr</a>, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00446">446</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

<p>References <a class="el" href="AtomicStruct_8h_source.html#l00093">folly::AtomicStruct&lt; T, Atom &gt;::compare_exchange_strong()</a>, <a class="el" href="Hazptr_8h_source.html#l00116">h</a>, <a class="el" href="IndexedMemPool_8h_source.html#l00336">folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt;::TaggedPtr::idx</a>, <a class="el" href="AtomicStruct_8h_source.html#l00141">folly::AtomicStruct&lt; T, Atom &gt;::load()</a>, <a class="el" href="IndexedMemPool_8h_source.html#l00329">folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt;::Slot::localNext</a>, <a class="el" href="StringKeyedBenchmark_8cpp_source.html#l00048">s</a>, <a class="el" href="IndexedMemPool_8h_source.html#l00349">folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt;::TaggedPtr::size()</a>, <a class="el" href="IndexedMemPool_8h_source.html#l00372">folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt;::TaggedPtr::withEmpty()</a>, <a class="el" href="IndexedMemPool_8h_source.html#l00368">folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt;::TaggedPtr::withIdx()</a>, and <a class="el" href="IndexedMemPool_8h_source.html#l00358">folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt;::TaggedPtr::withSizeIncr()</a>.</p>
<div class="fragment"><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;                                                                    {</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;    Slot&amp; <a class="code" href="StringKeyedBenchmark_8cpp.html#aa7f1a46e86fabf3df0ec876cd34220c2">s</a> = <a class="code" href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">slot</a>(idx);</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;    TaggedPtr <a class="code" href="Hazptr_8h.html#ab25155a2370ac096e61dc7e39e2816df">h</a> = head.load(std::memory_order_acquire);</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;      s.localNext.store(h.idx, std::memory_order_release);</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;      Traits::onRecycle(&amp;<a class="code" href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">slot</a>(idx).elem);</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;      <span class="keywordflow">if</span> (h.size() == <a class="code" href="structfolly_1_1IndexedMemPool.html#ac0e99c90c5be51024f0d212695d8b860a2caa5effafbb6651c4f648091c78b31b">LocalListLimit</a>) {</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;        <span class="comment">// push will overflow local list, steal it instead</span></div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;        <span class="keywordflow">if</span> (head.compare_exchange_strong(h, h.withEmpty())) {</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;          <span class="comment">// steal was successful, put everything in the global list</span></div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;          <a class="code" href="structfolly_1_1IndexedMemPool.html#abcee8e1f9fb4bcec8deae1b686dc7307">globalPush</a>(s, idx);</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;          <span class="keywordflow">return</span>;</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;        }</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;      } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;        <span class="comment">// local list has space</span></div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;        <span class="keywordflow">if</span> (head.compare_exchange_strong(h, h.withIdx(idx).withSizeIncr())) {</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;          <span class="comment">// success</span></div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;          <span class="keywordflow">return</span>;</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        }</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;      }</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;      <span class="comment">// h was updated by failing CAS</span></div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;    }</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;  }</div><div class="ttc" id="structfolly_1_1IndexedMemPool_html_ac0e99c90c5be51024f0d212695d8b860a2caa5effafbb6651c4f648091c78b31b"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#ac0e99c90c5be51024f0d212695d8b860a2caa5effafbb6651c4f648091c78b31b">folly::IndexedMemPool::LocalListLimit</a></div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00168">IndexedMemPool.h:168</a></div></div>
<div class="ttc" id="Hazptr_8h_html_ab25155a2370ac096e61dc7e39e2816df"><div class="ttname"><a href="Hazptr_8h.html#ab25155a2370ac096e61dc7e39e2816df">h</a></div><div class="ttdeci">*than *hazptr_holder h</div><div class="ttdef"><b>Definition:</b> <a href="Hazptr_8h_source.html#l00116">Hazptr.h:116</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_abcee8e1f9fb4bcec8deae1b686dc7307"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#abcee8e1f9fb4bcec8deae1b686dc7307">folly::IndexedMemPool::globalPush</a></div><div class="ttdeci">void globalPush(Slot &amp;s, uint32_t localHead)</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00434">IndexedMemPool.h:434</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a54bed1acb2c122bd20384b31b201bf2b"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">folly::IndexedMemPool::slot</a></div><div class="ttdeci">Slot &amp; slot(uint32_t idx)</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00424">IndexedMemPool.h:424</a></div></div>
<div class="ttc" id="StringKeyedBenchmark_8cpp_html_aa7f1a46e86fabf3df0ec876cd34220c2"><div class="ttname"><a href="StringKeyedBenchmark_8cpp.html#aa7f1a46e86fabf3df0ec876cd34220c2">s</a></div><div class="ttdeci">static set&lt; string &gt; s</div><div class="ttdef"><b>Definition:</b> <a href="StringKeyedBenchmark_8cpp_source.html#l00048">StringKeyedBenchmark.cpp:48</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af24f1367d1ed263e3f810cb5322a0a30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::locateElem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a> *&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If elem == &amp;pool[idx], then pool.locateElem(elem) == idx. Also, pool.locateElem(nullptr) == 0 </p>

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00303">303</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

<p>References <a class="el" href="ConstexprMathBenchmark_8cpp_source.html#l00186">uint32_t</a>, and <a class="el" href="Conv_8cpp_source.html#l00050">value</a>.</p>

<p>Referenced by <a class="el" href="LifoSem_8h_source.html#l00587">folly::detail::LifoSemBase&lt; BatonType, Atom &gt;::nodeToIdx()</a>, <a class="el" href="LifoSem_8h_source.html#l00197">folly::detail::LifoSemNodeRecycler&lt; Handoff, Atom &gt;::operator()()</a>, <a class="el" href="IndexedMemPoolTest_8cpp_source.html#l00148">TEST()</a>, and <a class="el" href="IndexedMemPoolTest_8cpp_source.html#l00349">testTraits()</a>.</p>
<div class="fragment"><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;                                           {</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    <span class="keywordflow">if</span> (!elem) {</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;      <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;    }</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    static_assert(<a class="code" href="Conv_8cpp.html#a2f6ac1714c34743067351b0d2a64162b">std::is_standard_layout&lt;Slot&gt;::value</a>, <span class="stringliteral">&quot;offsetof needs POD&quot;</span>);</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    <span class="keyword">auto</span> <a class="code" href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">slot</a> = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>Slot*<span class="keyword">&gt;</span>(</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;        <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(elem) - offsetof(Slot, elem));</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    <span class="keyword">auto</span> rv = <a class="code" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>(<a class="code" href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">slot</a> - <a class="code" href="structfolly_1_1IndexedMemPool.html#a87ce967c5980255616eb717751234215">slots_</a>);</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;    <span class="comment">// this assert also tests that rv is in range</span></div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    assert(elem == &amp;(*<span class="keyword">this</span>)[rv]);</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    <span class="keywordflow">return</span> rv;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;  }</div><div class="ttc" id="structfolly_1_1IndexedMemPool_html_a54bed1acb2c122bd20384b31b201bf2b"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">folly::IndexedMemPool::slot</a></div><div class="ttdeci">Slot &amp; slot(uint32_t idx)</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00424">IndexedMemPool.h:424</a></div></div>
<div class="ttc" id="Conv_8cpp_html_a2f6ac1714c34743067351b0d2a64162b"><div class="ttname"><a href="Conv_8cpp.html#a2f6ac1714c34743067351b0d2a64162b">value</a></div><div class="ttdeci">static const char *const value</div><div class="ttdef"><b>Definition:</b> <a href="Conv_8cpp_source.html#l00050">Conv.cpp:50</a></div></div>
<div class="ttc" id="ConstexprMathBenchmark_8cpp_html_a09a1e304d66d35dd47daffee9731edaa"><div class="ttname"><a href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a></div><div class="ttdeci">uint32_t</div><div class="ttdef"><b>Definition:</b> <a href="ConstexprMathBenchmark_8cpp_source.html#l00186">ConstexprMathBenchmark.cpp:186</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a87ce967c5980255616eb717751234215"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a87ce967c5980255616eb717751234215">folly::IndexedMemPool::slots_</a></div><div class="ttdeci">Slot * slots_</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00403">IndexedMemPool.h:403</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a69be5560e3908957a2855388350bbbe9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::markAllocated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfolly_1_1IndexedMemPool_1_1Slot.html">Slot</a> &amp;&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00530">530</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

<p>References <a class="el" href="IndexedMemPool_8h_source.html#l00329">folly::IndexedMemPool&lt; T, NumLocalLists_, LocalListLimit_, Atom, Traits &gt;::Slot::localNext</a>, and <a class="el" href="ConstexprMathBenchmark_8cpp_source.html#l00186">uint32_t</a>.</p>
<div class="fragment"><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;                                 {</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;    <a class="code" href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">slot</a>.<a class="code" href="structfolly_1_1IndexedMemPool_1_1Slot.html#aaf1baf437986cfeff7fa9cf5f66210b5">localNext</a>.store(<a class="code" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>(-1), std::memory_order_release);</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;  }</div><div class="ttc" id="structfolly_1_1IndexedMemPool_1_1Slot_html_aaf1baf437986cfeff7fa9cf5f66210b5"><div class="ttname"><a href="structfolly_1_1IndexedMemPool_1_1Slot.html#aaf1baf437986cfeff7fa9cf5f66210b5">folly::IndexedMemPool::Slot::localNext</a></div><div class="ttdeci">Atom&lt; uint32_t &gt; localNext</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00329">IndexedMemPool.h:329</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a54bed1acb2c122bd20384b31b201bf2b"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">folly::IndexedMemPool::slot</a></div><div class="ttdeci">Slot &amp; slot(uint32_t idx)</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00424">IndexedMemPool.h:424</a></div></div>
<div class="ttc" id="ConstexprMathBenchmark_8cpp_html_a09a1e304d66d35dd47daffee9731edaa"><div class="ttname"><a href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a></div><div class="ttdeci">uint32_t</div><div class="ttdef"><b>Definition:</b> <a href="ConstexprMathBenchmark_8cpp_source.html#l00186">ConstexprMathBenchmark.cpp:186</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac3462c05eb457f0accc512d55ad14017"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::maxAllocatedIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum index of elements ever allocated in this pool including elements that have been recycled. </p>

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00251">251</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

<p>References <a class="el" href="fizz_2build___2gtest_2src_2gtest_2googlemock_2include_2gmock_2gmock-generated-matchers_8h_source.html#l00481">testing::Args()</a>, <a class="el" href="LogLevel_8cpp_source.html#l00030">min</a>, and <a class="el" href="ConstexprMathBenchmark_8cpp_source.html#l00186">uint32_t</a>.</p>
<div class="fragment"><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;                                     {</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;    <span class="comment">// Take the minimum since it is possible that size_ &gt; actualCapacity_.</span></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    <span class="comment">// This can happen if there are multiple concurrent requests</span></div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    <span class="comment">// when size_ == actualCapacity_ - 1.</span></div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="LogLevel_8cpp.html#a7361901234703a521a82885405734c53">std::min</a>(<a class="code" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>(<a class="code" href="structfolly_1_1IndexedMemPool.html#a5de3d071fbddfc1dae27a23e52b55b6e">size_</a>), <a class="code" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>(<a class="code" href="structfolly_1_1IndexedMemPool.html#a8c0e8b2087c4fbf6ffc4edc84d0c9ad8">actualCapacity_</a>));</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;  }</div><div class="ttc" id="structfolly_1_1IndexedMemPool_html_a8c0e8b2087c4fbf6ffc4edc84d0c9ad8"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a8c0e8b2087c4fbf6ffc4edc84d0c9ad8">folly::IndexedMemPool::actualCapacity_</a></div><div class="ttdeci">uint32_t actualCapacity_</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00393">IndexedMemPool.h:393</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a5de3d071fbddfc1dae27a23e52b55b6e"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a5de3d071fbddfc1dae27a23e52b55b6e">folly::IndexedMemPool::size_</a></div><div class="ttdeci">Atom&lt; uint32_t &gt; size_</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00399">IndexedMemPool.h:399</a></div></div>
<div class="ttc" id="LogLevel_8cpp_html_a7361901234703a521a82885405734c53"><div class="ttname"><a href="LogLevel_8cpp.html#a7361901234703a521a82885405734c53">min</a></div><div class="ttdeci">LogLevel min</div><div class="ttdef"><b>Definition:</b> <a href="LogLevel_8cpp_source.html#l00030">LogLevel.cpp:30</a></div></div>
<div class="ttc" id="ConstexprMathBenchmark_8cpp_html_a09a1e304d66d35dd47daffee9731edaa"><div class="ttname"><a href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a></div><div class="ttdeci">uint32_t</div><div class="ttdef"><b>Definition:</b> <a href="ConstexprMathBenchmark_8cpp_source.html#l00186">ConstexprMathBenchmark.cpp:186</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afef094566f6ab4631e220c46e8e24e89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::maxIndexForCapacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00178">178</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

<p>References <a class="el" href="LogLevel_8cpp_source.html#l00031">max</a>, <a class="el" href="LogLevel_8cpp_source.html#l00030">min</a>, <a class="el" href="ConstexprMathBenchmark_8cpp_source.html#l00186">uint32_t</a>, and <a class="el" href="ConstexprMathBenchmark_8cpp_source.html#l00190">uint64_t</a>.</p>
<div class="fragment"><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;                                                                   {</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    <span class="comment">// index of std::numeric_limits&lt;uint32_t&gt;::max() is reserved for isAllocated</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    <span class="comment">// tracking</span></div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>(<a class="code" href="LogLevel_8cpp.html#a7361901234703a521a82885405734c53">std::min</a>(</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        <a class="code" href="ConstexprMathBenchmark_8cpp.html#a5dc34568a989dd90728a4ed499cd9fab">uint64_t</a>(<a class="code" href="structfolly_1_1IndexedMemPool.html#a0d751f8f1540725aa89df02f3b1a2870">capacity</a>) + (<a class="code" href="structfolly_1_1IndexedMemPool.html#ac0e99c90c5be51024f0d212695d8b860aec01e4ff6a7b8dcb5201fdf00805226d">NumLocalLists</a> - 1) * <a class="code" href="structfolly_1_1IndexedMemPool.html#ac0e99c90c5be51024f0d212695d8b860a2caa5effafbb6651c4f648091c78b31b">LocalListLimit</a>,</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        <a class="code" href="ConstexprMathBenchmark_8cpp.html#a5dc34568a989dd90728a4ed499cd9fab">uint64_t</a>(<a class="code" href="LogLevel_8cpp.html#a15c8b90f03cae068a6979f32590642e2">std::numeric_limits&lt;uint32_t&gt;::max</a>() - 1)));</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;  }</div><div class="ttc" id="structfolly_1_1IndexedMemPool_html_ac0e99c90c5be51024f0d212695d8b860a2caa5effafbb6651c4f648091c78b31b"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#ac0e99c90c5be51024f0d212695d8b860a2caa5effafbb6651c4f648091c78b31b">folly::IndexedMemPool::LocalListLimit</a></div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00168">IndexedMemPool.h:168</a></div></div>
<div class="ttc" id="LogLevel_8cpp_html_a15c8b90f03cae068a6979f32590642e2"><div class="ttname"><a href="LogLevel_8cpp.html#a15c8b90f03cae068a6979f32590642e2">max</a></div><div class="ttdeci">LogLevel max</div><div class="ttdef"><b>Definition:</b> <a href="LogLevel_8cpp_source.html#l00031">LogLevel.cpp:31</a></div></div>
<div class="ttc" id="LogLevel_8cpp_html_a7361901234703a521a82885405734c53"><div class="ttname"><a href="LogLevel_8cpp.html#a7361901234703a521a82885405734c53">min</a></div><div class="ttdeci">LogLevel min</div><div class="ttdef"><b>Definition:</b> <a href="LogLevel_8cpp_source.html#l00030">LogLevel.cpp:30</a></div></div>
<div class="ttc" id="ConstexprMathBenchmark_8cpp_html_a5dc34568a989dd90728a4ed499cd9fab"><div class="ttname"><a href="ConstexprMathBenchmark_8cpp.html#a5dc34568a989dd90728a4ed499cd9fab">uint64_t</a></div><div class="ttdeci">uint64_t</div><div class="ttdef"><b>Definition:</b> <a href="ConstexprMathBenchmark_8cpp_source.html#l00190">ConstexprMathBenchmark.cpp:190</a></div></div>
<div class="ttc" id="ConstexprMathBenchmark_8cpp_html_a09a1e304d66d35dd47daffee9731edaa"><div class="ttname"><a href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a></div><div class="ttdeci">uint32_t</div><div class="ttdef"><b>Definition:</b> <a href="ConstexprMathBenchmark_8cpp_source.html#l00186">ConstexprMathBenchmark.cpp:186</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a0d751f8f1540725aa89df02f3b1a2870"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a0d751f8f1540725aa89df02f3b1a2870">folly::IndexedMemPool::capacity</a></div><div class="ttdeci">uint32_t capacity()</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00245">IndexedMemPool.h:245</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_ac0e99c90c5be51024f0d212695d8b860aec01e4ff6a7b8dcb5201fdf00805226d"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#ac0e99c90c5be51024f0d212695d8b860aec01e4ff6a7b8dcb5201fdf00805226d">folly::IndexedMemPool::NumLocalLists</a></div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00167">IndexedMemPool.h:167</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae99f91ab6b82f5cbe57ae0494117a268"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>&amp; <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the pooled element referenced by idx. </p>

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00292">292</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;                              {</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">slot</a>(idx).<a class="code" href="structfolly_1_1IndexedMemPool_1_1Slot.html#aa3b598e8676295ba6667fb6880531dff">elem</a>;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;  }</div><div class="ttc" id="structfolly_1_1IndexedMemPool_html_a54bed1acb2c122bd20384b31b201bf2b"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">folly::IndexedMemPool::slot</a></div><div class="ttdeci">Slot &amp; slot(uint32_t idx)</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00424">IndexedMemPool.h:424</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_1_1Slot_html_aa3b598e8676295ba6667fb6880531dff"><div class="ttname"><a href="structfolly_1_1IndexedMemPool_1_1Slot.html#aa3b598e8676295ba6667fb6880531dff">folly::IndexedMemPool::Slot::elem</a></div><div class="ttdeci">T elem</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00328">IndexedMemPool.h:328</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac067ef099f71f4fe14e34b1ea7135ce1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>&amp; <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the pooled element referenced by idx. </p>

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00297">297</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;                                          {</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">slot</a>(idx).<a class="code" href="structfolly_1_1IndexedMemPool_1_1Slot.html#aa3b598e8676295ba6667fb6880531dff">elem</a>;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;  }</div><div class="ttc" id="structfolly_1_1IndexedMemPool_html_a54bed1acb2c122bd20384b31b201bf2b"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a54bed1acb2c122bd20384b31b201bf2b">folly::IndexedMemPool::slot</a></div><div class="ttdeci">Slot &amp; slot(uint32_t idx)</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00424">IndexedMemPool.h:424</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_1_1Slot_html_aa3b598e8676295ba6667fb6880531dff"><div class="ttname"><a href="structfolly_1_1IndexedMemPool_1_1Slot.html#aa3b598e8676295ba6667fb6880531dff">folly::IndexedMemPool::Slot::elem</a></div><div class="ttdeci">T elem</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00328">IndexedMemPool.h:328</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8bf4646be9fd0a8eabb4356fb31d04a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::recycleIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives up ownership previously granted by alloc() </p>

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00286">286</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

<p>Referenced by <a class="el" href="LifoSem_8h_source.html#l00551">folly::detail::LifoSemBase&lt; BatonType, Atom &gt;::allocateNode()</a>, <a class="el" href="FlatCombining_8h_source.html#l00390">folly::FlatCombining&lt; FcSimpleExample&lt; Mutex, Atom &gt;, Mutex, Atom &gt;::freeRec()</a>, <a class="el" href="LifoSem_8h_source.html#l00197">folly::detail::LifoSemNodeRecycler&lt; Handoff, Atom &gt;::operator()()</a>, and <a class="el" href="IndexedMemPoolTest_8cpp_source.html#l00349">testTraits()</a>.</p>
<div class="fragment"><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;                                  {</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    assert(<a class="code" href="structfolly_1_1IndexedMemPool.html#a61b91e16f6e73a440a776fab01041157">isAllocated</a>(idx));</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    <a class="code" href="structfolly_1_1IndexedMemPool.html#ac891d55dbb470b95ea9f16980ddba99c">localPush</a>(<a class="code" href="structfolly_1_1IndexedMemPool.html#a77c13722bca3b74a0fc4c8dfc5264110">localHead</a>(), idx);</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;  }</div><div class="ttc" id="structfolly_1_1IndexedMemPool_html_a77c13722bca3b74a0fc4c8dfc5264110"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a77c13722bca3b74a0fc4c8dfc5264110">folly::IndexedMemPool::localHead</a></div><div class="ttdeci">AtomicStruct&lt; TaggedPtr, Atom &gt; &amp; localHead()</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00525">IndexedMemPool.h:525</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a61b91e16f6e73a440a776fab01041157"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a61b91e16f6e73a440a776fab01041157">folly::IndexedMemPool::isAllocated</a></div><div class="ttdeci">bool isAllocated(uint32_t idx) const </div><div class="ttdoc">Returns true iff idx has been alloc()ed and not recycleIndex()ed. </div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00320">IndexedMemPool.h:320</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_ac891d55dbb470b95ea9f16980ddba99c"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#ac891d55dbb470b95ea9f16980ddba99c">folly::IndexedMemPool::localPush</a></div><div class="ttdeci">void localPush(AtomicStruct&lt; TaggedPtr, Atom &gt; &amp;head, uint32_t idx)</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00446">IndexedMemPool.h:446</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a54bed1acb2c122bd20384b31b201bf2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfolly_1_1IndexedMemPool_1_1Slot.html">Slot</a>&amp; <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::slot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00424">424</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;                           {</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="structfolly_1_1IndexedMemPool.html#a87ce967c5980255616eb717751234215">slots_</a>[<a class="code" href="structfolly_1_1IndexedMemPool.html#a1f196b7dcd5f4322313b983307fa1be1">slotIndex</a>(idx)];</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;  }</div><div class="ttc" id="structfolly_1_1IndexedMemPool_html_a87ce967c5980255616eb717751234215"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a87ce967c5980255616eb717751234215">folly::IndexedMemPool::slots_</a></div><div class="ttdeci">Slot * slots_</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00403">IndexedMemPool.h:403</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a1f196b7dcd5f4322313b983307fa1be1"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a1f196b7dcd5f4322313b983307fa1be1">folly::IndexedMemPool::slotIndex</a></div><div class="ttdeci">uint32_t slotIndex(uint32_t idx) const </div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00417">IndexedMemPool.h:417</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a84a92f08af2d6bf594771881006094d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structfolly_1_1IndexedMemPool_1_1Slot.html">Slot</a>&amp; <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::slot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00428">428</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;                                       {</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="structfolly_1_1IndexedMemPool.html#a87ce967c5980255616eb717751234215">slots_</a>[<a class="code" href="structfolly_1_1IndexedMemPool.html#a1f196b7dcd5f4322313b983307fa1be1">slotIndex</a>(idx)];</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;  }</div><div class="ttc" id="structfolly_1_1IndexedMemPool_html_a87ce967c5980255616eb717751234215"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a87ce967c5980255616eb717751234215">folly::IndexedMemPool::slots_</a></div><div class="ttdeci">Slot * slots_</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00403">IndexedMemPool.h:403</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a1f196b7dcd5f4322313b983307fa1be1"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a1f196b7dcd5f4322313b983307fa1be1">folly::IndexedMemPool::slotIndex</a></div><div class="ttdeci">uint32_t slotIndex(uint32_t idx) const </div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00417">IndexedMemPool.h:417</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1f196b7dcd5f4322313b983307fa1be1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::slotIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00417">417</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;                                         {</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    assert(</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;        0 &lt; idx &amp;&amp; idx &lt;= <a class="code" href="structfolly_1_1IndexedMemPool.html#a8c0e8b2087c4fbf6ffc4edc84d0c9ad8">actualCapacity_</a> &amp;&amp;</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;        idx &lt;= <a class="code" href="structfolly_1_1IndexedMemPool.html#a5de3d071fbddfc1dae27a23e52b55b6e">size_</a>.load(std::memory_order_acquire));</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    <span class="keywordflow">return</span> idx;</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;  }</div><div class="ttc" id="structfolly_1_1IndexedMemPool_html_a8c0e8b2087c4fbf6ffc4edc84d0c9ad8"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a8c0e8b2087c4fbf6ffc4edc84d0c9ad8">folly::IndexedMemPool::actualCapacity_</a></div><div class="ttdeci">uint32_t actualCapacity_</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00393">IndexedMemPool.h:393</a></div></div>
<div class="ttc" id="structfolly_1_1IndexedMemPool_html_a5de3d071fbddfc1dae27a23e52b55b6e"><div class="ttname"><a href="structfolly_1_1IndexedMemPool.html#a5de3d071fbddfc1dae27a23e52b55b6e">folly::IndexedMemPool::size_</a></div><div class="ttdeci">Atom&lt; uint32_t &gt; size_</div><div class="ttdef"><b>Definition:</b> <a href="IndexedMemPool_8h_source.html#l00399">IndexedMemPool.h:399</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a8c0e8b2087c4fbf6ffc4edc84d0c9ad8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a> <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::actualCapacity_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>the actual number of slots that we will allocate, to guarantee that we will satisfy the capacity requested at construction time. They will be numbered 1..actualCapacity_ (note the 1-based counting), and occupy slots_[1..actualCapacity_]. </p>

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00393">393</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad2fe1c0e0a1b1f933451b10930a7f9e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfolly_1_1AtomicStruct.html">AtomicStruct</a>&lt;<a class="el" href="structfolly_1_1IndexedMemPool_1_1TaggedPtr.html">TaggedPtr</a>, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>&gt; <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::globalHead_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>this is the head of a list of node chained by globalNext, that are themselves each the head of a list chained by localNext </p>

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00413">413</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a66ebc64f81b4d965c230a6dd1ede1521"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::kSlotSize = <a class="el" href="namespacefolly.html#a7c631f0179944e4771e98d398db760dd">sizeof</a>(<a class="el" href="structfolly_1_1IndexedMemPool_1_1Slot.html">Slot</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00535">535</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a273ddc208d0f0426b92263c0ca2ea94d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfolly_1_1IndexedMemPool_1_1LocalList.html">LocalList</a> <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::local_[<a class="el" href="structfolly_1_1IndexedMemPool.html#ac0e99c90c5be51024f0d212695d8b860aec01e4ff6a7b8dcb5201fdf00805226d">NumLocalLists</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>use <a class="el" href="structfolly_1_1AccessSpreader.html">AccessSpreader</a> to find your list. We use stripes instead of thread-local to avoid the need to grow or shrink on thread start or join. These are heads of lists chained with localNext </p>

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00408">408</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

</div>
</div>
<a class="anchor" id="abcd1a5d8cc16433d2da9f6179cdee914"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::mmapLength_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>the number of bytes allocated from mmap, which is a multiple of the page size of the machine </p>

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00387">387</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5de3d071fbddfc1dae27a23e52b55b6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>&lt;<a class="el" href="ConstexprMathBenchmark_8cpp.html#a09a1e304d66d35dd47daffee9731edaa">uint32_t</a>&gt; <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>this records the number of slots that have actually been constructed. To allow use of atomic ++ instead of CAS, we let this overflow. The actual number of constructed elements is min(actualCapacity_, size_) </p>

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00399">399</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a87ce967c5980255616eb717751234215"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, uint32_t NumLocalLists_ = 32, uint32_t LocalListLimit_ = 200, template&lt; typename &gt; class Atom = std::atomic, typename Traits = IndexedMemPoolTraits&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfolly_1_1IndexedMemPool_1_1Slot.html">Slot</a>* <a class="el" href="structfolly_1_1IndexedMemPool.html">folly::IndexedMemPool</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a>, NumLocalLists_, LocalListLimit_, <a class="el" href="ConcurrentHashMapTest_8cpp.html#a98ac53dd3c18b4046e7c5cb0bcb64b75">Atom</a>, Traits &gt;::slots_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>raw storage, only 1..min(size_,actualCapacity_) (inclusive) are actually constructed. Note that slots_[0] is not constructed or used </p>

<p>Definition at line <a class="el" href="IndexedMemPool_8h_source.html#l00403">403</a> of file <a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>proxygen/folly/folly/<a class="el" href="IndexedMemPool_8h_source.html">IndexedMemPool.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefolly.html">folly</a></li><li class="navelem"><a class="el" href="structfolly_1_1IndexedMemPool.html">IndexedMemPool</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
