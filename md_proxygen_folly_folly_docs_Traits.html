<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: &#39;folly/Traits.h&#39;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_proxygen_folly_folly_docs_Traits.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">'folly/Traits.h' </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Implements traits complementary to those provided in &lt;type_traits&gt;</p>
<ul>
<li>Implements <code>IsRelocatable</code> trait.</li>
<li>Implements <code>IsOneOf</code> trait</li>
<li>Macros to state the assumptions easily</li>
</ul>
<h3>Motivation</h3>
<hr/>
<p><code>&lt;type_traits&gt;</code> is the Standard type-traits library defining a variety of traits such as <code>is_integral</code> or <code>is_floating_point</code>. This helps to gain more information about a given type.</p>
<p><code>folly/Traits.h</code> implements traits complementing those present in the Standard.</p>
<h3>IsRelocatable</h3>
<hr/>
<p>In C++, the default way to move an object is by calling the copy constructor and destroying the old copy instead of directly copying the memory contents by using memcpy(). The conservative approach of moving an object assumes that the copied object is not relocatable. The two following code sequences should be semantically equivalent for a relocatable type:</p>
<div class="fragment"><div class="line">{</div><div class="line">  <span class="keywordtype">void</span> conservativeMove(<a class="code" href="http__parser_8c.html#ad24d0de3f597ca60dd95c4bc59c2ff73">T</a> * <a class="code" href="namespacefolly_1_1pushmi_1_1operators.html#a66a275bf0c134161fd2050e9ec72a29d">from</a>, <a class="code" href="http__parser_8c.html#ad24d0de3f597ca60dd95c4bc59c2ff73">T</a> * <a class="code" href="namespacefolly.html#a005f91db4ecc55675cf5ad7ba25ec24d">to</a>) {</div><div class="line">    <span class="keyword">new</span>(<a class="code" href="namespacefolly.html#a005f91db4ecc55675cf5ad7ba25ec24d">to</a>) <a class="code" href="http__parser_8c.html#ad24d0de3f597ca60dd95c4bc59c2ff73">T</a>(from);</div><div class="line">    (*from).~T();</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">  <span class="keywordtype">void</span> optimizedMove(<a class="code" href="http__parser_8c.html#ad24d0de3f597ca60dd95c4bc59c2ff73">T</a> * from, <a class="code" href="http__parser_8c.html#ad24d0de3f597ca60dd95c4bc59c2ff73">T</a> * to) {</div><div class="line">    memcpy(to, from, <span class="keyword">sizeof</span>(<a class="code" href="http__parser_8c.html#ad24d0de3f597ca60dd95c4bc59c2ff73">T</a>));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>Very few C++ types are non-relocatable. The type defined below maintains a pointer inside an embedded buffer and hence would be non-relocatable. Moving the object by simply copying its memory contents would leave the internal pointer pointing to the old buffer.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>NonRelocatableType {</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">char</span> <a class="code" href="experimental_2test_2BitsBenchmark_8cpp.html#a25bccaee4203f6f142efc1f61e9b66c5">buffer</a>[1024];</div><div class="line">  <span class="keywordtype">char</span> * pointerToBuffer;</div><div class="line">  ...</div><div class="line">public:</div><div class="line">  NonRelocatableType() : pointerToBuffer(buffer) {}</div><div class="line">  ...</div><div class="line">};</div></div><!-- fragment --><p>We can optimize the task of moving a relocatable type T using memcpy. IsRelocatable&lt;T&gt;::value describes the ability of moving around memory a value of type T by using memcpy.</p>
<h3>Usage</h3>
<hr/>
<ul>
<li><p class="startli">Declaring types</p>
<p class="startli">```Cpp template &lt;class <a class="el" href="structT1.html">T1</a>, class <a class="el" href="structT2.html">T2</a>&gt; class MyParameterizedType;</p>
<p class="startli">class MySimpleType; ```</p>
</li>
<li><p class="startli">Declaring a type as relocatable</p>
<p class="startli">Appending the lines below after definition of My*Type (<code>MyParameterizedType</code> or <code>MySimpleType</code>) will declare it as relocatable</p>
<p class="startli">```Cpp /* Definition of My*Type goes here */ // global namespace (not inside any namespace) namespace folly { // defining specialization of IsRelocatable for MySimpleType template &lt;&gt; struct IsRelocatable&lt;MySimpleType&gt; : std::true_type {}; // defining specialization of IsRelocatable for MyParameterizedType template &lt;class <a class="el" href="structT1.html">T1</a>, class <a class="el" href="structT2.html">T2</a>&gt; struct IsRelocatable&lt;MyParameterizedType&lt;T1, T2&gt;&gt; : ::std::true_type {}; } ```</p>
</li>
<li>To make it easy to state assumptions for a regular type or a family of parameterized type, various macros can be used as shown below.</li>
<li><p class="startli">Stating that a type is Relocatable using a macro</p>
<p class="startli">```Cpp // global namespace namespace folly { // For a Regular Type <a class="el" href="Traits_8h.html#a6817881896de35b6c9623e9075a86aa2">FOLLY_ASSUME_RELOCATABLE(MySimpleType)</a>; // For a Parameterized Type <a class="el" href="Traits_8h.html#a6817881896de35b6c9623e9075a86aa2">FOLLY_ASSUME_RELOCATABLE(MyParameterizedType&lt;T1, T2&gt;)</a>; } ```</p>
</li>
</ul>
<p><code>fbvector</code> only works with relocatable objects. If assumptions are not stated explicitly, <code>fbvector&lt;MySimpleType&gt;</code> or <code>fbvector&lt;MyParameterizedType&gt;</code> will fail to compile due to assertion below:</p>
<div class="fragment"><div class="line">static_assert(<a class="code" href="Conv_8cpp.html#a2f6ac1714c34743067351b0d2a64162b">IsRelocatable&lt;My*Type&gt;::value</a>, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --><p>FOLLY_ASSUME_FBVECTOR_COMPATIBLE*(type) macros can be used to state that type is relocatable and has nothrow constructor.</p>
<ul>
<li><p class="startli">Stating that a type is <code>fbvector-compatible</code> using macros i.e. relocatable and has nothrow default constructor</p>
<p class="startli">```Cpp // at global level, i.e no namespace // macro for regular type <a class="el" href="Traits_8h.html#a6e627af1326145e14389d13054f0e03a">FOLLY_ASSUME_FBVECTOR_COMPATIBLE(MySimpleType)</a> // macro for types having 2 template parameters (MyParameterizedType) <a class="el" href="Traits_8h.html#a673c7652173f5c3d921168fb2f72d120">FOLLY_ASSUME_FBVECTOR_COMPATIBLE_2(MyParameterizedType)</a> ```</p>
</li>
</ul>
<p>Similarly,</p>
<ul>
<li><a class="el" href="Traits_8h.html#ab74094a73b9eada94387f28b2f99975e">FOLLY_ASSUME_FBVECTOR_COMPATIBLE_1(MyTypeHavingOneParameter)</a> macro is for family of parameterized types having 1 parameter</li>
<li><a class="el" href="Traits_8h.html#af141419d104229854b8e63fd10e827be">FOLLY_ASSUME_FBVECTOR_COMPATIBLE_3(MyTypeHavingThreeParameters)</a> macro is for family of parameterized types having 3 parameters</li>
<li><a class="el" href="Traits_8h.html#afc5c626976285bdb6a910a594e76daa2">FOLLY_ASSUME_FBVECTOR_COMPATIBLE_4(MyTypeHavingFourParameters)</a> macro is for family of parameterized types having 4 parameters</li>
</ul>
<p>Few common types, namely <code>std::basic_string</code>, <code>std::vector</code>, <code>std::list</code>, <code>std::map</code>, <code>std::deque</code>, <code>std::set</code>, <code>std::unique_ptr</code>, <code>std::shared_ptr</code>, <code>std::function</code>, which are compatible with <code>fbvector</code> are already instantiated and declared compatible with <code>fbvector</code>. <code>fbvector</code> can be directly used with any of these C++ types.</p>
<p><code>std::pair</code> can be safely assumed to be compatible with <code>fbvector</code> if both of its components are.</p>
<h3>IsOneOf</h3>
<hr/>
<p><code>std::is_same&lt;<a class="el" href="structT1.html">T1</a>, <a class="el" href="structT2.html">T2</a>&gt;<a class="el" href="Crc32CombineDetail_8cpp.html#aeaa7b1832e5d1cbfc21edb15bbe1700e">value</a></code> can be used to test if types of <a class="el" href="structT1.html">T1</a> and <a class="el" href="structT2.html">T2</a> are same. <code><a class="el" href="namespacefolly.html#aa806356886e3c7c88d073c3e06d76746">folly::IsOneOf</a>&lt;T, <a class="el" href="structT1.html">T1</a>, Ts...&gt;<a class="el" href="Crc32CombineDetail_8cpp.html#aeaa7b1832e5d1cbfc21edb15bbe1700e">value</a></code> can be used to test if type of <a class="el" href="structT1.html">T1</a> matches the type of one of the other template parameter, <a class="el" href="structT1.html">T1</a>, <a class="el" href="structT2.html">T2</a>, ...Tn. Recursion is used to implement this type trait. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
