<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: # folly/io/async: An object-oriented wrapper around libevent</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_proxygen_folly_folly_io_async_README.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title"># folly/io/async: An object-oriented wrapper around libevent </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://github.com/libevent/libevent">libevent</a> is an excellent cross-platform eventing library. Folly's async provides C++ object wrappers for fd callbacks and event_base, as well as providing implementations for many common types of fd uses.</p>
<h2>EventBase</h2>
<p>The main libevent / epoll loop. Generally there is a single EventBase per thread, and once started, nothing else happens on the thread except fd callbacks. For example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;EventBase base;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;auto thread = std::thread([&amp;](){</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  base.loopForever();</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;});</div></div><!-- fragment --><p>EventBase has built-in support for message passing between threads. To send a function to be run in the EventBase thread, use runInEventBaseThread().</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;EventBase base;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;auto thread1 = std::thread([&amp;](){</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  base.loopForever();</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;});</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;base.runInEventBaseThread([&amp;](){</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  printf(&quot;This will be printed in thread1\n&quot;);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;});</div></div><!-- fragment --><p>There are various ways to run the loop. EventBase::loop() will return when there are no more registered events. EventBase::loopForever() will loop until EventBase::terminateLoopSoon() is called. EventBase::loopOnce() will only call epoll() a single time.</p>
<p>Other useful methods include EventBase::runAfterDelay() to run events after some delay, and EventBase::setMaxLatency(latency, callback) to run some callback if the loop is running very slowly, i.e., there are too many events in this loop, and some code should probably be running in different threads.</p>
<p>EventBase always calls all callbacks inline - that is, there is no explicit or implicit queuing. The specific implications of this are:</p>
<ul>
<li>Tail-latency times (P99) are vastly better than any queueing implementation</li>
<li>The EventHandler implementation is responsible for not taking too long in any individual callback. All of the EventHandlers in this implementation already do a good job of this, but if you are subclassing EventHandler directly, something to keep in mind.</li>
<li>The callback cannot delete the EventBase or EventHandler directly, since it is still on the call stack. See DelayedDestruction class description below, and use shared_ptrs appropriately.</li>
</ul>
<h2>EventHandler</h2>
<p>EventHandler is the object wrapper for fd's. Any class you wish to receive callbacks on will inherit from EventHandler. <code>registerHandler(EventType)</code> will register to receive events of a specific type.</p>
<p>Currently supported event types:</p>
<ul>
<li>READ - read and EOF events</li>
<li>WRITE - write events, when kernel write buffer is empty</li>
<li>READ_WRITE - both</li>
<li>PERSIST - The event will remain registered even after the handlerReady() fires</li>
</ul>
<p>Unsupported libevent event types, and why-</p>
<ul>
<li>TIMEOUT - this library has specific timeout support, instead of being attached to read/write fds.</li>
<li>SIGNAL - similarly, signals are handled separately, see AsyncSignalHandler</li>
<li><p class="startli">EV_ET - Currently all the implementations of EventHandler are set up for level triggered. Benchmarking hasn't shown that edge triggered provides much improvement.</p>
<p class="startli">Edge-triggered in this context means that libevent will provide only a single callback when an event becomes active, as opposed to level-triggered where as long as there is still data to read/write, the event will continually fire each time event_wait is called. Edge-triggered adds extra code complexity, since the library would need to maintain a similar list of active FDs that libevent currently does between edge triggering events. The only advantage of edge-triggered is that you can use EPOLLONESHOT to ensure the event only gets called on a single event_base - but in this library, we assume each event is only registered on a single thread anyway.</p>
</li>
<li>EV_FINALIZE - EventBase can only be used in a single thread, excepting a few methods. To safely unregister an event from a different thread, it would have to be done through EventBase::runInEventBaseThread(). Most APIs already make this thread transition for you, or at least CHECK() that you've done it in the correct thread.</li>
<li>EV_CLOSED - This is an optimization - instead of having to READ all the data and then get an EOF, EV_CLOSED would fire before all the data is read. TODO: implement this. Probably only useful in request/response servers.</li>
</ul>
<h2>Implementations of EventHandler</h2>
<h3>AsyncSocket</h3>
<p><a class="el" href="structA.html">A</a> nonblocking socket implementation. Writes are queued and written asynchronously, even before <a class="el" href="namespacefolly_1_1netops.html#ac1c485d763067b5987724117affe463d">connect()</a> is successful. The read api consists of two methods: getReadBuffer() and readDataAvailable(). When the READ event is signaled, libevent has no way of knowing how much data is available to read. In some systems (linux), we <em>could</em> make another syscall to get the data size in the kernel read buffer, but syscalls are slow. Instead, most users will just want to provide a fixed size buffer in getReadBuffer(), probably using the IOBufQueue in folly/io. readDataAvailable() will then describe exactly how much data was read.</p>
<p>AsyncSocket provides send timeouts, but not read timeouts - generally read timeouts are application specific, and should use an AsyncTimer implementation below.</p>
<p>Various notes:</p>
<ul>
<li>Using a chain of IOBuf objects, and calling writeChain(), is a very syscall-efficient way to add/modify data to be sent, without unnecessary copies.</li>
<li>setMaxReadsPerEvent() - this prevents an AsyncSocket from blocking the event loop for too long.</li>
<li>Don't use the fd for syscalls yourself while it is being used in AsyncSocket, instead use the provided wrappers, like <a class="el" href="namespacefolly_1_1netops.html#a27d9201e6386937ffded3bfd86f995aa">AsyncSocket::close()</a>, <a class="el" href="namespacefolly.html#a89e6d5d07a92c88cf24c7a3f9a02f94e">shutdown()</a>, etc.</li>
</ul>
<h4>AsyncSSLSocket</h4>
<p>Similar to AsyncSocket, but uses openssl. Provides an additional HandshakeCallback to check the server's certificates.</p>
<h4>TAsyncUDPSocket</h4>
<p>TODO: Currently in fbthrift.</p>
<p><a class="el" href="structA.html">A</a> socket that reads/writes UDP packets. Since there is little state to maintain, this is much simpler than AsyncSocket.</p>
<h3>AsyncServerSocket</h3>
<p><a class="el" href="structA.html">A</a> <a class="el" href="namespacefolly_1_1netops.html#ace702f1a8775087ffe26719278824191">listen()</a>ing socket that <a class="el" href="namespacefolly_1_1netops.html#a1fbffaeaeb4c134076228e7e3be0c783">accept()</a>s fds, and passes them to other event bases.</p>
<p>The general pattern is:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;EventBase base;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;auto socket = AsyncServerSocket::newSocket(&amp;base);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;socket-&gt;bind(port); // 0 to choose any free port</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;socket-&gt;addAcceptCallback(object, &amp;base); // where object is the object that implements the accept callback, and base is the object&#39;s eventbase.  base::runInEventBaseThread() will be called to send it a message.</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;socket-&gt;listen(backlog);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;socket-&gt;startAccepting();</div></div><!-- fragment --><p>Generally there is a single <a class="el" href="namespacefolly_1_1netops.html#a1fbffaeaeb4c134076228e7e3be0c783">accept()</a> thread, and multiple AcceptCallback objects. The Acceptee objects then will manage the individual AsyncSockets. While AsyncSockets <em>can</em> be moved between event bases, most users just tie them to a single event base to get better cache locallity, and to avoid locking.</p>
<p>Multiple ServerSockets can be made, but currently the linux kernel has a lock on <a class="el" href="namespacefolly_1_1netops.html#a1fbffaeaeb4c134076228e7e3be0c783">accept()</a>ing from a port, preventing more than ~20k accepts / sec. There are various workarounds (SO_REUSEPORT), but generally clients should be using connection pooling instead when possible.</p>
<p>Since AsyncServerSocket provides an fd, an AsyncSSLSocket or AsyncSocket can be made using the same codepath</p>
<h4>TAsyncUDPServerSocket</h4>
<p>Similar to AsyncServerSocket, but for UDP messages - messages are <a class="el" href="namespacefizz_1_1detail.html#a36dc6280bf4d04bce115a7055a78abac">read()</a> on a single thread, and then fanned out to multiple worker threads.</p>
<h3>NotificationQueue (EventFD or pipe notifications)</h3>
<p>NotificationQueue is used to send messages between threads in the <em>same process</em>. It is what backs EventBase::runInEventBaseThread(), so it is unlikely you'd want to use it directly instead of using runInEventBaseThread().</p>
<p>An eventFD (for kernels &gt; 2.6.30) or pipe (older kernels) are added to the EventBase loop to wake up threads receiving messages. The queue itself is a spinlock-guarded list. Since we are almost always talking about a single sender thread and a single receiver (although the code works just fine for multiple producers and multiple consumers), the spinlock is almost always uncontended, and we haven't seen any perf issues with it in practice.</p>
<p>The eventfd or pipe is only notified if the thread isn't already awake, to avoid syscalls. <a class="el" href="structA.html">A</a> naive implementaiton that does one write per message in the queue, or worse, writes the whole message to the queue, would be significantly slower.</p>
<p>If you need to send messages <em>between processes</em>, you would have to write the whole message to the pipe, and manage the pipe size. See AsyncPipe.</p>
<h3>AsyncTimeout</h3>
<p>An individual timeout callback that can be installed in the event loop. For code cleanliness and clarity, timeouts are separated from sockets. There is one fd used per AsyncTimeout. This is a pretty serious restriction, so the two below subclasses were made to support multiple timeouts using a single fd.</p>
<h4>HHWheelTimer</h4>
<p>Implementation of a <a href="http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf">hashed hierarchical wheel timer</a>. Any timeout time can be used, with O(1) insertion, deletion, and callback time. The wheel itself takes up some amount of space, and wheel timers have to have a constant tick, consuming a constant amount of CPU.</p>
<p>An alternative to a wheel timer would be a heap of callbacks sorted by timeout time, but would change the big-O to O(log n). In our experience, the average server has thousands to hundreds of thousands of open sockets, and the common case is to add and remove timeouts without them ever firing, assuming the server is able to keep up with the load. Therefore O(log n) insertion time overshadows the extra CPU consumed by a wheel timer tick.</p>
<h4>TAsyncTimeoutSet</h4>
<p>NOTE: currently in proxygen codebase.</p>
<p>If we assume that all timeouts scheduled use the same timeout time, we can keep O(1) insertion time: just schedule the new timeout at the tail of the list, along with the time it was actually added. When the current timeout fires, we look at the new head of the list, and schedule AsyncTimeout to fire at the difference between the current time and the scheduled time (which probably isn't the same as the timeout time.)</p>
<p>This requires all AsyncTimeoutSets timeouts to have the same timeout time though, which in practice means many AsyncTimeoutSets are needed per application. Using HHWheelTimer instead can clean up the code quite a bit, because only a single HHWheelTimer is needed per thread, as opposed to one AsyncTimeoutSet per timeout time per thread.</p>
<h3>AsyncSignalHandler</h3>
<p>Used to handle AsyncSignals. Similar to AsyncTimeout, for code clarity, we don't reuse the same fd as a socket to receive signals.</p>
<h3>AsyncPipe</h3>
<p>Async reads/writes to a unix pipe, to send data between processes.</p>
<h2>Helper Classes</h2>
<h3>RequestContext (in Request.h)</h3>
<p>Since messages are frequently passed between threads with runInEventBaseThread(), ThreadLocals don't work for messages. Instead, RequestContext can be used, which is saved/restored between threads. Major uses for this include:</p>
<ul>
<li>NUMA: saving the numa node the code was running on, and explicitly running it on the same node in other threadpools / eventbases</li>
<li>Tracing: tracing requests dapper-style intra machine, as well as between threads themselves.</li>
</ul>
<p>In this library only runInEventBaseThread save/restores the request context, although other Facebook libraries that pass requests between threads do also: folly::future, and fbthrift::ThreadManager, etc</p>
<h3>DelayedDestruction</h3>
<p>Since EventBase callbacks already have the EventHandler and EventBase on the stack, calling <code>delete</code> on either of these objects would most likely result in a segfault. Instead, these objects inherit from DelayedDestruction, which provides reference counting in the callbacks. Instead of delete, <code><a class="el" href="ThreadPoolExecutorTest_8cpp.html#a48d87d9b4245c5ac2b79b3314f8bef9e">destroy()</a></code> is called, which notifies that is ready to be destroyed. In each of the callbacks there is a DestructorGuard, which prevents destruction until all the Guards are gone from the stack, when the actual delete method is called.</p>
<p>DelayedDestruction can be a painful to use, since shared_ptrs and unique_ptrs need to have a special DelayedDestruction destructor type. It's also pretty easy to forget to add a DestructorGuard in code that calls callbacks. But it is well worth it to avoid queuing callbacks, and the improved P99 times as a result.</p>
<h3>DestructorCheck</h3>
<p>Often for an object requesting callbacks from other components (timer, socket connect, etc.) there is a chance that the requestor will be deallocated before it'll receive the callback. One of the ways to avoid dereferencing the deallocated object from callbacks is to derive the object from DelayedDestruction, and add a delayed destruction guard to the callback context. In case if keeping the object around until all the requested callbacks fire is too expensive, or if the callback requestor can't have private destructor (it's allocated on the stack, or as a member of a larger object), DestructorCheck can be used. DestructorCheck is not affecting object life time. It helps other component to detect safely that the tracked object was deallocated.</p>
<p>The object requesting the callback must be derived from DestructorCheck. The callback context should contain an instance of DestructorCheck::Safety object initialized with a reference to the object requesting the callback. Safety object can be captured by value in the callback lambda, or explicitly added to a predefined callback context class. Multiple instances of Safety object can be instantiated for the same tracked object. Once the callback is invoked, before dereferencing the requester object, callback code should make sure that <code>destroyed()</code> method for the corresponding Safety object returns false.</p>
<h3>EventBaseManager</h3>
<p>DANGEROUS.</p>
<p>Since there is ususally only a single EventBase per thread, why not make EventBase managed by a threadlocal? Sounds easy! But there are several catches:</p>
<ul>
<li>The EventBase returned by <code><a class="el" href="namespacefolly_1_1pushmi_1_1operators.html#a3fb4b634ea259cf94b63687a25b3f505">EventBaseManager::get()</a>-&gt;<a class="el" href="namespacefolly.html#af7fbee06181c27cb9f88984f78293232">getEventBase()</a></code> may not actually be running.</li>
<li>There may be more than one event base in the thread (unusual), or the EventBase in the code may not be registerd in EventBaseManager.</li>
<li>The event bases in EventBaseManager may be used for different purposes, i.e. some are AsyncSocket threads, and some are AsyncServerSocket threads: So you can't just grab the list of EventBases and call runInEventBaseThread() on all of them and expect it to do the right thing.</li>
</ul>
<p><a class="el" href="structA.html">A</a> much safer option is to explicitly pass around an EventBase, or use an explicit pool of EventBases.</p>
<h3>SSLContext</h3>
<p>SSL helper routines to load / verify certs. Used with AsyncSSLSocket.</p>
<h2>Generic Multithreading Advice</h2>
<p>Facebook has a lot of experience running services. For background reading, see <a href="http://www.kegel.com/c10k.html">The C10k problem</a> and <a href="http://nick-black.com/dankwiki/index.php/Fast_UNIX_Servers">Fast UNIX servers</a></p>
<p>Some best practices we've found:</p>
<ol type="1">
<li>It's much easier to maintain latency expectations when each EventBase thread is used for only a single purpose: AsyncServerSocket, or inbound AsyncSocket, or in proxies, outbound AsyncSocket calls. In a perfect world, one EventBase per thread per core would be enough, but the implementor needs to be extremely diligent to make sure all CPU work is moved off of the IO threads to prevent slow read/write/closes of fds.</li>
<li><b>ANY</b> work that is CPU intensive should be offloaded to a pool of CPU-bound threads, instead of being done in the EventBase threads. runInEventBaseThread() is fast: It can be called millions of times per second before the spinlock becomes an issue - so passing the request off to a different thread is probably fine perf wise.</li>
<li>In contrast to the first two recommendations, if there are more total threads than cores, context switching overhead can become an issue. In particular we have seen this be an issue when a CPU-intensive thread blocks the scheduling of an IO thread, using the linux <code>perf sched</code> tool.</li>
<li>For async programming, in contrast to synchronous systems, managing load is extremely hard - it is better to use out-of-band methods to notify of overload, such as timeouts, or CPU usage. For sync systems, you are almost always limited by the number of threads. For more details see <a href="https://www.usenix.org/legacy/event/hotos09/tech/full_papers/aguilera/aguilera.pdf">No Time for Asynchrony</a> </li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
