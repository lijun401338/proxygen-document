<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: proxygen/folly/folly/docs/Function.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('Function_8md.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">proxygen/folly/folly/docs/Function.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="Function_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;`folly/Function.h`</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;------------------</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;`folly::Function` is a polymorphic function wrapper that is not copyable and does not require the wrapped function to be copy constructible. It is similar to `std::function`, but different with respect to some interesting features.</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;There are some limitations in `std::function` that `folly::Function` tries to avoid. `std::function` is copy-constructible and requires that the callable that it wraps is copy-constructible as well, which is a constraint that is often inconvenient. In most cases when using a `std::function` you don&#39;t make use of its copy-constructibility, so you might sometimes feel like you get back very little in return for a noticeable restriction.</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;This restriction becomes apparent when trying to use a lambda capturing a `unique_ptr` (or any non-copyable type) as a callback for a folly::Future.</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;``` Cpp</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;std::unique_ptr&lt;Foo&gt; foo_ptr = new Foo;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;some_future.then(</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    [foo_ptr = std::move(foo_ptr)] mutable</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    (int x)</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    { foo_ptr-&gt;setX(x); }</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;);</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;```</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;This piece of code did not compile before `folly::Future` started using `folly::Function` instead of `std::function` to store the callback. Because the lambda captures something non-copyable (the `unique_ptr`), it is not copyable itself. And `std::function` can only store copyable callables.</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;The implementation of folly::Future did not make use of the copy-constructibility of `std::function` at any point. There was no benefit from the fact that the `std::function` is copy-constructible, but the fact that it can only wrap copy-constructible callables posed a restriction.</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;A workaround was available: `folly::MoveWrapper`, which wraps an object that may be non-copyable and implements copy operations by moving the embedded object. Using a `folly::MoveWrapper`, you can capture non-copyable objects in a lambda, and the lambda itself is still copyable and may be wrapped in a `std::function`. It is a pragmatic solution for the above problem, but you have to be a little careful. The problem is that you can’t use a `MoveWrapper` anywhere where copy operations are assumed to behave like actual copy operations. Also, a `folly::MoveWrapper&lt;std::unique_ptr&lt;T&gt;&gt;` essentially behaves like `auto_ptr&lt;T&gt;`. Ask yourself whether you’d want to use lots of `auto_ptr`s in your codebase. And the original question still persists: we very often don’t benefit from copy-constructibility of `std::function`, so why do we have to live with this restriction? I.e. why do we have to use `MoveWrapper`?</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;`folly::Function` is an actual solution to this problem, as it can wrap non-copyable callables, at the cost of not being copy-constructible, which more often than not is not a relevant restriction. `folly::Future` now uses `folly::Function` to store callbacks, so the good news is: the code example from the top of this note is becoming a perfectly valid way to use future callbacks. The code compiles and behaves as you would expect.</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;Here are more details about `folly::Function`: much like `std::function`, it wraps an arbitrary object that can be invoked like a given function type. E.g. a `folly::Function&lt;int(std::string, double)&gt;` can wrap any callable object that returns an `int` (or something that is convertible to an `int`) when invoked with a `std::string` and a `double` argument. The function type is a template parameter of `folly::Function`, but the specific type of the callable is not. Also, like most implementations of `std::function`, `folly::Function` will store small callable objects in-place whereas larger callables will be stored on the heap. (Unlike `std::function`, you can set the size of the in-place storage as a template parameter of `folly::Function`.)</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;Other than copyability, there is one more significant difference between `std::function` and `folly::Function`, and it concerns const-correctness. `std::function` does not enforce const-correctness: it allows you to store mutable callables (i.e. callables that may change their inner state when executed, such as a mutable lambda) and call them in a const context (i.e. when you only have access to a const reference to the `std::function` object). For example:</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;``` Cpp</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;class FooBar {</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160; public:</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  void call_func() const {</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    func_();</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  }</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160; private:</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  std::function&lt;void()&gt; func_;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;};</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;```</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;The `call_func` member function is declared const. However, when it calls `func_()`, it may change the inner state of `func_`, and thereby the inner state of the `FooBar` object. Inside the `FooBar` class, `func_` is like a non-const method that is callable from const methods.</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;Some people consider `std::function` in the standard broken with respect to this. (Paper N4348 explains this problem in more detail.) It also lists possible ways to fix the problem. `folly::Function`, however, goes a different way: you have to declare whether you want to store a const function, in which case you can invoke any reference (const or non-const) of the `folly::Function`, or a non-const (mutable) function, in which case you need a non-const reference to the `folly::Function` to be able to invoke it. In the above example, let’s say that `func_` stores a const function, which makes it okay that it gets invoked from `call_func` (a const method). Instead of `std::function`, you could use `folly::Function&lt;void() const&gt;` for the `func_` member.</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;Const-ness is part of a function type. To illustrate:</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;``` Cpp</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;class Foo {</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160; public:</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;  int operator()() { return 1; }</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  int operator()(char const*) { return 2; }</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;  int operator()(int) { return 3; }</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  int operator()(int) const { return 4; }</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  int operator()(int, int) const { return 5; }</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;};</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;```</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;You can overload methods multiple times using different argument signatures. Const-ness is part of that signature, so even for the same set of argument types you can overload a const and a non-const version. It’s not even particularly unusual to do that. Take for instance the `begin()` method of STL container types: `begin()` returns an `iterator`, `begin() const` returns a `const_iterator`. `folly::Function` allows you to select a specific overload easily:</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;``` Cpp</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;folly::Function&lt;int()&gt; uf1 = Foo();</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;// uf1() returns 1</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;folly::Function&lt;int(char const*)&gt; uf2 = Foo();</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;// uf2() returns 2</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;folly::Function&lt;int(int)&gt; uf3 = Foo();</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;// uf3() returns 3</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;folly::Function&lt;int(int) const&gt; uf4 = Foo();</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;// uf4() returns 4</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;folly::Function&lt;int(int, int) const&gt; uf5 = Foo();</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;// uf5() returns 5</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;```</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;If `cfoo` is a const-reference to a `Foo` object, `cfoo(int)` returns 4. If `foo` is a non-const reference to a `Foo` object, `foo(int)` returns 3. Normal const-to-non-const conversion behaviour applies: if you call `foo(int, int)` it will return 5: a non-const reference will invoke the const method if no non-const method is defined. Which leads to the following behaviour:</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;``` Cpp</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;folly::Function&lt;int(int, int)&gt; uf5nc = Foo();</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;// uf5nc() returns 5</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;```</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;If you are wondering if the introduction of const function types means that you have to change lots of normal function types to const function types if you want to use `folly::Function`: not really, or at least not as much as you might think. There are only two reasons to use a `folly::Function` with a const function type:</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;* a callable object defines both const and non-const `operator()` and you explicitly want to select the const one</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;* you need to invoke a `folly::Function` from a const context (i.e. you only have a const reference to the `folly::Function`)</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;In practice, you will not need the const variant very often. Adding const to a function type adds a restriction for the callable: it must not change its inner state when invoked. If you don’t care whether it does or not, don’t worry about const!</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;A `folly::Function&lt;R(Args...) const&gt;` can be converted into a `folly::Function&lt;R(Args...)&gt;`: either way the stored callable will not change its inner state when invoked. The former type expresses and guarantees that, the latter does not. When you get rid of the const, the selected function stays the same:</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;``` Cpp</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;folly::Function&lt;int(int)&gt; uf4nc = std::move(uf4);</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;// uf4nc() returns 4, not 3!</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;```</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;If you want to go the other way, you are talking about a (potentially dangerous) const cast: a callable that may or may not change its inner state is declared as one that guarantees not to do that. Proceed at your own risk! This conversion does not happen implicitly, though:</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;``` Cpp</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;folly::Function&lt;int() const&gt; uf1c = folly::constCastFunction(std::move(uf1));</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;// uf1c() returns 1</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;```</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;Admittedly, seeing const function types as template parameters is unfamiliar. As far as I am aware it happens nowhere in the standard library. But it is the most consistent way to deal with the issue of const-correctness here. Const qualifiers are part of a function type, as a matter of fact. If you require a const-qualified function to be wrapped in a `folly::Function`, just declare it as that! More often than not you will find that you do not need the const qualifier. While writing the `folly::Function` implementation, a good set of unit tests had existed before the const function types got introduced. Not a single of those unit tests had to be changed: they all compiled and passed after the introduction of const function types. Obviously new ones were added to test the const-correctness. But in your day-to-day use of `folly::Function` you won’t have to worry about const very often.</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="Function_8md.html">Function.md</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
