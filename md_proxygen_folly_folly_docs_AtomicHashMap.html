<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: `folly/AtomicHashmap.h`</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_proxygen_folly_folly_docs_AtomicHashMap.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">`folly/AtomicHashmap.h` </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><code>folly/AtomicHashmap.h</code> introduces a synchronized UnorderedAssociativeContainer implementation designed for extreme performance in heavily multithreaded environments (about 2-5x faster than tbb::concurrent_hash_map) and good memory usage properties. Find and iteration are wait-free, insert has key-level lock granularity, there is minimal memory overhead, and permanent 32-bit ids can be used to reference each element.</p>
<h3>Limitations</h3>
<hr/>
<p>Although it can provide extreme performance, AtomicHashmap has some unique limitations as well.</p>
<ul>
<li>The space for erased elements cannot be reclaimed (they are tombstoned forever) so it's generally not a good idea to use this if you're erasing things a lot.</li>
<li>Only supports 32 or 64 bit keys - this is because they must be atomically compare-and-swap'ed.</li>
<li>Growth beyond initialization reduces performance - if you don't know the approximate number of elements you'll be inserting into the map, you probably shouldn't use this class.</li>
<li>Must manage synchronization externally in order to modify values in the map after insertion. Lock pools are a common way to do this, or you may consider using <code><a class="el" href="classfolly_1_1PackedSyncPtr.html">folly::PackedSyncPtr</a>&lt;T&gt;</code> as your <code>ValueT</code>.</li>
<li>Must define special reserved key values for empty, erased, and locked elements.</li>
</ul>
<p>For a complete list of limitations and departures from the UnorderedAssociativeContainer concept, see <code>folly/AtomicHashMap.h</code></p>
<h3>Unique Features</h3>
<hr/>
<ul>
<li><code>value_type</code> references remain valid as long as the map itself. Note this is not true for most other probing hash maps which will move elements when rehashing, which is necessary for them to grow. AtomicHashMap grows by chaining additional slabs, so elements never need to be moved.</li>
<li>Unique 32-bit ids can be used to reference elements in the map via <code>iterator::getIndex()</code>. This can be helpful to save memory in the rest of the application by replacing 64-bit pointers or keys.</li>
<li>Iterators are never invalidated. This means you can iterate through the map while simultaneously inserting and erasing. This is particularly useful for non-blocking map serialization.</li>
</ul>
<h3>Usage</h3>
<hr/>
<p>Usage is similar to most maps, although note the conspicuous lack of operator[] which encourages non thread-safe access patterns.</p>
<p>Below is a synchronized key counter implementation that allows the counter values to be incremented in parallel with serializing all the values to a string.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="classCounters.html">Counters</a> {</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  AtomicHashMap&lt;int64_t,int64_t&gt; <a class="code" href="classCounters.html#ab96e948e8e466a97fe10511f741158ea">ahm</a>;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">explicit</span> <a class="code" href="classCounters.html#a4d0d838b570a884eb532cfd6e2ec7616">Counters</a>(<span class="keywordtype">size_t</span> numCounters) : ahm(numCounters) {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classCounters.html#a7c66b01110eaa9fcdd67be429cbe74eb">increment</a>(<a class="code" href="ConstexprMathBenchmark_8cpp.html#a21214d6ef664ff09b89c1fd75fe0a042">int64_t</a> obj_id) {</div><div class="line">    <span class="keyword">auto</span> ret = ahm.insert(make_pair(obj_id, 1));</div><div class="line">    <span class="keywordflow">if</span> (!ret.second) {</div><div class="line">      <span class="comment">// obj_id already exists, increment</span></div><div class="line">      NoBarrier_AtomicIncrement(&amp;ret.first-&gt;second, 1);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="ConstexprMathBenchmark_8cpp.html#a21214d6ef664ff09b89c1fd75fe0a042">int64_t</a> <a class="code" href="classCounters.html#a90ef1c5384719bac864010aac93e4d68">getValue</a>(<a class="code" href="ConstexprMathBenchmark_8cpp.html#a21214d6ef664ff09b89c1fd75fe0a042">int64_t</a> obj_id) {</div><div class="line">    <span class="keyword">auto</span> ret = ahm.find(obj_id);</div><div class="line">    <span class="keywordflow">return</span> ret != ahm.end() ? ret-&gt;second : 0;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Serialize the counters without blocking increments</span></div><div class="line">  <span class="keywordtype">string</span> <a class="code" href="classCounters.html#a7918678ac3a3d15f9f0224fbf4db7292">toString</a>() {</div><div class="line">    <span class="keywordtype">string</span> ret = <span class="stringliteral">&quot;{\n&quot;</span>;</div><div class="line">    ret.reserve(ahm.size() * 32);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : ahm) {</div><div class="line">      ret += folly::to&lt;string&gt;(</div><div class="line">        <span class="stringliteral">&quot;  [&quot;</span>, e.first, <span class="stringliteral">&quot;:&quot;</span>, NoBarrier_Load(&amp;e.second), <span class="stringliteral">&quot;]\n&quot;</span>);</div><div class="line">    }</div><div class="line">    ret += <span class="stringliteral">&quot;}\n&quot;</span>;</div><div class="line">    <span class="keywordflow">return</span> ret;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><h3>Implementation</h3>
<hr/>
<p>AtomicHashMap is a composition of AtomicHashArray submaps, which implement the meat of the functionality. Only one AHA is created on initialization, and additional submaps are appended if the first one gets full. If the AHM grows, there will be multiple submaps that must be probed in series to find a given key. The more growth, the more submaps will be chained, and the slower it will get. If the initial size estimate is good, only one submap will ever be created and performance will be optimal.</p>
<p>AtomicHashArray is a fixed-size probing hash map (also referred to as an open addressed hash map) where hash collisions are resolved by checking subsequent elements. This means that they can be allocated in slabs as arrays of value_type elements, have excellent cache performance, and have no memory overhead from storing pointers.</p>
<p>The algorithm is simple - when inserting, the key is hash-mod'ed to an offset, and that element-key is atomically compare-and-swap'ed with the locked key value. If successful, the value is written and the element-key is unlocked by setting it to the input key value. If the compare fails, the next element is tried until success or the map is full.</p>
<p>Finds are even simpler. The key is hash-mod'ed to an offset, and the element-key is examined. If it is the same as the input key, the reference is returned, if it's the empty key, failure is returned, otherwise the next key is tried. This can be done wait-free without any atomic instructions because the elements are always in a valid state.</p>
<p>Erase is done by finding the key, then compare-and-swap'ing the element-key with the reserved erased key value. If the swap succeeds, return success, otherwise return failure (the element was erased by a competing thread). If the key does not exist, return failure. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
