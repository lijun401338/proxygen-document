<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: proxygen/folly/folly/experimental/pushmi/examples/readme.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('readme_8md.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">proxygen/folly/folly/experimental/pushmi/examples/readme.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="readme_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;# things I learned from std::for_each and std::reduce</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;I wrote an operator called `bulk()` and implemented for_each and reduce in terms of it. I departed from the `bulk_execute()` signature and tried to model the reduce signature on my `bulk` operator. I am not satisfied with the result and would need to invest more to get an abstraction for bulk that I was confident was minimal and efficient.</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;# Background </div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;## bulk_execute</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;The `bulk_execute()` function is intended to be an abstraction that allows efficient implementation of the parallel std algorithms on both CPU and GPU executors.</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;```cpp</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;template&lt;class Function, class SharedFactory&gt;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;void bulk_execute(Function&amp;&amp; f, size_t n, SharedFactory&amp;&amp; sf) const;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;```</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;A sequential implementation might look like:</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;```cpp</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;template&lt;class Function, class SharedFactory&gt;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;void bulk_execute(Function&amp;&amp; f, size_t n, SharedFactory&amp;&amp; sf)</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;{</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;  auto state = sf();</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  for(size_t idx = 0; idx &lt; n; ++idx) {</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;      f(state, idx);</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  }</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;}</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;```</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;The `Function f` already appears to be similar to the accumulate function passed to reduce. It takes the shared state and the index indicating the current value. The SharedFactory is very similar to the initialValue parameter to reduce. The Shape parameter is very similar to the Range parameter to reduce. These similarities motivated me to modify the signature to more explicitly match the reduce pattern.</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;## bulk operator</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;```cpp</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;template&lt;class F, class ShapeBegin, class ShapeEnd, class Target, class IF, class RS&gt;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;auto bulk(</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    F&amp;&amp; func,</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    ShapeBegin sb,</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    ShapeEnd se,</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    Target&amp;&amp; driver,</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    IF&amp;&amp; initFunc,</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    RS&amp;&amp; selector);</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;```</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;The `bulk` function packages the parameters and returns an adapter function. </div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;&gt; A Sender is an object with a `submit()` method</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;&gt; An Adapter is a function that takes a Sender and returns a Sender. Adapters are used for composition.</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;When called, the Adapter from `bulk()` will package the Adapter parameter with the original parameters and return a Sender. </div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;&gt; A Receiver is an object that has methods like `value()`, `error()` and `done()`. A Receiver is like a Promise.</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;The `submit()` method takes a Receiver. When called, the Sender from the bulk Adapter will create a Receiver with the original parameters to `bulk()` and the Receiver parameter. This new Receiver will be passed to `submit()` on the Sender that the bulk Adapter stored in this bulk Sender.</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;When called, the `value()` method on the bulk Receiver will pass all the packaged parameters to the Target.</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;&gt; A Target is a function that orchestrates the bulk operation using the parameters. There would be different Target implementations for device, sequential, concurrent execution patterns.</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;A Target implementation might look like:</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;```cpp</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;template&lt;class IF, class RS, class Input, class F, class ShapeBegin, class ShapeEnd, class Out&gt;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;void inline_driver(</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    IF init,</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    RS selector,</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    Input input,</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    F&amp;&amp; func,</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    ShapeBegin sb,</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    ShapeEnd se,</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    Out out) {</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    try {</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        auto acc = init(input);</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        for (decltype(sb) idx{sb}; idx != se; ++idx){</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;            func(acc, idx);</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        }</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        auto result = selector(std::move(acc));</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        mi::set_value(out, std::move(result));</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    } catch(...) {</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        mi::set_error(out, std::current_exception());</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    }</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    };</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;```</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;&gt; ways to improve bulk: </div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;&gt;  - merge ShapeBegin and ShapeEnd into a Range.</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;&gt;  - pass out to selector so that it can deliver an error or a success.</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;&gt;  - initFunc multiple times to have context local state that does not need locking or CAS loop. </div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;&gt;  - compose the driver implementations from operators rather than each having a bespoke implementation</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;# for_each</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;implementing for_each was straight-forward with the interface.</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;```cpp</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;template&lt;class ExecutionPolicy, class RandomAccessIterator, class Function&gt;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;void for_each(</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  ExecutionPolicy&amp;&amp; policy, </div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  RandomAccessIterator begin, </div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  RandomAccessIterator end, </div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;  Function f)</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;{</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;  operators::just(0) | </div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    operators::bulk(</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;      [f](auto&amp; acc, auto cursor){ f(*cursor); }, </div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;      begin,</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;      end, </div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;      policy, </div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;      [](auto&amp;&amp; args){ return args; }, </div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;      [](auto&amp;&amp; acc){ return 0; }) |</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    operators::blocking_submit();</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;}</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;```</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;The oddity is that bulk is expecting a shared state value and a value as input and a value result. Since for_each does not have shared state, this is overhead that becomes obvious and disturbing when looking at the naive concurrent driver in the code (there is a CAS loop around the call to the state update function even though the state is not updated here).</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;# reduce </div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;implementing reduce took more effort and some of the code in the drivers and parameters to the driver were modified to get reduce working.</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;```cpp</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;template&lt;class ExecutionPolicy, class ForwardIt, class T, class BinaryOp&gt;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;T reduce(</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  ExecutionPolicy&amp;&amp; policy,</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;  ForwardIt begin, </div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  ForwardIt end, </div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;  T init, </div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  BinaryOp binary_op){</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    return operators::just(std::move(init)) | </div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;      operators::bulk(</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        [binary_op](auto&amp; acc, auto cursor){ acc = binary_op(acc, *cursor); }, </div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        begin,</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;        end, </div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;        policy, </div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        [](auto&amp;&amp; args){ return args; }, </div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;        [](auto&amp;&amp; acc){ return acc; }) |</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;      operators::get&lt;T&gt;;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    }</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;```</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;Based on examples that I have been shown, the existing bulk_execute would expect the bulk_execute caller to provide the synchronization for the shared state. In the case of reduce it is important to synchronize when the execution is concurrent and equally important not to synchronize when it is not concurrent. Using if constexpr to implement reduce with and without sync in the parameters to bulk would add a lot of unsafe bespoke work and complication into every algorithm using bulk. In this bulk design the driver owns synchronization instead. </div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;&gt; NOTE - in any case, if a high-level async library design requires manual lock or lock-free primitive usage for correct behavior, then the design needs to be changed.</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;I am dissatisfied with the expected perf results from the naive concurrent driver (expectation from looking at the code, will need to measure). For instance, here is the CAS loop over the accumulator function from the naive concurrent driver:</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;```cpp</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;  // this indicates to me that bulk is not the right abstraction</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;  auto old = std::get&lt;4&gt;(*shared_state).load();</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;  auto step = old;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;  do {</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    step = old;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    // func(accumulation, idx)</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    std::get&lt;3&gt;(*shared_state)(step, idx);</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;  } while(!std::get&lt;4&gt;(*shared_state).compare_exchange_strong(old, step));</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;```</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;This is due to having a single shared_state being shared concurrently. I would much prefer having multiple states that are never used concurrently and then composing them all into one final result.</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;&gt; creating factor * hardware_concurrency() number of states would allow user controlled granularity (factor) for work stealing. each state would only be used from one `hardware_concurrency` context and thus would have no synchronization when it was modified.</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;# static_thread_pool</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;this bonus section is to mention the bulk_execute implementation in the static_thread_pool. The static thread pool is a cool piece of tech. in the bulk_execute method I had two observations.</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160; 1. every index in the range from 0-N is allocated as a task node</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160; 2. this list of nodes is built locally and then inserted in one lock operation</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;For #1, I expect that there is a desire to reduce the number of task nodes allocated in bulk.</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;There are multiple ways to achieve #2 on P1055.</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;one way to achieve this is to add a type that is an executor but just accumulates a local queue. usage would be similar to..</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;```cpp</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;auto pool = thread_pool();</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;auto e = pool.bulk_executor();</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;my_bulk_generator(e, . . .); // lots of calls to submit</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;pool.bulk_enqueue(e);</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;```</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;# ExecutionPolicy</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;In building these algorithms I observed that the parallel std algorithms do not really depend on executor, they depend on ExecutionPolicy. GPU and CPU can have different execution policies and it does not affect the implementation or expression of the parallel algorithms (rather than passing an executor around pass an ExecutionPolicy).</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="readme_8md.html">readme.md</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
