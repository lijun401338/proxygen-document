<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: folly::traits_detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacefolly_1_1traits__detail.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">folly::traits_detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1traits__detail_1_1has__IsRelocatable____folly__traits__impl____.html">has_IsRelocatable__folly_traits_impl__</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1traits__detail_1_1has__IsZeroInitializable____folly__traits__impl____.html">has_IsZeroInitializable__folly_traits_impl__</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1traits__detail_1_1has__true__IsRelocatable.html">has_true_IsRelocatable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1traits__detail_1_1has__true__IsZeroInitializable.html">has_true_IsZeroInitializable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1traits__detail_1_1IsRelocatable__is__true.html">IsRelocatable_is_true</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1traits__detail_1_1IsZeroInitializable__is__true.html">IsZeroInitializable_is_true</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1traits__detail_1_1type__t__.html">type_t_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac09574d67ff9252e7e98b2a3cb1d5969"><td class="memTemplParams" colspan="2">template&lt;typename TTheClass_ &gt; </td></tr>
<tr class="memitem:ac09574d67ff9252e7e98b2a3cb1d5969"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefolly_1_1traits__detail.html#ac09574d67ff9252e7e98b2a3cb1d5969">has_IsRelocatable</a> = typename std::conditional&lt; <a class="el" href="structfolly_1_1traits__detail_1_1has__IsRelocatable____folly__traits__impl____.html">has_IsRelocatable__folly_traits_impl__</a>&lt; TTheClass_ &gt;::template <a class="el" href="FlatCombiningPriorityQueueTest_8cpp.html#a6229bdba5366994108a0f0bf5fc0250c">test</a>&lt; TTheClass_ &gt;(<a class="el" href="http__parser__cpp_8cpp.html#ab979d9d4b4923f7c54d6caa6e1a61936">nullptr</a>), std::true_type, std::false_type &gt;::<a class="el" href="ClientProtocol_8cpp.html#afb6f25e8ca4d7adb175ad413430bbb90">type</a></td></tr>
<tr class="separator:ac09574d67ff9252e7e98b2a3cb1d5969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd7eab79321fee6638c8afe4cd10c01"><td class="memTemplParams" colspan="2">template&lt;typename TTheClass_ &gt; </td></tr>
<tr class="memitem:a1cd7eab79321fee6638c8afe4cd10c01"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacefolly_1_1traits__detail.html#a1cd7eab79321fee6638c8afe4cd10c01">has_IsZeroInitializable</a> = typename std::conditional&lt; <a class="el" href="structfolly_1_1traits__detail_1_1has__IsZeroInitializable____folly__traits__impl____.html">has_IsZeroInitializable__folly_traits_impl__</a>&lt; TTheClass_ &gt;::template <a class="el" href="FlatCombiningPriorityQueueTest_8cpp.html#a6229bdba5366994108a0f0bf5fc0250c">test</a>&lt; TTheClass_ &gt;(<a class="el" href="http__parser__cpp_8cpp.html#ab979d9d4b4923f7c54d6caa6e1a61936">nullptr</a>), std::true_type, std::false_type &gt;::<a class="el" href="ClientProtocol_8cpp.html#afb6f25e8ca4d7adb175ad413430bbb90">type</a></td></tr>
<tr class="separator:a1cd7eab79321fee6638c8afe4cd10c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>type_t</p>
<p><a class="el" href="structA.html">A</a> type alias for the first template type argument. <code>type_t</code> is useful for controlling class-template and function-template partial specialization.</p>
<p>Example:</p>
<p>template &lt;typename value&gt;=""&gt; class Container { public: template &lt;typename... Args&gt; Container( type_t&lt;in_place_t, decltype(Value(std::declval&lt;Args&gt;()...))&gt;, Args&amp;&amp;...); };</p>
<p>void_t</p>
<p><a class="el" href="structA.html">A</a> type alias for <code>void</code>. <code>void_t</code> is useful for controling class-template and function-template partial specialization.</p>
<p>Example:</p>
<p>// has_value_type&lt;T&gt;::value is true if T has a nested type <code>value_type</code> template &lt;class T, class = void&gt; struct has_value_type : std::false_type {};</p>
<p>template &lt;class t&gt;=""&gt; struct has_value_type&lt;T, <a class="el" href="namespacefolly.html#ac6c0097f88fb7d6ae7aee71249b2ece4">folly::void_t&lt;typename T::value_type&gt;</a>&gt; : std::true_type {}; There is a bug in libstdc++, libc++, and MSVC's STL that causes it to ignore unused template parameter arguments in template aliases and does not cause substitution failures. This defect has been recorded here: <a href="http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1558">http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1558</a>.</p>
<p>This causes the implementation of std::void_t to be buggy, as it is likely defined as something like the following:</p>
<p>template &lt;typename...&gt; using void_t = void;</p>
<p>This causes the compiler to ignore all the template arguments and does not help when one wants to cause substitution failures. Rather declarations which have void_t in orthogonal specializations are treated as the same. For example, assuming the possible <code>T</code> types are only allowed to have either the alias <code>one</code> or <code>two</code> and never both or none:</p>
<p>template &lt;typename T, typename std::void_t&lt;std::decay_t&lt;T&gt;::one&gt;* = nullptr&gt; void <a class="el" href="structfoo.html">foo(T&amp;&amp;)</a> {} template &lt;typename T, typename std::void_t&lt;std::decay_t&lt;T&gt;::two&gt;* = nullptr&gt; void <a class="el" href="structfoo.html">foo(T&amp;&amp;)</a> {}</p>
<p>The second <a class="el" href="namespacefolly.html#a0f40fd6f0c31c541abc13d1092e1201b">foo()</a> will be a redefinition because it conflicts with the first one; void_t does not cause substitution failures - the template types are just ignored.</p>
<p>IsRelocatable&lt;T&gt;::value describes the ability of moving around memory a value of type T by using memcpy (as opposed to the conservative approach of calling the copy constructor and then destroying the old temporary. Essentially for a relocatable type, the following two sequences of code should be semantically equivalent:</p>
<p>void move1(T * from, T * to) { new(to) <a class="el" href="http__parser__cpp_8cpp.html#ad24d0de3f597ca60dd95c4bc59c2ff73">T(from)</a>; (*from).~T(); }</p>
<p>void move2(T * from, T * to) { memcpy(to, from, sizeof(T)); }</p>
<p>Most C++ types are relocatable; the ones that aren't would include internal pointers or (very rarely) would need to update remote pointers to pointers tracking them. All C++ primitive types and type constructors are relocatable.</p>
<p>This property can be used in a variety of optimizations. Currently fbvector uses this property intensively.</p>
<p>The default conservatively assumes the type is not relocatable. Several specializations are defined for known types. You may want to add your own specializations. Do so in namespace folly and make sure you keep the specialization of IsRelocatable&lt;SomeStruct&gt; in the same header as SomeStruct.</p>
<p>You may also declare a type to be relocatable by including <code>typedef std::true_type <a class="el" href="structfolly_1_1IsRelocatable.html">IsRelocatable</a>;</code> in the class header.</p>
<p>It may be unset in a base class by overriding the typedef to false_type. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ac09574d67ff9252e7e98b2a3cb1d5969"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTheClass_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacefolly_1_1traits__detail.html#ac09574d67ff9252e7e98b2a3cb1d5969">folly::traits_detail::has_IsRelocatable</a> = typedef typename std::conditional&lt; <a class="el" href="structfolly_1_1traits__detail_1_1has__IsRelocatable____folly__traits__impl____.html">has_IsRelocatable__folly_traits_impl__</a>&lt;TTheClass_&gt;::template <a class="el" href="FlatCombiningPriorityQueueTest_8cpp.html#a6229bdba5366994108a0f0bf5fc0250c">test</a>&lt;TTheClass_&gt;( <a class="el" href="http__parser__cpp_8cpp.html#ab979d9d4b4923f7c54d6caa6e1a61936">nullptr</a>), std::true_type, std::false_type&gt;::<a class="el" href="ClientProtocol_8cpp.html#afb6f25e8ca4d7adb175ad413430bbb90">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Traits_8h_source.html#l00370">370</a> of file <a class="el" href="Traits_8h_source.html">Traits.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1cd7eab79321fee6638c8afe4cd10c01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTheClass_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacefolly_1_1traits__detail.html#a1cd7eab79321fee6638c8afe4cd10c01">folly::traits_detail::has_IsZeroInitializable</a> = typedef typename std::conditional&lt; <a class="el" href="structfolly_1_1traits__detail_1_1has__IsZeroInitializable____folly__traits__impl____.html">has_IsZeroInitializable__folly_traits_impl__</a>&lt;TTheClass_&gt;::template <a class="el" href="FlatCombiningPriorityQueueTest_8cpp.html#a6229bdba5366994108a0f0bf5fc0250c">test</a>&lt;TTheClass_&gt;( <a class="el" href="http__parser__cpp_8cpp.html#ab979d9d4b4923f7c54d6caa6e1a61936">nullptr</a>), std::true_type, std::false_type&gt;::<a class="el" href="ClientProtocol_8cpp.html#afb6f25e8ca4d7adb175ad413430bbb90">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Traits_8h_source.html#l00371">371</a> of file <a class="el" href="Traits_8h_source.html">Traits.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefolly.html">folly</a></li><li class="navelem"><a class="el" href="namespacefolly_1_1traits__detail.html">traits_detail</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
