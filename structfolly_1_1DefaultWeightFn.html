<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: folly::DefaultWeightFn&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structfolly_1_1DefaultWeightFn.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structfolly_1_1DefaultWeightFn-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">folly::DefaultWeightFn&lt; T &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="DynamicBoundedQueue_8h_source.html">DynamicBoundedQueue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a01fb431a4a95a0b772a9df671a6be8c9"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a01fb431a4a95a0b772a9df671a6be8c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a5dc34568a989dd90728a4ed499cd9fab">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structfolly_1_1DefaultWeightFn.html#a01fb431a4a95a0b772a9df671a6be8c9">operator()</a> (Arg &amp;&amp;) const noexcept</td></tr>
<tr class="separator:a01fb431a4a95a0b772a9df671a6be8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct folly::DefaultWeightFn&lt; T &gt;</h3>

<p><a class="el" href="classfolly_1_1DynamicBoundedQueue.html">DynamicBoundedQueue</a> supports:</p><ul>
<li>Dynamic memory usage that grows and shrink in proportion to the number of elements in the queue.</li>
<li>Adjustable capacity that helps throttle pathological cases of producer-consumer imbalance that may lead to excessive memory usage.</li>
<li>The adjustable capacity can also help prevent deadlock by allowing users to temporarily increase capacity substantially to guarantee accommodating producer requests that cannot wait.</li>
<li>SPSC, SPMC, MPSC, <a class="el" href="classMPMC.html">MPMC</a> variants.</li>
<li>Blocking and spinning-only variants.</li>
<li>Inter-operable non-waiting, timed until, timed for, and waiting variants of producer and consumer operations.</li>
<li><a class="el" href="classfolly_1_1Optional.html">Optional</a> variable element weights.</li>
</ul>
<p>Element Weights</p><ul>
<li><a class="el" href="classQueue.html">Queue</a> elements may have variable weights (calculated using a template parameter) that are by default 1.</li>
<li>Element weights count towards the queue's capacity.</li>
<li>Elements weights are not priorities and do not affect element order. Queues with variable element weights follow FIFO order, the same as default queues.</li>
</ul>
<p>When to use <a class="el" href="classfolly_1_1DynamicBoundedQueue.html">DynamicBoundedQueue</a>:</p><ul>
<li>If a small maximum capacity may lead to deadlock or performance degradation under bursty patterns and a larger capacity is sufficient.</li>
<li>If the typical queue size is expected to be much lower than the maximum capacity</li>
<li>If an unbounded queue is susceptible to growing too much.</li>
<li>If support for variable element weights is needed.</li>
</ul>
<p>When not to use <a class="el" href="classfolly_1_1DynamicBoundedQueue.html">DynamicBoundedQueue</a>?</p><ul>
<li>If dynamic memory allocation is unacceptable or if the maximum capacity needs to be small, then use fixed-size <a class="el" href="classfolly_1_1MPMCQueue.html">MPMCQueue</a> or (if non-blocking SPSC) <a class="el" href="structfolly_1_1ProducerConsumerQueue.html">ProducerConsumerQueue</a>.</li>
<li>If there is no risk of the queue growing too much, then use <a class="el" href="classfolly_1_1UnboundedQueue.html">UnboundedQueue</a>.</li>
</ul>
<p>Setting capacity</p><ul>
<li>The general rule is to set the capacity as high as acceptable. The queue performs best when it is not near full capacity.</li>
<li>The implementation may allow extra slack in capacity (~10%) for amortizing some costly steps. Therefore, precise capacity is not guaranteed and cannot be relied on for synchronization; i.e., this queue cannot be used as a semaphore.</li>
</ul>
<p>Performance expectations:</p><ul>
<li>As long as the queue size is below capacity in the common case, performance is comparable to <a class="el" href="classfolly_1_1MPMCQueue.html">MPMCQueue</a> and better in cases of higher producer demand.</li>
<li>Performance degrades gracefully at full capacity.</li>
<li>It is recommended to measure performance with different variants when applicable, e.g., DMPMC vs DMPSC. Depending on the use case, sometimes the variant with the higher sequential overhead may yield better results due to, for example, more favorable producer-consumer balance or favorable timing for avoiding costly blocking.</li>
<li>See <a class="el" href="DynamicBoundedQueueTest_8cpp.html">DynamicBoundedQueueTest.cpp</a> for some benchmark results.</li>
</ul>
<p>Template parameters:</p><ul>
<li>T: element type</li>
<li>SingleProducer: true if there can be only one producer at a time.</li>
<li>SingleConsumer: true if there can be only one consumer at a time.</li>
<li>MayBlock: true if producers or consumers may block.</li>
<li>LgSegmentSize (default 8): Log base 2 of number of elements per <a class="el" href="classfolly_1_1UnboundedQueue.html">UnboundedQueue</a> segment.</li>
<li>LgAlign (default 7): Log base 2 of alignment directive; can be used to balance scalability (avoidance of false sharing) with memory efficiency.</li>
<li>WeightFn (DefaultWeightFn&lt;T&gt;): <a class="el" href="structA.html">A</a> customizable weight computing type for computing the weights of elements. The default weight is 1.</li>
</ul>
<p>Template Aliases: DSPSCQueue&lt;T, MayBlock, LgSegmentSize, LgAlign&gt; DMPSCQueue&lt;T, MayBlock, LgSegmentSize, LgAlign&gt; DSPMCQueue&lt;T, MayBlock, LgSegmentSize, LgAlign&gt; DMPMCQueue&lt;T, MayBlock, LgSegmentSize, LgAlign&gt;</p>
<p>Functions: Constructor Takes a capacity value as an argument.</p>
<p>Producer functions: void enqueue(const T&amp;); void enqueue(T&amp;&amp;); Adds an element to the end of the queue. Waits until capacity is available if necessary. bool try_enqueue(const T&amp;); bool try_enqueue(T&amp;&amp;); Tries to add an element to the end of the queue if capacity allows it. Returns true if successful. Otherwise Returns false. bool try_enqueue_until(const T&amp;, time_point&amp; deadline); bool try_enqueue_until(T&amp;&amp;, time_point&amp; deadline); Tries to add an element to the end of the queue if capacity allows it until the specified deadline. Returns true if successful, otherwise false. bool try_enqueue_for(const T&amp;, duration&amp;); bool try_enqueue_for(T&amp;&amp;, duration&amp;); Tries to add an element to the end of the queue if capacity allows until the expiration of the specified duration. Returns true if successful, otherwise false.</p>
<p>Consumer functions: void dequeue(T&amp;); Extracts an element from the front of the queue. Waits until an element is available if necessary. bool try_dequeue(T&amp;); Tries to extracts an element from the front of the queue if available. Returns true if successful, otherwise false. bool try_dequeue_until(T&amp;, time_point&amp; deadline); Tries to extracts an element from the front of the queue if available until the specified daedline. Returns true if successful. Otherwise Returns false. bool try_dequeue_for(T&amp;, duration&amp;); Tries to extracts an element from the front of the queue if available until the expiration of the specified duration. Returns true if successful. Otherwise Returns false.</p>
<p>Secondary functions: void reset_capacity(size_t capacity); Changes the capacity of the queue. Does not affect the current contents of the queue. Guaranteed only to affect subsequent enqueue operations. May or may not affect concurrent operations. Capacity must be at least 1000. Weight weight(); Returns an estimate of the total weight of the elements in the queue. size_t <a class="el" href="namespacefolly.html#a0606ba855bcb96a1673880aa3b404993">size()</a>; Returns an estimate of the total number of elements. bool <a class="el" href="namespacefolly.html#a689e45e870f8267348e24cea50d6877f">empty()</a>; Returns true only if the queue was empty during the call. Note: weight(), <a class="el" href="namespacefolly.html#a0606ba855bcb96a1673880aa3b404993">size()</a>, and <a class="el" href="namespacefolly.html#a689e45e870f8267348e24cea50d6877f">empty()</a> are guaranteed to be accurate only if there are no concurrent changes to the queue.</p>
<p>Usage example with default weight: </p><div class="fragment"><div class="line"><span class="comment">/* DMPSC, doesn&#39;t block, 1024 int elements per segment */</span></div><div class="line">DMPSCQueue&lt;int, false, 10&gt; q(100000);</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#ae9244bfbda562e8b798789b001993fa5">ASSERT_TRUE</a>(q.empty());</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#a1a6db8b1338ee7040329322b77779086">ASSERT_EQ</a>(q.size(), 0);</div><div class="line">q.enqueue(1));</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#ae9244bfbda562e8b798789b001993fa5">ASSERT_TRUE</a>(q.try_enqueue(2));</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#ae9244bfbda562e8b798789b001993fa5">ASSERT_TRUE</a>(q.try_enqueue_until(3, deadline));</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#ae9244bfbda562e8b798789b001993fa5">ASSERT_TRUE</a>(q.try_enqueue(4, duration));</div><div class="line"><span class="comment">// ... enqueue more elements until capacity is full</span></div><div class="line"><span class="comment">// See above comments about imprecise capacity guarantees</span></div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#a8197fa52f3538588d20d8af4834c9003">ASSERT_FALSE</a>(q.try_enqueue(100001)); <span class="comment">// can&#39;t enqueue but can&#39;t wait</span></div><div class="line"><span class="keywordtype">size_t</span> sz = q.size();</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#af4ff5dc71479fcb374b6bc2ed195bcc4">ASSERT_GE</a>(sz, 100000);</div><div class="line">q.reset_capacity(1000000000); <span class="comment">// set huge capacity</span></div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#ae9244bfbda562e8b798789b001993fa5">ASSERT_TRUE</a>(q.try_enqueue(100001)); <span class="comment">// now enqueue succeeds</span></div><div class="line">q.reset_capacity(100000); <span class="comment">// set capacity back to 100,000</span></div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#a8197fa52f3538588d20d8af4834c9003">ASSERT_FALSE</a>(q.try_enqueue(100002));</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#a1a6db8b1338ee7040329322b77779086">ASSERT_EQ</a>(q.size(), sz + 1);</div><div class="line"><span class="keywordtype">int</span> <a class="code" href="ParallelBenchmark_8cpp.html#a62448945ba9492b4ac991254a7d267bb">v</a>;</div><div class="line">q.dequeue(v);</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#a1a6db8b1338ee7040329322b77779086">ASSERT_EQ</a>(v, 1);</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#ae9244bfbda562e8b798789b001993fa5">ASSERT_TRUE</a>(q.try_dequeue(v));</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#a1a6db8b1338ee7040329322b77779086">ASSERT_EQ</a>(v, 2);</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#ae9244bfbda562e8b798789b001993fa5">ASSERT_TRUE</a>(q.try_dequeue_until(v, deadline));</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#a1a6db8b1338ee7040329322b77779086">ASSERT_EQ</a>(v, 3);</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#ae9244bfbda562e8b798789b001993fa5">ASSERT_TRUE</a>(q.try_dequeue_for(v, duration));</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#a1a6db8b1338ee7040329322b77779086">ASSERT_EQ</a>(v, 4);</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#a1a6db8b1338ee7040329322b77779086">ASSERT_EQ</a>(q.size(), sz - 3);</div></div><!-- fragment --><p>Usage example with custom weights: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>CustomWeightFn {</div><div class="line">  <a class="code" href="ConstexprMathBenchmark_8cpp.html#a5dc34568a989dd90728a4ed499cd9fab">uint64_t</a> <a class="code" href="structfolly_1_1DefaultWeightFn.html#a01fb431a4a95a0b772a9df671a6be8c9">operator()</a>(<span class="keywordtype">int</span> <a class="code" href="String_8cpp.html#a3c8bc0bb4f045bfe78d1196cb786792c">val</a>) { <span class="keywordflow">return</span> val / 100; }</div><div class="line">};</div><div class="line">DMPMCQueue&lt;int, false, 10, CustomWeightFn&gt; q(20);</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#ae9244bfbda562e8b798789b001993fa5">ASSERT_TRUE</a>(q.empty());</div><div class="line">q.enqueue(100);</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#ae9244bfbda562e8b798789b001993fa5">ASSERT_TRUE</a>(q.try_enqueue(200));</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#ae9244bfbda562e8b798789b001993fa5">ASSERT_TRUE</a>(q.try_enqueue_until(500, <a class="code" href="TimekeeperTest_8cpp.html#a562b4baa36dcf267f35a4ba4e0aef329">now</a>() + seconds(1)));</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#a1a6db8b1338ee7040329322b77779086">ASSERT_EQ</a>(q.size(), 3);</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#a1a6db8b1338ee7040329322b77779086">ASSERT_EQ</a>(q.weight(), 8);</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#a8197fa52f3538588d20d8af4834c9003">ASSERT_FALSE</a>(q.try_enqueue_for(1700, microseconds(1)));</div><div class="line">q.reset_capacity(1000000); <span class="comment">// set capacity to 1000000 instead of 20</span></div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#ae9244bfbda562e8b798789b001993fa5">ASSERT_TRUE</a>(q.try_enqueue_for(1700, microseconds(1)));</div><div class="line">q.reset_capacity(20); <span class="comment">// set capacity to 20 again</span></div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#a8197fa52f3538588d20d8af4834c9003">ASSERT_FALSE</a>(q.try_enqueue(100));</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#a1a6db8b1338ee7040329322b77779086">ASSERT_EQ</a>(q.size(), 4);</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#a1a6db8b1338ee7040329322b77779086">ASSERT_EQ</a>(q.weight(), 25);</div><div class="line"><span class="keywordtype">int</span> <a class="code" href="ParallelBenchmark_8cpp.html#a62448945ba9492b4ac991254a7d267bb">v</a>;</div><div class="line">q.dequeue(v);</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#a1a6db8b1338ee7040329322b77779086">ASSERT_EQ</a>(v, 100);</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#ae9244bfbda562e8b798789b001993fa5">ASSERT_TRUE</a>(q.try_dequeue(v));</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#a1a6db8b1338ee7040329322b77779086">ASSERT_EQ</a>(v, 200);</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#ae9244bfbda562e8b798789b001993fa5">ASSERT_TRUE</a>(q.try_dequeue_until(v, <a class="code" href="TimekeeperTest_8cpp.html#a562b4baa36dcf267f35a4ba4e0aef329">now</a>() + seconds(1)));</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#a1a6db8b1338ee7040329322b77779086">ASSERT_EQ</a>(v, 500);</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#a1a6db8b1338ee7040329322b77779086">ASSERT_EQ</a>(q.size(), 1);</div><div class="line"><a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2include_2gtest_2gtest_8h.html#a1a6db8b1338ee7040329322b77779086">ASSERT_EQ</a>(q.weight(), 17);</div></div><!-- fragment --><p>Design:</p><ul>
<li>The implementation is on top of <a class="el" href="classfolly_1_1UnboundedQueue.html">UnboundedQueue</a>.</li>
<li>The main FIFO functionality is in <a class="el" href="classfolly_1_1UnboundedQueue.html">UnboundedQueue</a>. <a class="el" href="classfolly_1_1DynamicBoundedQueue.html">DynamicBoundedQueue</a> manages keeping the total queue weight within the specified capacity.</li>
<li>For the sake of scalability, the data structures are designed to minimize interference between producers on one side and consumers on the other.</li>
<li>Producers add to a debit variable the weight of the added element and check capacity.</li>
<li>Consumers add to a credit variable the weight of the removed element.</li>
<li>Producers, for the sake of scalability, use fetch_add to add to the debit variable and subtract if it exceeded capacity, rather than using compare_exchange to avoid overshooting.</li>
<li>Consumers, infrequently, transfer credit to a transfer variable and unblock any blocked producers. The transfer variable can be used by producers to decrease their debit when needed.</li>
<li>Note that a low capacity will trigger frequent credit transfer by consumers that may degrade performance. Capacity should not be set too low.</li>
<li>Transfer of credit by consumers is triggered when the amount of credit reaches a threshold (1/10 of capacity).</li>
<li>The waiting of consumers is handled in <a class="el" href="classfolly_1_1UnboundedQueue.html">UnboundedQueue</a>. The waiting of producers is handled in this template.</li>
<li>For a producer operation, if the difference between debit and capacity (plus some slack to account for the transfer threshold) does not accommodate the weight of the new element, it first tries to transfer credit that may have already been made available by consumers. If this is insufficient and MayBlock is true, then the producer uses a futex to block until new credit is transferred by a consumer.</li>
</ul>
<p>Memory Usage:</p><ul>
<li>Aside from three cache lines for managing capacity, the memory for queue elements is managed using <a class="el" href="classfolly_1_1UnboundedQueue.html">UnboundedQueue</a> and grows and shrinks dynamically with the number of elements.</li>
<li>The template parameter LgAlign can be used to reduce memory usage at the cost of increased chance of false sharing. </li>
</ul>

<p>Definition at line <a class="el" href="DynamicBoundedQueue_8h_source.html#l00271">271</a> of file <a class="el" href="DynamicBoundedQueue_8h_source.html">DynamicBoundedQueue.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a01fb431a4a95a0b772a9df671a6be8c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Arg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ConstexprMathBenchmark_8cpp.html#a5dc34568a989dd90728a4ed499cd9fab">uint64_t</a> <a class="el" href="structfolly_1_1DefaultWeightFn.html">folly::DefaultWeightFn</a>&lt; <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">T</a> &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="DynamicBoundedQueue_8h_source.html#l00273">273</a> of file <a class="el" href="DynamicBoundedQueue_8h_source.html">DynamicBoundedQueue.h</a>.</p>

<p>References <a class="el" href="ConcurrentHashMapTest_8cpp_source.html#l00301">Atom</a>, and <a class="el" href="namespacefolly.html#a0652a9c51b69e7a13d40ccbcb139bc55">folly::T</a>.</p>
<div class="fragment"><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;                                            {</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    <span class="keywordflow">return</span> 1;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>proxygen/folly/folly/concurrency/<a class="el" href="DynamicBoundedQueue_8h_source.html">DynamicBoundedQueue.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefolly.html">folly</a></li><li class="navelem"><a class="el" href="structfolly_1_1DefaultWeightFn.html">DefaultWeightFn</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
