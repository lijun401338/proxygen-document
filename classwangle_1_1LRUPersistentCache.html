<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: wangle::LRUPersistentCache&lt; K, V, MutexT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classwangle_1_1LRUPersistentCache.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classwangle_1_1LRUPersistentCache-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">wangle::LRUPersistentCache&lt; K, V, MutexT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for wangle::LRUPersistentCache&lt; K, V, MutexT &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classwangle_1_1LRUPersistentCache.png" usemap="#wangle::LRUPersistentCache_3C_20K_2C_20V_2C_20MutexT_20_3E_map" alt=""/>
  <map id="wangle::LRUPersistentCache_3C_20K_2C_20V_2C_20MutexT_20_3E_map" name="wangle::LRUPersistentCache&lt; K, V, MutexT &gt;_map">
<area href="classwangle_1_1PersistentCache.html" alt="wangle::PersistentCache&lt; K, V &gt;" shape="rect" coords="0,0,415,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a18bcb670ff3e3d3e344a3e74ee420a82"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#a18bcb670ff3e3d3e344a3e74ee420a82">Ptr</a> = std::shared_ptr&lt; <a class="el" href="classwangle_1_1LRUPersistentCache.html">LRUPersistentCache</a>&lt; K, V, MutexT &gt;&gt;</td></tr>
<tr class="separator:a18bcb670ff3e3d3e344a3e74ee420a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9757b68f199570adf0be47bd22505e8f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#a9757b68f199570adf0be47bd22505e8f">LRUPersistentCache</a> (std::size_t cacheCapacity, std::chrono::milliseconds syncInterval=<a class="el" href="namespacewangle_1_1client_1_1persistence.html#a9a4ecd2b5d1866ccb2bc23b1113f921b">client::persistence::DEFAULT_CACHE_SYNC_INTERVAL</a>, int nSyncRetries=<a class="el" href="namespacewangle_1_1client_1_1persistence.html#a221c3cb2f9657aec7b03222846a89eeb">client::persistence::DEFAULT_CACHE_SYNC_RETRIES</a>, std::unique_ptr&lt; <a class="el" href="classwangle_1_1CachePersistence.html">CachePersistence</a>&lt; K, V &gt;&gt; persistence=<a class="el" href="http__parser__cpp_8cpp.html#ab979d9d4b4923f7c54d6caa6e1a61936">nullptr</a>)</td></tr>
<tr class="separator:a9757b68f199570adf0be47bd22505e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c0da58386564fc6e1620da0820a5ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#ab9c0da58386564fc6e1620da0820a5ad">LRUPersistentCache</a> (std::shared_ptr&lt; <a class="el" href="classfolly_1_1Executor.html">folly::Executor</a> &gt; executor, std::size_t cacheCapacity, std::chrono::milliseconds syncInterval, int nSyncRetries, std::unique_ptr&lt; <a class="el" href="classwangle_1_1CachePersistence.html">CachePersistence</a>&lt; K, V &gt;&gt; persistence)</td></tr>
<tr class="separator:ab9c0da58386564fc6e1620da0820a5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8f5c5941520b314e86590f82b8194a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#acc8f5c5941520b314e86590f82b8194a">~LRUPersistentCache</a> () override</td></tr>
<tr class="separator:acc8f5c5941520b314e86590f82b8194a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f216e84f0283880b67f7eaf810fc5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#aa9f216e84f0283880b67f7eaf810fc5d">hasPendingUpdates</a> ()</td></tr>
<tr class="separator:aa9f216e84f0283880b67f7eaf810fc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6121ae85b05a20620d6fc61b8c193395"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfolly_1_1Optional.html">folly::Optional</a>&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#a6121ae85b05a20620d6fc61b8c193395">get</a> (const K &amp;key) override</td></tr>
<tr class="separator:a6121ae85b05a20620d6fc61b8c193395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867bb37cbedb276407a0a02f2389c103"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#a867bb37cbedb276407a0a02f2389c103">put</a> (const K &amp;key, const V &amp;<a class="el" href="String_8cpp.html#a3c8bc0bb4f045bfe78d1196cb786792c">val</a>) override</td></tr>
<tr class="separator:a867bb37cbedb276407a0a02f2389c103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4148b75c82a5e0e9ef73eb8b290d5766"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#a4148b75c82a5e0e9ef73eb8b290d5766">remove</a> (const K &amp;key) override</td></tr>
<tr class="separator:a4148b75c82a5e0e9ef73eb8b290d5766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae571e0c624e47586ef8fa4444b7cadef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#ae571e0c624e47586ef8fa4444b7cadef">clear</a> (bool clearPersistence=false) override</td></tr>
<tr class="separator:ae571e0c624e47586ef8fa4444b7cadef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d44eea9886d7b23c0b86a95ee439e57"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#a1d44eea9886d7b23c0b86a95ee439e57">size</a> () override</td></tr>
<tr class="separator:a1d44eea9886d7b23c0b86a95ee439e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc77c568e225493d78fd476ebc51068"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#a2dc77c568e225493d78fd476ebc51068">setSyncOnDestroy</a> (bool syncOnDestroy)</td></tr>
<tr class="separator:a2dc77c568e225493d78fd476ebc51068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e8b64b7193a179409b8601a8fdb279"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#ae3e8b64b7193a179409b8601a8fdb279">setPersistence</a> (std::unique_ptr&lt; <a class="el" href="classwangle_1_1CachePersistence.html">CachePersistence</a>&lt; K, V &gt;&gt; persistence)</td></tr>
<tr class="separator:ae3e8b64b7193a179409b8601a8fdb279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classwangle_1_1PersistentCache"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classwangle_1_1PersistentCache')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classwangle_1_1PersistentCache.html">wangle::PersistentCache&lt; K, V &gt;</a></td></tr>
<tr class="memitem:afb3f3cb6dd276f9a21ed913d4174af58 inherit pub_methods_classwangle_1_1PersistentCache"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1PersistentCache.html#afb3f3cb6dd276f9a21ed913d4174af58">~PersistentCache</a> ()</td></tr>
<tr class="separator:afb3f3cb6dd276f9a21ed913d4174af58 inherit pub_methods_classwangle_1_1PersistentCache"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:adbe01633c6baa529d6e94ffd4ec934ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#adbe01633c6baa529d6e94ffd4ec934ef">setPersistenceHelper</a> (std::unique_ptr&lt; <a class="el" href="classwangle_1_1CachePersistence.html">CachePersistence</a>&lt; K, V &gt;&gt; persistence, bool syncVersion) noexcept</td></tr>
<tr class="separator:adbe01633c6baa529d6e94ffd4ec934ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d473fbc1d813268c92429662a36f82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacewangle.html#aeccf189e78de80caf7e2aa50c59d464c">CacheDataVersion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#af0d473fbc1d813268c92429662a36f82">load</a> (<a class="el" href="classwangle_1_1CachePersistence.html">CachePersistence</a>&lt; K, V &gt; &amp;persistence) noexcept</td></tr>
<tr class="separator:af0d473fbc1d813268c92429662a36f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049d8bec51d761125d5743ca3b9048f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#a049d8bec51d761125d5743ca3b9048f8">sync</a> ()</td></tr>
<tr class="separator:a049d8bec51d761125d5743ca3b9048f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf7f67e7556142f67bdd59bd49acdd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#a4cf7f67e7556142f67bdd59bd49acdd0">oneShotSync</a> ()</td></tr>
<tr class="separator:a4cf7f67e7556142f67bdd59bd49acdd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1d482dfe6a457aaf780ad7f3d28751"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#a1f1d482dfe6a457aaf780ad7f3d28751">syncNow</a> (<a class="el" href="classwangle_1_1CachePersistence.html">CachePersistence</a>&lt; K, V &gt; &amp;persistence)</td></tr>
<tr class="separator:a1f1d482dfe6a457aaf780ad7f3d28751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa08e5f576df0a31c1fb54ab9ce115a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classwangle_1_1CachePersistence.html">CachePersistence</a>&lt; K, V &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#a5fa08e5f576df0a31c1fb54ab9ce115a">getPersistence</a> ()</td></tr>
<tr class="separator:a5fa08e5f576df0a31c1fb54ab9ce115a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:af45bb4c57317db72a11ab07dc60c3fb4"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#af45bb4c57317db72a11ab07dc60c3fb4">syncThreadMain</a> (void *arg)</td></tr>
<tr class="separator:af45bb4c57317db72a11ab07dc60c3fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7c89180fae7c002ac23925ccce7b83bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwangle_1_1LRUInMemoryCache.html">LRUInMemoryCache</a>&lt; K, V, MutexT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">cache_</a></td></tr>
<tr class="separator:a7c89180fae7c002ac23925ccce7b83bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a71ae938b18705e30af27497673a56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#a06a71ae938b18705e30af27497673a56">stopSyncer_</a> {false}</td></tr>
<tr class="separator:a06a71ae938b18705e30af27497673a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43b3a33d3053cab6a7df84f752ffd4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="OpenSSLThreading_8cpp.html#a1be3f7fa26e4521098de5f1ec0f865f3">std::mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#af43b3a33d3053cab6a7df84f752ffd4f">stopSyncerMutex_</a></td></tr>
<tr class="separator:af43b3a33d3053cab6a7df84f752ffd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa405e907b62768fbb2fbc060b7a655bc"><td class="memItemLeft" align="right" valign="top">std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#aa405e907b62768fbb2fbc060b7a655bc">stopSyncerCV_</a></td></tr>
<tr class="separator:aa405e907b62768fbb2fbc060b7a655bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf611ef758be7996827c8b9544bf89d4"><td class="memItemLeft" align="right" valign="top">std::atomic_flag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#aaf611ef758be7996827c8b9544bf89d4">executorScheduled_</a> = ATOMIC_FLAG_INIT</td></tr>
<tr class="separator:aaf611ef758be7996827c8b9544bf89d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf50ee1960461284c2bbf522d6b19be1"><td class="memItemLeft" align="right" valign="top">const std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#acf50ee1960461284c2bbf522d6b19be1">syncInterval_</a></td></tr>
<tr class="separator:acf50ee1960461284c2bbf522d6b19be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af246945baba03071238b1fad94beffa6"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#af246945baba03071238b1fad94beffa6">nSyncRetries_</a> {<a class="el" href="namespacewangle_1_1client_1_1persistence.html#a221c3cb2f9657aec7b03222846a89eeb">client::persistence::DEFAULT_CACHE_SYNC_RETRIES</a>}</td></tr>
<tr class="separator:af246945baba03071238b1fad94beffa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd97e6e8ad2e5e9100b0aa6fe625f41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#a0bd97e6e8ad2e5e9100b0aa6fe625f41">nSyncTries_</a> {0}</td></tr>
<tr class="separator:a0bd97e6e8ad2e5e9100b0aa6fe625f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6045c5ff13560b2a3f3fcadb4ea641e8"><td class="memItemLeft" align="right" valign="top">std::chrono::steady_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#a6045c5ff13560b2a3f3fcadb4ea641e8">lastExecutorScheduleTime_</a></td></tr>
<tr class="separator:a6045c5ff13560b2a3f3fcadb4ea641e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8c5d1001ad1b00f1b93186aa3a4fb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#a7f8c5d1001ad1b00f1b93186aa3a4fb0">syncOnDestroy_</a> {false}</td></tr>
<tr class="separator:a7f8c5d1001ad1b00f1b93186aa3a4fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1dc6b4eab04e0f55c0832aabe02ec1"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classwangle_1_1CachePersistence.html">CachePersistence</a>&lt; K, V &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#a6b1dc6b4eab04e0f55c0832aabe02ec1">persistence_</a></td></tr>
<tr class="separator:a6b1dc6b4eab04e0f55c0832aabe02ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff313d97b5c2f1d7779775e6ff4268a8"><td class="memItemLeft" align="right" valign="top">MutexT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#aff313d97b5c2f1d7779775e6ff4268a8">persistenceLock_</a></td></tr>
<tr class="separator:aff313d97b5c2f1d7779775e6ff4268a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cdae47124ba26ac2c66eecb0c117ad"><td class="memItemLeft" align="right" valign="top">std::thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#a65cdae47124ba26ac2c66eecb0c117ad">syncer_</a></td></tr>
<tr class="separator:a65cdae47124ba26ac2c66eecb0c117ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016d852231aa66e1535cff9e0115c941"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classfolly_1_1Executor.html">folly::Executor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwangle_1_1LRUPersistentCache.html#a016d852231aa66e1535cff9e0115c941">executor_</a></td></tr>
<tr class="separator:a016d852231aa66e1535cff9e0115c941"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename K, typename V, typename MutexT = std::mutex&gt;<br />
class wangle::LRUPersistentCache&lt; K, V, MutexT &gt;</h3>

<p><a class="el" href="structA.html">A</a> <a class="el" href="classwangle_1_1PersistentCache.html">PersistentCache</a> implementation that used a <a class="el" href="classwangle_1_1CachePersistence.html">CachePersistence</a> for storage. In memory structure fronts the persistence and the cache operations happen on it. Loading from and syncing to persistence are hidden from clients. Sync to persistence happens asynchronously on a separate thread at a configurable interval. Syncs to persistence on destruction as well.</p>
<p>The in memory structure is an EvictingCacheMap which causes this class to evict entries in an LRU fashion.</p>
<p>NOTE NOTE NOTE: Although this class aims to be a cache for arbitrary, it relies heavily on <a class="el" href="namespacefolly.html#a517fee573b1d06e4b9aaec3ac59d847d">folly::toJson</a>, <a class="el" href="structfolly_1_1dynamic.html">folly::dynamic</a> and convertTo for serialization and deserialization. So It may not suit your need until true support arbitrary types is written. </p>

<p>Definition at line <a class="el" href="LRUPersistentCache_8h_source.html#l00119">119</a> of file <a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a18bcb670ff3e3d3e344a3e74ee420a82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT = std::mutex&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::<a class="el" href="classwangle_1_1LRUPersistentCache.html#a18bcb670ff3e3d3e344a3e74ee420a82">Ptr</a> =  std::shared_ptr&lt;<a class="el" href="classwangle_1_1LRUPersistentCache.html">LRUPersistentCache</a>&lt;K, V, MutexT&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="LRUPersistentCache_8h_source.html#l00124">124</a> of file <a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9757b68f199570adf0be47bd22505e8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::<a class="el" href="classwangle_1_1LRUPersistentCache.html">LRUPersistentCache</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cacheCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>syncInterval</em> = <code><a class="el" href="namespacewangle_1_1client_1_1persistence.html#a9a4ecd2b5d1866ccb2bc23b1113f921b">client::persistence::DEFAULT_CACHE_SYNC_INTERVAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSyncRetries</em> = <code><a class="el" href="namespacewangle_1_1client_1_1persistence.html#a221c3cb2f9657aec7b03222846a89eeb">client::persistence::DEFAULT_CACHE_SYNC_RETRIES</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classwangle_1_1CachePersistence.html">CachePersistence</a>&lt; K, V &gt;&gt;&#160;</td>
          <td class="paramname"><em>persistence</em> = <code><a class="el" href="http__parser__cpp_8cpp.html#ab979d9d4b4923f7c54d6caa6e1a61936">nullptr</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classwangle_1_1LRUPersistentCache.html">LRUPersistentCache</a> constructor </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cacheCapacity</td><td>max number of elements to hold in the cache. </td></tr>
    <tr><td class="paramname">syncInterval</td><td>how often to sync to the persistence (in ms). </td></tr>
    <tr><td class="paramname">nSyncRetries</td><td>how many times to retry to sync on failure.</td></tr>
  </table>
  </dd>
</dl>
<p>Loads the cache and starts of the syncer thread that periodically syncs the cache to persistence.</p>
<p>If persistence is specified, the cache is initially loaded with the contents from it. If load fails, then cache starts empty.</p>
<p>On write failures, the sync will happen again up to nSyncRetries times. Once failed nSyncRetries amount of time, then it will give up and not attempt to sync again until another update occurs.</p>
<p>On reaching capacity limit, LRU items are evicted. </p>

<p>Definition at line <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00031">31</a> of file <a class="el" href="LRUPersistentCache-inl_8h_source.html">LRUPersistentCache-inl.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    : <a class="code" href="classwangle_1_1LRUPersistentCache.html#a9757b68f199570adf0be47bd22505e8f">LRUPersistentCache</a>(</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;          <span class="keyword">nullptr</span>,</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;          cacheCapacity,</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;          syncInterval,</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;          nSyncRetries,</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;          <a class="code" href="namespacefolly_1_1gen.html#ac24ec252b1b738a40c274285527c193f">std::move</a>(persistence)) {</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;}</div><div class="ttc" id="namespacefolly_1_1gen_html_ac24ec252b1b738a40c274285527c193f"><div class="ttname"><a href="namespacefolly_1_1gen.html#ac24ec252b1b738a40c274285527c193f">folly::gen::move</a></div><div class="ttdeci">constexpr detail::Map&lt; Move &gt; move</div><div class="ttdef"><b>Definition:</b> <a href="Base-inl_8h_source.html#l02567">Base-inl.h:2567</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a9757b68f199570adf0be47bd22505e8f"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a9757b68f199570adf0be47bd22505e8f">wangle::LRUPersistentCache::LRUPersistentCache</a></div><div class="ttdeci">LRUPersistentCache(std::size_t cacheCapacity, std::chrono::milliseconds syncInterval=client::persistence::DEFAULT_CACHE_SYNC_INTERVAL, int nSyncRetries=client::persistence::DEFAULT_CACHE_SYNC_RETRIES, std::unique_ptr&lt; CachePersistence&lt; K, V &gt;&gt; persistence=nullptr)</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache-inl_8h_source.html#l00031">LRUPersistentCache-inl.h:31</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab9c0da58386564fc6e1620da0820a5ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::<a class="el" href="classwangle_1_1LRUPersistentCache.html">LRUPersistentCache</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classfolly_1_1Executor.html">folly::Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>executor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>cacheCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>syncInterval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSyncRetries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classwangle_1_1CachePersistence.html">CachePersistence</a>&lt; K, V &gt;&gt;&#160;</td>
          <td class="paramname"><em>persistence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00045">45</a> of file <a class="el" href="LRUPersistentCache-inl_8h_source.html">LRUPersistentCache-inl.h</a>.</p>

<p>References <a class="el" href="LRUPersistentCache_8h_source.html#l00292">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::executor_</a>, <a class="el" href="Base-inl_8h_source.html#l02567">folly::gen::move</a>, <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00212">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::setPersistenceHelper()</a>, and <a class="el" href="LRUPersistentCache_8h_source.html#l00289">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::syncer_</a>.</p>
<div class="fragment"><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    : <a class="code" href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">cache_</a>(cacheCapacity),</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;      <a class="code" href="classwangle_1_1LRUPersistentCache.html#acf50ee1960461284c2bbf522d6b19be1">syncInterval_</a>(syncInterval),</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;      <a class="code" href="classwangle_1_1LRUPersistentCache.html#af246945baba03071238b1fad94beffa6">nSyncRetries_</a>(nSyncRetries),</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;      <a class="code" href="classwangle_1_1LRUPersistentCache.html#a016d852231aa66e1535cff9e0115c941">executor_</a>(<a class="code" href="namespacefolly_1_1gen.html#ac24ec252b1b738a40c274285527c193f">std::move</a>(<a class="code" href="namespacefolly_1_1pushmi.html#a845fc76a7574c2f87e2b0dde29867f74">executor</a>)) {</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  <span class="comment">// load the cache. be silent if load fails, we just drop the cache</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  <span class="comment">// and start from scratch.</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  <span class="keywordflow">if</span> (persistence) {</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <a class="code" href="classwangle_1_1LRUPersistentCache.html#adbe01633c6baa529d6e94ffd4ec934ef">setPersistenceHelper</a>(<a class="code" href="namespacefolly_1_1gen.html#ac24ec252b1b738a40c274285527c193f">std::move</a>(persistence), <span class="keyword">true</span>);</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  }</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="classwangle_1_1LRUPersistentCache.html#a016d852231aa66e1535cff9e0115c941">executor_</a>) {</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <span class="comment">// start the syncer thread. done at the end of construction so that the</span></div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <span class="comment">// cache is fully initialized before being passed to the syncer thread.</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    <a class="code" href="classwangle_1_1LRUPersistentCache.html#a65cdae47124ba26ac2c66eecb0c117ad">syncer_</a> =</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        std::thread(&amp;<a class="code" href="classwangle_1_1LRUPersistentCache.html#af45bb4c57317db72a11ab07dc60c3fb4">LRUPersistentCache&lt;K, V, MutexT&gt;::syncThreadMain</a>, <span class="keyword">this</span>);</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  }</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;}</div><div class="ttc" id="namespacefolly_1_1gen_html_ac24ec252b1b738a40c274285527c193f"><div class="ttname"><a href="namespacefolly_1_1gen.html#ac24ec252b1b738a40c274285527c193f">folly::gen::move</a></div><div class="ttdeci">constexpr detail::Map&lt; Move &gt; move</div><div class="ttdef"><b>Definition:</b> <a href="Base-inl_8h_source.html#l02567">Base-inl.h:2567</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a016d852231aa66e1535cff9e0115c941"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a016d852231aa66e1535cff9e0115c941">wangle::LRUPersistentCache::executor_</a></div><div class="ttdeci">std::shared_ptr&lt; folly::Executor &gt; executor_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00292">LRUPersistentCache.h:292</a></div></div>
<div class="ttc" id="namespacefolly_1_1pushmi_html_a845fc76a7574c2f87e2b0dde29867f74"><div class="ttname"><a href="namespacefolly_1_1pushmi.html#a845fc76a7574c2f87e2b0dde29867f74">folly::pushmi::executor</a></div><div class="ttdeci">PUSHMI_INLINE_VAR constexpr __adl::get_executor_fn executor</div><div class="ttdef"><b>Definition:</b> <a href="extension__points_8h_source.html#l00359">extension_points.h:359</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_adbe01633c6baa529d6e94ffd4ec934ef"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#adbe01633c6baa529d6e94ffd4ec934ef">wangle::LRUPersistentCache::setPersistenceHelper</a></div><div class="ttdeci">void setPersistenceHelper(std::unique_ptr&lt; CachePersistence&lt; K, V &gt;&gt; persistence, bool syncVersion) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache-inl_8h_source.html#l00212">LRUPersistentCache-inl.h:212</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_af246945baba03071238b1fad94beffa6"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#af246945baba03071238b1fad94beffa6">wangle::LRUPersistentCache::nSyncRetries_</a></div><div class="ttdeci">const int nSyncRetries_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00273">LRUPersistentCache.h:273</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a7c89180fae7c002ac23925ccce7b83bd"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">wangle::LRUPersistentCache::cache_</a></div><div class="ttdeci">LRUInMemoryCache&lt; K, V, MutexT &gt; cache_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00257">LRUPersistentCache.h:257</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_acf50ee1960461284c2bbf522d6b19be1"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#acf50ee1960461284c2bbf522d6b19be1">wangle::LRUPersistentCache::syncInterval_</a></div><div class="ttdeci">const std::chrono::milliseconds syncInterval_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00270">LRUPersistentCache.h:270</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a65cdae47124ba26ac2c66eecb0c117ad"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a65cdae47124ba26ac2c66eecb0c117ad">wangle::LRUPersistentCache::syncer_</a></div><div class="ttdeci">std::thread syncer_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00289">LRUPersistentCache.h:289</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_af45bb4c57317db72a11ab07dc60c3fb4"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#af45bb4c57317db72a11ab07dc60c3fb4">wangle::LRUPersistentCache::syncThreadMain</a></div><div class="ttdeci">static void * syncThreadMain(void *arg)</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache-inl_8h_source.html#l00121">LRUPersistentCache-inl.h:121</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acc8f5c5941520b314e86590f82b8194a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename MutexT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::~<a class="el" href="classwangle_1_1LRUPersistentCache.html">LRUPersistentCache</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classwangle_1_1LRUPersistentCache.html">LRUPersistentCache</a> Destructor</p>
<p>Signals the syncer thread to stop, waits for any pending syncs to be done. </p>

<p>Definition at line <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00069">69</a> of file <a class="el" href="LRUPersistentCache-inl_8h_source.html">LRUPersistentCache-inl.h</a>.</p>

<p>References <a class="el" href="LRUPersistentCache_8h_source.html#l00292">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::executor_</a>, <a class="el" href="Synchronized_8h_source.html#l00871">folly::detail::lock()</a>, <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00130">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::oneShotSync()</a>, <a class="el" href="LRUPersistentCache_8h_source.html#l00260">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::stopSyncer_</a>, <a class="el" href="LRUPersistentCache_8h_source.html#l00264">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::stopSyncerCV_</a>, <a class="el" href="LRUPersistentCache_8h_source.html#l00262">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::stopSyncerMutex_</a>, <a class="el" href="LRUPersistentCache_8h_source.html#l00289">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::syncer_</a>, and <a class="el" href="LRUPersistentCache_8h_source.html#l00279">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::syncOnDestroy_</a>.</p>
<div class="fragment"><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;                                                      {</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classwangle_1_1LRUPersistentCache.html#a016d852231aa66e1535cff9e0115c941">executor_</a>) {</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    <span class="comment">// In executor mode, each task holds a weak_ptr to the cache itself. No need</span></div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <span class="comment">// to notify them the cache is dying. We are done here. Alternatively we may</span></div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <span class="comment">// want to do a final sync upon destruction.</span></div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <span class="keywordflow">return</span>;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  }</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  {</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <span class="comment">// tell syncer to wake up and quit</span></div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    std::lock_guard&lt;std::mutex&gt; <a class="code" href="namespacefolly_1_1detail.html#a387acec4cb2d7df1e6bab13521d27e60">lock</a>(<a class="code" href="classwangle_1_1LRUPersistentCache.html#af43b3a33d3053cab6a7df84f752ffd4f">stopSyncerMutex_</a>);</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    <a class="code" href="classwangle_1_1LRUPersistentCache.html#a06a71ae938b18705e30af27497673a56">stopSyncer_</a> = <span class="keyword">true</span>;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classwangle_1_1LRUPersistentCache.html#a7f8c5d1001ad1b00f1b93186aa3a4fb0">syncOnDestroy_</a>) {</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;      <span class="comment">// Sync on the thread of the destroyer.</span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;      <a class="code" href="classwangle_1_1LRUPersistentCache.html#a4cf7f67e7556142f67bdd59bd49acdd0">oneShotSync</a>();</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    }</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <a class="code" href="classwangle_1_1LRUPersistentCache.html#aa405e907b62768fbb2fbc060b7a655bc">stopSyncerCV_</a>.notify_all();</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  }</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;  <a class="code" href="classwangle_1_1LRUPersistentCache.html#a65cdae47124ba26ac2c66eecb0c117ad">syncer_</a>.join();</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;}</div><div class="ttc" id="classwangle_1_1LRUPersistentCache_html_aa405e907b62768fbb2fbc060b7a655bc"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#aa405e907b62768fbb2fbc060b7a655bc">wangle::LRUPersistentCache::stopSyncerCV_</a></div><div class="ttdeci">std::condition_variable stopSyncerCV_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00264">LRUPersistentCache.h:264</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a4cf7f67e7556142f67bdd59bd49acdd0"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a4cf7f67e7556142f67bdd59bd49acdd0">wangle::LRUPersistentCache::oneShotSync</a></div><div class="ttdeci">void oneShotSync()</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache-inl_8h_source.html#l00130">LRUPersistentCache-inl.h:130</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a016d852231aa66e1535cff9e0115c941"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a016d852231aa66e1535cff9e0115c941">wangle::LRUPersistentCache::executor_</a></div><div class="ttdeci">std::shared_ptr&lt; folly::Executor &gt; executor_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00292">LRUPersistentCache.h:292</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a06a71ae938b18705e30af27497673a56"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a06a71ae938b18705e30af27497673a56">wangle::LRUPersistentCache::stopSyncer_</a></div><div class="ttdeci">bool stopSyncer_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00260">LRUPersistentCache.h:260</a></div></div>
<div class="ttc" id="namespacefolly_1_1detail_html_a387acec4cb2d7df1e6bab13521d27e60"><div class="ttname"><a href="namespacefolly_1_1detail.html#a387acec4cb2d7df1e6bab13521d27e60">folly::detail::lock</a></div><div class="ttdeci">auto lock(SynchronizedLocker...lockersIn) -&gt; std::tuple&lt; typename SynchronizedLocker::LockedPtr... &gt;</div><div class="ttdef"><b>Definition:</b> <a href="Synchronized_8h_source.html#l00871">Synchronized.h:871</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a7f8c5d1001ad1b00f1b93186aa3a4fb0"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a7f8c5d1001ad1b00f1b93186aa3a4fb0">wangle::LRUPersistentCache::syncOnDestroy_</a></div><div class="ttdeci">bool syncOnDestroy_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00279">LRUPersistentCache.h:279</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a65cdae47124ba26ac2c66eecb0c117ad"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a65cdae47124ba26ac2c66eecb0c117ad">wangle::LRUPersistentCache::syncer_</a></div><div class="ttdeci">std::thread syncer_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00289">LRUPersistentCache.h:289</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_af43b3a33d3053cab6a7df84f752ffd4f"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#af43b3a33d3053cab6a7df84f752ffd4f">wangle::LRUPersistentCache::stopSyncerMutex_</a></div><div class="ttdeci">std::mutex stopSyncerMutex_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00262">LRUPersistentCache.h:262</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae571e0c624e47586ef8fa4444b7cadef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT = std::mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearPersistence</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Empty the contents of the cache </p>

<p>Implements <a class="el" href="classwangle_1_1PersistentCache.html#a44960d4a29a1c5030bdc991672c9b7b0">wangle::PersistentCache&lt; K, V &gt;</a>.</p>

<p>Definition at line <a class="el" href="LRUPersistentCache_8h_source.html#l00184">184</a> of file <a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a>.</p>

<p>Referenced by <a class="el" href="FilePersistentCache_8h_source.html#l00075">wangle::FilePersistentCache&lt; K, V, M &gt;::clear()</a>.</p>
<div class="fragment"><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;                                                     {</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    <a class="code" href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">cache_</a>.clear();</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    <span class="keywordflow">if</span> (clearPersistence) {</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;      <span class="keyword">auto</span> persistence = <a class="code" href="classwangle_1_1LRUPersistentCache.html#a5fa08e5f576df0a31c1fb54ab9ce115a">getPersistence</a>();</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;      <span class="keywordflow">if</span> (persistence) {</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        persistence-&gt;clear();</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;      }</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    }</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;  }</div><div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a7c89180fae7c002ac23925ccce7b83bd"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">wangle::LRUPersistentCache::cache_</a></div><div class="ttdeci">LRUInMemoryCache&lt; K, V, MutexT &gt; cache_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00257">LRUPersistentCache.h:257</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a5fa08e5f576df0a31c1fb54ab9ce115a"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a5fa08e5f576df0a31c1fb54ab9ce115a">wangle::LRUPersistentCache::getPersistence</a></div><div class="ttdeci">std::shared_ptr&lt; CachePersistence&lt; K, V &gt; &gt; getPersistence()</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache-inl_8h_source.html#l00206">LRUPersistentCache-inl.h:206</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6121ae85b05a20620d6fc61b8c193395"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT = std::mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfolly_1_1Optional.html">folly::Optional</a>&lt;V&gt; <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classwangle_1_1PersistentCache.html">PersistentCache</a> operations </p>

<p>Implements <a class="el" href="classwangle_1_1PersistentCache.html#a3db200dcc63e7e69393089f00369234d">wangle::PersistentCache&lt; K, V &gt;</a>.</p>

<p>Definition at line <a class="el" href="LRUPersistentCache_8h_source.html#l00174">174</a> of file <a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a>.</p>

<p>Referenced by <a class="el" href="FilePersistentCache_8h_source.html#l00063">wangle::FilePersistentCache&lt; K, V, M &gt;::get()</a>.</p>
<div class="fragment"><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;                                              {</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">cache_</a>.get(key);</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  }</div><div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a7c89180fae7c002ac23925ccce7b83bd"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">wangle::LRUPersistentCache::cache_</a></div><div class="ttdeci">LRUInMemoryCache&lt; K, V, MutexT &gt; cache_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00257">LRUPersistentCache.h:257</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5fa08e5f576df0a31c1fb54ab9ce115a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename MutexT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classwangle_1_1CachePersistence.html">CachePersistence</a>&lt; K, V &gt; &gt; <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::getPersistence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper to get the persistence layer under lock since it will be called by syncer thread and setters call from any thread. </p>

<p>Definition at line <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00206">206</a> of file <a class="el" href="LRUPersistentCache-inl_8h_source.html">LRUPersistentCache-inl.h</a>.</p>

<p>References <a class="el" href="LRUPersistentCache_8h_source.html#l00284">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::persistence_</a>, and <a class="el" href="LRUPersistentCache_8h_source.html#l00286">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::persistenceLock_</a>.</p>

<p>Referenced by <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00130">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::oneShotSync()</a>, and <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00146">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::sync()</a>.</p>
<div class="fragment"><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;                                                 {</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;  <span class="keyword">typename</span> <a class="code" href="structwangle_1_1CacheLockGuard.html">wangle::CacheLockGuard&lt;MutexT&gt;::Read</a> readLock(<a class="code" href="classwangle_1_1LRUPersistentCache.html#aff313d97b5c2f1d7779775e6ff4268a8">persistenceLock_</a>);</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classwangle_1_1LRUPersistentCache.html#a6b1dc6b4eab04e0f55c0832aabe02ec1">persistence_</a>;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;}</div><div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a6b1dc6b4eab04e0f55c0832aabe02ec1"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a6b1dc6b4eab04e0f55c0832aabe02ec1">wangle::LRUPersistentCache::persistence_</a></div><div class="ttdeci">std::shared_ptr&lt; CachePersistence&lt; K, V &gt; &gt; persistence_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00284">LRUPersistentCache.h:284</a></div></div>
<div class="ttc" id="structwangle_1_1CacheLockGuard_html"><div class="ttname"><a href="structwangle_1_1CacheLockGuard.html">wangle::CacheLockGuard</a></div><div class="ttdef"><b>Definition:</b> <a href="PersistentCacheCommon_8h_source.html#l00026">PersistentCacheCommon.h:26</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_aff313d97b5c2f1d7779775e6ff4268a8"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#aff313d97b5c2f1d7779775e6ff4268a8">wangle::LRUPersistentCache::persistenceLock_</a></div><div class="ttdeci">MutexT persistenceLock_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00286">LRUPersistentCache.h:286</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa9f216e84f0283880b67f7eaf810fc5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename MutexT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::hasPendingUpdates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if there are updates that need to be synced to persistence </p>

<p>Definition at line <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00112">112</a> of file <a class="el" href="LRUPersistentCache-inl_8h_source.html">LRUPersistentCache-inl.h</a>.</p>

<p>References <a class="el" href="LRUPersistentCache_8h_source.html#l00257">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::cache_</a>, <a class="el" href="LRUPersistentCache_8h_source.html#l00284">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::persistence_</a>, and <a class="el" href="LRUPersistentCache_8h_source.html#l00286">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::persistenceLock_</a>.</p>
<div class="fragment"><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;                                                         {</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  <span class="keyword">typename</span> <a class="code" href="structwangle_1_1CacheLockGuard.html">wangle::CacheLockGuard&lt;MutexT&gt;::Read</a> readLock(<a class="code" href="classwangle_1_1LRUPersistentCache.html#aff313d97b5c2f1d7779775e6ff4268a8">persistenceLock_</a>);</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="classwangle_1_1LRUPersistentCache.html#a6b1dc6b4eab04e0f55c0832aabe02ec1">persistence_</a>) {</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  }</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">cache_</a>.hasChangedSince(<a class="code" href="classwangle_1_1LRUPersistentCache.html#a6b1dc6b4eab04e0f55c0832aabe02ec1">persistence_</a>-&gt;getLastPersistedVersion());</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;}</div><div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a6b1dc6b4eab04e0f55c0832aabe02ec1"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a6b1dc6b4eab04e0f55c0832aabe02ec1">wangle::LRUPersistentCache::persistence_</a></div><div class="ttdeci">std::shared_ptr&lt; CachePersistence&lt; K, V &gt; &gt; persistence_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00284">LRUPersistentCache.h:284</a></div></div>
<div class="ttc" id="structwangle_1_1CacheLockGuard_html"><div class="ttname"><a href="structwangle_1_1CacheLockGuard.html">wangle::CacheLockGuard</a></div><div class="ttdef"><b>Definition:</b> <a href="PersistentCacheCommon_8h_source.html#l00026">PersistentCacheCommon.h:26</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_aff313d97b5c2f1d7779775e6ff4268a8"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#aff313d97b5c2f1d7779775e6ff4268a8">wangle::LRUPersistentCache::persistenceLock_</a></div><div class="ttdeci">MutexT persistenceLock_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00286">LRUPersistentCache.h:286</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a7c89180fae7c002ac23925ccce7b83bd"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">wangle::LRUPersistentCache::cache_</a></div><div class="ttdeci">LRUInMemoryCache&lt; K, V, MutexT &gt; cache_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00257">LRUPersistentCache.h:257</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af0d473fbc1d813268c92429662a36f82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacewangle.html#aeccf189e78de80caf7e2aa50c59d464c">CacheDataVersion</a> <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwangle_1_1CachePersistence.html">CachePersistence</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>persistence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the contents of the persistence passed to constructor in to the in-memory cache. Failure to read will result in no changes to the in-memory data. That is, if in-memory entries exist, and loading fails, the in-memory data remains and will sync down to the underlying persistence layer on the next sync.</p>
<p>Failure to read inclues IO errors and deserialization errors.</p>
<dl class="section return"><dt>Returns</dt><dd>the in memory cache's new version </dd></dl>

<p>Definition at line <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00236">236</a> of file <a class="el" href="LRUPersistentCache-inl_8h_source.html">LRUPersistentCache-inl.h</a>.</p>

<p>References <a class="el" href="LRUPersistentCache_8h_source.html#l00257">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::cache_</a>.</p>

<p>Referenced by <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00212">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::setPersistenceHelper()</a>.</p>
<div class="fragment"><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;                                                  {</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;  <span class="keyword">auto</span> kvPairs = persistence.load();</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;  <span class="keywordflow">if</span> (!kvPairs) {</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;  }</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">cache_</a>.loadData(kvPairs.value());</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;}</div><div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a7c89180fae7c002ac23925ccce7b83bd"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">wangle::LRUPersistentCache::cache_</a></div><div class="ttdeci">LRUInMemoryCache&lt; K, V, MutexT &gt; cache_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00257">LRUPersistentCache.h:257</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4cf7f67e7556142f67bdd59bd49acdd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename MutexT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::oneShotSync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00130">130</a> of file <a class="el" href="LRUPersistentCache-inl_8h_source.html">LRUPersistentCache-inl.h</a>.</p>

<p>References <a class="el" href="LRUPersistentCache_8h_source.html#l00257">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::cache_</a>, <a class="el" href="LRUPersistentCache_8h_source.html#l00267">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::executorScheduled_</a>, <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00206">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::getPersistence()</a>, <a class="el" href="LRUPersistentCache_8h_source.html#l00273">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::nSyncRetries_</a>, <a class="el" href="LRUPersistentCache_8h_source.html#l00275">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::nSyncTries_</a>, and <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00178">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::syncNow()</a>.</p>

<p>Referenced by <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00069">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::~LRUPersistentCache()</a>.</p>
<div class="fragment"><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;                                                   {</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  <a class="code" href="classwangle_1_1LRUPersistentCache.html#aaf611ef758be7996827c8b9544bf89d4">executorScheduled_</a>.clear();</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;  <span class="keyword">auto</span> persistence = <a class="code" href="classwangle_1_1LRUPersistentCache.html#a5fa08e5f576df0a31c1fb54ab9ce115a">getPersistence</a>();</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;  <span class="keywordflow">if</span> (persistence &amp;&amp; !<a class="code" href="classwangle_1_1LRUPersistentCache.html#a1f1d482dfe6a457aaf780ad7f3d28751">syncNow</a>(*persistence)) {</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    <span class="comment">// track failures and give up if we tried too many times</span></div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    ++<a class="code" href="classwangle_1_1LRUPersistentCache.html#a0bd97e6e8ad2e5e9100b0aa6fe625f41">nSyncTries_</a>;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classwangle_1_1LRUPersistentCache.html#a0bd97e6e8ad2e5e9100b0aa6fe625f41">nSyncTries_</a> == <a class="code" href="classwangle_1_1LRUPersistentCache.html#af246945baba03071238b1fad94beffa6">nSyncRetries_</a>) {</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;      persistence-&gt;setPersistedVersion(<a class="code" href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">cache_</a>.getVersion());</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;      <a class="code" href="classwangle_1_1LRUPersistentCache.html#a0bd97e6e8ad2e5e9100b0aa6fe625f41">nSyncTries_</a> = 0;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    }</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    <a class="code" href="classwangle_1_1LRUPersistentCache.html#a0bd97e6e8ad2e5e9100b0aa6fe625f41">nSyncTries_</a> = 0;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  }</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;}</div><div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a0bd97e6e8ad2e5e9100b0aa6fe625f41"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a0bd97e6e8ad2e5e9100b0aa6fe625f41">wangle::LRUPersistentCache::nSyncTries_</a></div><div class="ttdeci">int nSyncTries_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00275">LRUPersistentCache.h:275</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_aaf611ef758be7996827c8b9544bf89d4"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#aaf611ef758be7996827c8b9544bf89d4">wangle::LRUPersistentCache::executorScheduled_</a></div><div class="ttdeci">std::atomic_flag executorScheduled_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00267">LRUPersistentCache.h:267</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_af246945baba03071238b1fad94beffa6"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#af246945baba03071238b1fad94beffa6">wangle::LRUPersistentCache::nSyncRetries_</a></div><div class="ttdeci">const int nSyncRetries_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00273">LRUPersistentCache.h:273</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a7c89180fae7c002ac23925ccce7b83bd"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">wangle::LRUPersistentCache::cache_</a></div><div class="ttdeci">LRUInMemoryCache&lt; K, V, MutexT &gt; cache_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00257">LRUPersistentCache.h:257</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a1f1d482dfe6a457aaf780ad7f3d28751"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a1f1d482dfe6a457aaf780ad7f3d28751">wangle::LRUPersistentCache::syncNow</a></div><div class="ttdeci">bool syncNow(CachePersistence&lt; K, V &gt; &amp;persistence)</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache-inl_8h_source.html#l00178">LRUPersistentCache-inl.h:178</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a5fa08e5f576df0a31c1fb54ab9ce115a"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a5fa08e5f576df0a31c1fb54ab9ce115a">wangle::LRUPersistentCache::getPersistence</a></div><div class="ttdeci">std::shared_ptr&lt; CachePersistence&lt; K, V &gt; &gt; getPersistence()</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache-inl_8h_source.html#l00206">LRUPersistentCache-inl.h:206</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a867bb37cbedb276407a0a02f2389c103"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::put </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set a value corresponding to a key </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>string, the key to set </td></tr>
    <tr><td class="paramname">val</td><td>string, the value to set</td></tr>
  </table>
  </dd>
</dl>
<p>overwrites value if key has a value associated in the cache </p>

<p>Implements <a class="el" href="classwangle_1_1PersistentCache.html#ad4268549b6675fae30f6d890a8e471dd">wangle::PersistentCache&lt; K, V &gt;</a>.</p>

<p>Definition at line <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00090">90</a> of file <a class="el" href="LRUPersistentCache-inl_8h_source.html">LRUPersistentCache-inl.h</a>.</p>

<p>References <a class="el" href="LRUPersistentCache_8h_source.html#l00257">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::cache_</a>, <a class="el" href="LRUPersistentCache_8h_source.html#l00292">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::executor_</a>, <a class="el" href="LRUPersistentCache_8h_source.html#l00267">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::executorScheduled_</a>, <a class="el" href="LRUPersistentCache_8h_source.html#l00276">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::lastExecutorScheduleTime_</a>, <a class="el" href="Synchronized_8h_source.html#l00871">folly::detail::lock()</a>, <a class="el" href="Base-inl_8h_source.html#l02567">folly::gen::move</a>, <a class="el" href="TimekeeperTest_8cpp_source.html#l00031">now()</a>, and <a class="el" href="LRUPersistentCache_8h_source.html#l00270">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::syncInterval_</a>.</p>

<p>Referenced by <a class="el" href="FilePersistentCache_8h_source.html#l00067">wangle::FilePersistentCache&lt; K, V, M &gt;::put()</a>.</p>
<div class="fragment"><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;                                                                     {</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  <a class="code" href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">cache_</a>.put(key, <a class="code" href="String_8cpp.html#a3c8bc0bb4f045bfe78d1196cb786792c">val</a>);</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classwangle_1_1LRUPersistentCache.html#a016d852231aa66e1535cff9e0115c941">executor_</a>) {</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="classwangle_1_1LRUPersistentCache.html#aaf611ef758be7996827c8b9544bf89d4">executorScheduled_</a>.test_and_set()) {</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="TimekeeperTest_8cpp.html#a562b4baa36dcf267f35a4ba4e0aef329">std::chrono::steady_clock::now</a>() - <a class="code" href="classwangle_1_1LRUPersistentCache.html#a6045c5ff13560b2a3f3fcadb4ea641e8">lastExecutorScheduleTime_</a> &lt;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;          <a class="code" href="classwangle_1_1LRUPersistentCache.html#acf50ee1960461284c2bbf522d6b19be1">syncInterval_</a>) {</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;        <span class="comment">// Do not schedule more than once during a syncInterval_ period</span></div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        <span class="keywordflow">return</span>;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;      }</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;      std::weak_ptr&lt;LRUPersistentCache&lt;K, V, MutexT&gt;&gt; weakSelf =</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;          this-&gt;shared_from_this();</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;      <a class="code" href="classwangle_1_1LRUPersistentCache.html#a6045c5ff13560b2a3f3fcadb4ea641e8">lastExecutorScheduleTime_</a> = <a class="code" href="TimekeeperTest_8cpp.html#a562b4baa36dcf267f35a4ba4e0aef329">std::chrono::steady_clock::now</a>();</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;      <a class="code" href="classwangle_1_1LRUPersistentCache.html#a016d852231aa66e1535cff9e0115c941">executor_</a>-&gt;add([<span class="keyword">self</span> = <a class="code" href="namespacefolly_1_1gen.html#ac24ec252b1b738a40c274285527c193f">std::move</a>(weakSelf)]() {</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        <span class="keywordflow">if</span> (<span class="keyword">auto</span> sharedSelf = <span class="keyword">self</span>.<a class="code" href="namespacefolly_1_1detail.html#a387acec4cb2d7df1e6bab13521d27e60">lock</a>()) {</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;          sharedSelf-&gt;oneShotSync();</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        }</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;      });</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    }</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;  }</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;}</div><div class="ttc" id="namespacefolly_1_1gen_html_ac24ec252b1b738a40c274285527c193f"><div class="ttname"><a href="namespacefolly_1_1gen.html#ac24ec252b1b738a40c274285527c193f">folly::gen::move</a></div><div class="ttdeci">constexpr detail::Map&lt; Move &gt; move</div><div class="ttdef"><b>Definition:</b> <a href="Base-inl_8h_source.html#l02567">Base-inl.h:2567</a></div></div>
<div class="ttc" id="TimekeeperTest_8cpp_html_a562b4baa36dcf267f35a4ba4e0aef329"><div class="ttname"><a href="TimekeeperTest_8cpp.html#a562b4baa36dcf267f35a4ba4e0aef329">now</a></div><div class="ttdeci">std::chrono::steady_clock::time_point now()</div><div class="ttdef"><b>Definition:</b> <a href="TimekeeperTest_8cpp_source.html#l00031">TimekeeperTest.cpp:31</a></div></div>
<div class="ttc" id="String_8cpp_html_a3c8bc0bb4f045bfe78d1196cb786792c"><div class="ttname"><a href="String_8cpp.html#a3c8bc0bb4f045bfe78d1196cb786792c">val</a></div><div class="ttdeci">double val</div><div class="ttdef"><b>Definition:</b> <a href="String_8cpp_source.html#l00273">String.cpp:273</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a016d852231aa66e1535cff9e0115c941"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a016d852231aa66e1535cff9e0115c941">wangle::LRUPersistentCache::executor_</a></div><div class="ttdeci">std::shared_ptr&lt; folly::Executor &gt; executor_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00292">LRUPersistentCache.h:292</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_aaf611ef758be7996827c8b9544bf89d4"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#aaf611ef758be7996827c8b9544bf89d4">wangle::LRUPersistentCache::executorScheduled_</a></div><div class="ttdeci">std::atomic_flag executorScheduled_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00267">LRUPersistentCache.h:267</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a6045c5ff13560b2a3f3fcadb4ea641e8"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a6045c5ff13560b2a3f3fcadb4ea641e8">wangle::LRUPersistentCache::lastExecutorScheduleTime_</a></div><div class="ttdeci">std::chrono::steady_clock::time_point lastExecutorScheduleTime_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00276">LRUPersistentCache.h:276</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a7c89180fae7c002ac23925ccce7b83bd"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">wangle::LRUPersistentCache::cache_</a></div><div class="ttdeci">LRUInMemoryCache&lt; K, V, MutexT &gt; cache_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00257">LRUPersistentCache.h:257</a></div></div>
<div class="ttc" id="namespacefolly_1_1detail_html_a387acec4cb2d7df1e6bab13521d27e60"><div class="ttname"><a href="namespacefolly_1_1detail.html#a387acec4cb2d7df1e6bab13521d27e60">folly::detail::lock</a></div><div class="ttdeci">auto lock(SynchronizedLocker...lockersIn) -&gt; std::tuple&lt; typename SynchronizedLocker::LockedPtr... &gt;</div><div class="ttdef"><b>Definition:</b> <a href="Synchronized_8h_source.html#l00871">Synchronized.h:871</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_acf50ee1960461284c2bbf522d6b19be1"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#acf50ee1960461284c2bbf522d6b19be1">wangle::LRUPersistentCache::syncInterval_</a></div><div class="ttdeci">const std::chrono::milliseconds syncInterval_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00270">LRUPersistentCache.h:270</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4148b75c82a5e0e9ef73eb8b290d5766"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT = std::mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear a cache entry associated with a key </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>string, the key to lookup and clear</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean true if any elements are removed, else false </dd></dl>

<p>Implements <a class="el" href="classwangle_1_1PersistentCache.html#a9391d71b061410ff1b2280fc2f77ca71">wangle::PersistentCache&lt; K, V &gt;</a>.</p>

<p>Definition at line <a class="el" href="LRUPersistentCache_8h_source.html#l00180">180</a> of file <a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a>.</p>

<p>Referenced by <a class="el" href="FilePersistentCache_8h_source.html#l00071">wangle::FilePersistentCache&lt; K, V, M &gt;::remove()</a>.</p>
<div class="fragment"><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;                                     {</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">cache_</a>.remove(key);</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;  }</div><div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a7c89180fae7c002ac23925ccce7b83bd"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">wangle::LRUPersistentCache::cache_</a></div><div class="ttdeci">LRUInMemoryCache&lt; K, V, MutexT &gt; cache_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00257">LRUPersistentCache.h:257</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae3e8b64b7193a179409b8601a8fdb279"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::setPersistence </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classwangle_1_1CachePersistence.html">CachePersistence</a>&lt; K, V &gt;&gt;&#160;</td>
          <td class="paramname"><em>persistence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a new persistence layer on this cache. This call blocks while the new persistence layer is loaded into the cache. The load is also done under a lock so multiple calls to this will not stomp on each other. </p>

<p>Definition at line <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00227">227</a> of file <a class="el" href="LRUPersistentCache-inl_8h_source.html">LRUPersistentCache-inl.h</a>.</p>

<p>References <a class="el" href="Base-inl_8h_source.html#l02567">folly::gen::move</a>, and <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00212">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::setPersistenceHelper()</a>.</p>
<div class="fragment"><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                                                       {</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;  <span class="comment">// note that we don&#39;t set the persisted version on the persistence like we</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;  <span class="comment">// do in the constructor since we want any deltas that were in memory but</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;  <span class="comment">// not in the persistence layer to sync back.</span></div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;  <a class="code" href="classwangle_1_1LRUPersistentCache.html#adbe01633c6baa529d6e94ffd4ec934ef">setPersistenceHelper</a>(<a class="code" href="namespacefolly_1_1gen.html#ac24ec252b1b738a40c274285527c193f">std::move</a>(persistence), <span class="keyword">false</span>);</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;}</div><div class="ttc" id="namespacefolly_1_1gen_html_ac24ec252b1b738a40c274285527c193f"><div class="ttname"><a href="namespacefolly_1_1gen.html#ac24ec252b1b738a40c274285527c193f">folly::gen::move</a></div><div class="ttdeci">constexpr detail::Map&lt; Move &gt; move</div><div class="ttdef"><b>Definition:</b> <a href="Base-inl_8h_source.html#l02567">Base-inl.h:2567</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_adbe01633c6baa529d6e94ffd4ec934ef"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#adbe01633c6baa529d6e94ffd4ec934ef">wangle::LRUPersistentCache::setPersistenceHelper</a></div><div class="ttdeci">void setPersistenceHelper(std::unique_ptr&lt; CachePersistence&lt; K, V &gt;&gt; persistence, bool syncVersion) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache-inl_8h_source.html#l00212">LRUPersistentCache-inl.h:212</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adbe01633c6baa529d6e94ffd4ec934ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::setPersistenceHelper </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classwangle_1_1CachePersistence.html">CachePersistence</a>&lt; K, V &gt;&gt;&#160;</td>
          <td class="paramname"><em>persistence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>syncVersion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper to set persistence that will load the persistence data into memory and optionally sync versions </p>

<p>Definition at line <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00212">212</a> of file <a class="el" href="LRUPersistentCache-inl_8h_source.html">LRUPersistentCache-inl.h</a>.</p>

<p>References <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00236">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::load()</a>, <a class="el" href="Base-inl_8h_source.html#l02567">folly::gen::move</a>, <a class="el" href="LRUPersistentCache_8h_source.html#l00284">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::persistence_</a>, <a class="el" href="LRUPersistentCache_8h_source.html#l00286">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::persistenceLock_</a>, and <a class="el" href="ClientProtocol_8cpp_source.html#l01005">version</a>.</p>

<p>Referenced by <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00045">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::LRUPersistentCache()</a>, and <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00227">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::setPersistence()</a>.</p>
<div class="fragment"><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;                               {</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;  <span class="keyword">typename</span> <a class="code" href="structwangle_1_1CacheLockGuard.html">wangle::CacheLockGuard&lt;MutexT&gt;::Write</a> writeLock(<a class="code" href="classwangle_1_1LRUPersistentCache.html#aff313d97b5c2f1d7779775e6ff4268a8">persistenceLock_</a>);</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;  <a class="code" href="classwangle_1_1LRUPersistentCache.html#a6b1dc6b4eab04e0f55c0832aabe02ec1">persistence_</a> = <a class="code" href="namespacefolly_1_1gen.html#ac24ec252b1b738a40c274285527c193f">std::move</a>(persistence);</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;  <span class="comment">// load the persistence data into memory</span></div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classwangle_1_1LRUPersistentCache.html#a6b1dc6b4eab04e0f55c0832aabe02ec1">persistence_</a>) {</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    <span class="keyword">auto</span> <a class="code" href="ClientProtocol_8cpp.html#abe1b247743d4691ae90a9b12b08cc176">version</a> = <a class="code" href="classwangle_1_1LRUPersistentCache.html#af0d473fbc1d813268c92429662a36f82">load</a>(*<a class="code" href="classwangle_1_1LRUPersistentCache.html#a6b1dc6b4eab04e0f55c0832aabe02ec1">persistence_</a>);</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    <span class="keywordflow">if</span> (syncVersion) {</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;      <a class="code" href="classwangle_1_1LRUPersistentCache.html#a6b1dc6b4eab04e0f55c0832aabe02ec1">persistence_</a>-&gt;setPersistedVersion(<a class="code" href="ClientProtocol_8cpp.html#abe1b247743d4691ae90a9b12b08cc176">version</a>);</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    }</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;  }</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;}</div><div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a6b1dc6b4eab04e0f55c0832aabe02ec1"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a6b1dc6b4eab04e0f55c0832aabe02ec1">wangle::LRUPersistentCache::persistence_</a></div><div class="ttdeci">std::shared_ptr&lt; CachePersistence&lt; K, V &gt; &gt; persistence_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00284">LRUPersistentCache.h:284</a></div></div>
<div class="ttc" id="structwangle_1_1CacheLockGuard_html"><div class="ttname"><a href="structwangle_1_1CacheLockGuard.html">wangle::CacheLockGuard</a></div><div class="ttdef"><b>Definition:</b> <a href="PersistentCacheCommon_8h_source.html#l00026">PersistentCacheCommon.h:26</a></div></div>
<div class="ttc" id="namespacefolly_1_1gen_html_ac24ec252b1b738a40c274285527c193f"><div class="ttname"><a href="namespacefolly_1_1gen.html#ac24ec252b1b738a40c274285527c193f">folly::gen::move</a></div><div class="ttdeci">constexpr detail::Map&lt; Move &gt; move</div><div class="ttdef"><b>Definition:</b> <a href="Base-inl_8h_source.html#l02567">Base-inl.h:2567</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_aff313d97b5c2f1d7779775e6ff4268a8"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#aff313d97b5c2f1d7779775e6ff4268a8">wangle::LRUPersistentCache::persistenceLock_</a></div><div class="ttdeci">MutexT persistenceLock_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00286">LRUPersistentCache.h:286</a></div></div>
<div class="ttc" id="ClientProtocol_8cpp_html_abe1b247743d4691ae90a9b12b08cc176"><div class="ttname"><a href="ClientProtocol_8cpp.html#abe1b247743d4691ae90a9b12b08cc176">version</a></div><div class="ttdeci">ProtocolVersion version</div><div class="ttdef"><b>Definition:</b> <a href="ClientProtocol_8cpp_source.html#l01005">ClientProtocol.cpp:1005</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_af0d473fbc1d813268c92429662a36f82"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#af0d473fbc1d813268c92429662a36f82">wangle::LRUPersistentCache::load</a></div><div class="ttdeci">CacheDataVersion load(CachePersistence&lt; K, V &gt; &amp;persistence) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache-inl_8h_source.html#l00236">LRUPersistentCache-inl.h:236</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2dc77c568e225493d78fd476ebc51068"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT = std::mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::setSyncOnDestroy </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>syncOnDestroy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="LRUPersistentCache_8h_source.html#l00198">198</a> of file <a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a>.</p>

<p>Referenced by <a class="el" href="FilePersistentCache_8h_source.html#l00083">wangle::FilePersistentCache&lt; K, V, M &gt;::setSyncOnDestroy()</a>.</p>
<div class="fragment"><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;                                            {</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <a class="code" href="classwangle_1_1LRUPersistentCache.html#a7f8c5d1001ad1b00f1b93186aa3a4fb0">syncOnDestroy_</a> = syncOnDestroy;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;  }</div><div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a7f8c5d1001ad1b00f1b93186aa3a4fb0"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a7f8c5d1001ad1b00f1b93186aa3a4fb0">wangle::LRUPersistentCache::syncOnDestroy_</a></div><div class="ttdeci">bool syncOnDestroy_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00279">LRUPersistentCache.h:279</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1d44eea9886d7b23c0b86a95ee439e57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT = std::mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>return the size of the cache</p>
<dl class="section return"><dt>Returns</dt><dd>size_t, the size of the cache </dd></dl>

<p>Implements <a class="el" href="classwangle_1_1PersistentCache.html#ac6b0c2022ff890d7e3929646d7b5eb80">wangle::PersistentCache&lt; K, V &gt;</a>.</p>

<p>Definition at line <a class="el" href="LRUPersistentCache_8h_source.html#l00194">194</a> of file <a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a>.</p>

<p>Referenced by <a class="el" href="FilePersistentCache_8h_source.html#l00079">wangle::FilePersistentCache&lt; K, V, M &gt;::size()</a>.</p>
<div class="fragment"><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;                         {</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">cache_</a>.size();</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;  }</div><div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a7c89180fae7c002ac23925ccce7b83bd"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">wangle::LRUPersistentCache::cache_</a></div><div class="ttdeci">LRUInMemoryCache&lt; K, V, MutexT &gt; cache_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00257">LRUPersistentCache.h:257</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a049d8bec51d761125d5743ca3b9048f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename MutexT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::sync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The syncer thread's function. Syncs to the persistence, if necessary, after every syncInterval_ seconds. </p>

<p>Definition at line <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00146">146</a> of file <a class="el" href="LRUPersistentCache-inl_8h_source.html">LRUPersistentCache-inl.h</a>.</p>

<p>References <a class="el" href="LRUPersistentCache_8h_source.html#l00257">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::cache_</a>, <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00206">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::getPersistence()</a>, <a class="el" href="LRUPersistentCache_8h_source.html#l00273">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::nSyncRetries_</a>, <a class="el" href="LRUPersistentCache_8h_source.html#l00260">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::stopSyncer_</a>, <a class="el" href="LRUPersistentCache_8h_source.html#l00264">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::stopSyncerCV_</a>, <a class="el" href="LRUPersistentCache_8h_source.html#l00262">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::stopSyncerMutex_</a>, <a class="el" href="LRUPersistentCache_8h_source.html#l00270">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::syncInterval_</a>, and <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00178">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::syncNow()</a>.</p>

<p>Referenced by <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00121">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::syncThreadMain()</a>.</p>
<div class="fragment"><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;                                            {</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;  <span class="comment">// keep running as long the destructor signals to stop or</span></div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;  <span class="comment">// there are pending updates that are not synced yet</span></div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;  std::unique_lock&lt;std::mutex&gt; stopSyncerLock(<a class="code" href="classwangle_1_1LRUPersistentCache.html#af43b3a33d3053cab6a7df84f752ffd4f">stopSyncerMutex_</a>);</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;  <span class="keywordtype">int</span> nSyncFailures = 0;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;  <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    <span class="keyword">auto</span> persistence = <a class="code" href="classwangle_1_1LRUPersistentCache.html#a5fa08e5f576df0a31c1fb54ab9ce115a">getPersistence</a>();</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classwangle_1_1LRUPersistentCache.html#a06a71ae938b18705e30af27497673a56">stopSyncer_</a>) {</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;      <span class="keywordflow">if</span> (!persistence ||</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;          !<a class="code" href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">cache_</a>.hasChangedSince(persistence-&gt;getLastPersistedVersion())) {</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        <span class="keywordflow">break</span>;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;      }</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    }</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    <span class="keywordflow">if</span> (persistence &amp;&amp; !<a class="code" href="classwangle_1_1LRUPersistentCache.html#a1f1d482dfe6a457aaf780ad7f3d28751">syncNow</a>(*persistence)) {</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;      <span class="comment">// track failures and give up if we tried too many times</span></div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;      ++nSyncFailures;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;      <span class="keywordflow">if</span> (nSyncFailures == <a class="code" href="classwangle_1_1LRUPersistentCache.html#af246945baba03071238b1fad94beffa6">nSyncRetries_</a>) {</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        persistence-&gt;setPersistedVersion(<a class="code" href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">cache_</a>.getVersion());</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        nSyncFailures = 0;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;      }</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;      nSyncFailures = 0;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    }</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="classwangle_1_1LRUPersistentCache.html#a06a71ae938b18705e30af27497673a56">stopSyncer_</a>) {</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;      <a class="code" href="classwangle_1_1LRUPersistentCache.html#aa405e907b62768fbb2fbc060b7a655bc">stopSyncerCV_</a>.wait_for(stopSyncerLock, <a class="code" href="classwangle_1_1LRUPersistentCache.html#acf50ee1960461284c2bbf522d6b19be1">syncInterval_</a>);</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    }</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;  }</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;}</div><div class="ttc" id="classwangle_1_1LRUPersistentCache_html_aa405e907b62768fbb2fbc060b7a655bc"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#aa405e907b62768fbb2fbc060b7a655bc">wangle::LRUPersistentCache::stopSyncerCV_</a></div><div class="ttdeci">std::condition_variable stopSyncerCV_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00264">LRUPersistentCache.h:264</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a06a71ae938b18705e30af27497673a56"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a06a71ae938b18705e30af27497673a56">wangle::LRUPersistentCache::stopSyncer_</a></div><div class="ttdeci">bool stopSyncer_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00260">LRUPersistentCache.h:260</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_af246945baba03071238b1fad94beffa6"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#af246945baba03071238b1fad94beffa6">wangle::LRUPersistentCache::nSyncRetries_</a></div><div class="ttdeci">const int nSyncRetries_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00273">LRUPersistentCache.h:273</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a7c89180fae7c002ac23925ccce7b83bd"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">wangle::LRUPersistentCache::cache_</a></div><div class="ttdeci">LRUInMemoryCache&lt; K, V, MutexT &gt; cache_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00257">LRUPersistentCache.h:257</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_acf50ee1960461284c2bbf522d6b19be1"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#acf50ee1960461284c2bbf522d6b19be1">wangle::LRUPersistentCache::syncInterval_</a></div><div class="ttdeci">const std::chrono::milliseconds syncInterval_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00270">LRUPersistentCache.h:270</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a1f1d482dfe6a457aaf780ad7f3d28751"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a1f1d482dfe6a457aaf780ad7f3d28751">wangle::LRUPersistentCache::syncNow</a></div><div class="ttdeci">bool syncNow(CachePersistence&lt; K, V &gt; &amp;persistence)</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache-inl_8h_source.html#l00178">LRUPersistentCache-inl.h:178</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a5fa08e5f576df0a31c1fb54ab9ce115a"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a5fa08e5f576df0a31c1fb54ab9ce115a">wangle::LRUPersistentCache::getPersistence</a></div><div class="ttdeci">std::shared_ptr&lt; CachePersistence&lt; K, V &gt; &gt; getPersistence()</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache-inl_8h_source.html#l00206">LRUPersistentCache-inl.h:206</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_af43b3a33d3053cab6a7df84f752ffd4f"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#af43b3a33d3053cab6a7df84f752ffd4f">wangle::LRUPersistentCache::stopSyncerMutex_</a></div><div class="ttdeci">std::mutex stopSyncerMutex_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00262">LRUPersistentCache.h:262</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1f1d482dfe6a457aaf780ad7f3d28751"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::syncNow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwangle_1_1CachePersistence.html">CachePersistence</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>persistence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper to sync routine above that actualy does the serialization and writes to persistence.</p>
<dl class="section return"><dt>Returns</dt><dd>boolean, true on successful serialization and write to persistence, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00178">178</a> of file <a class="el" href="LRUPersistentCache-inl_8h_source.html">LRUPersistentCache-inl.h</a>.</p>

<p>References <a class="el" href="LRUPersistentCache_8h_source.html#l00257">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::cache_</a>, <a class="el" href="LRUPersistentCache_8h_source.html#l00061">wangle::CachePersistence&lt; K, V &gt;::getLastPersistedVersion()</a>, <a class="el" href="Base-inl_8h_source.html#l02567">folly::gen::move</a>, <a class="el" href="LRUPersistentCache_8h_source.html#l00049">wangle::CachePersistence&lt; K, V &gt;::persistVersionedData()</a>, and <a class="el" href="ClientProtocol_8cpp_source.html#l01005">version</a>.</p>

<p>Referenced by <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00130">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::oneShotSync()</a>, and <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00146">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::sync()</a>.</p>
<div class="fragment"><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                                          {</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;  <span class="comment">// check if we need to sync.  There is a chance that someone can</span></div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;  <span class="comment">// update cache_ between this check and the convert below, but that</span></div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;  <span class="comment">// is ok.  The persistence layer would have needed to update anyway</span></div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;  <span class="comment">// and will just get the latest version.</span></div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">cache_</a>.hasChangedSince(persistence.getLastPersistedVersion())) {</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    <span class="comment">// nothing to do</span></div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;  }</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;  <span class="comment">// serialize the current contents of cache under lock</span></div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;  <span class="keyword">auto</span> serializedCacheAndVersion = <a class="code" href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">cache_</a>.convertToKeyValuePairs();</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;  <span class="keywordflow">if</span> (!serializedCacheAndVersion) {</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    LOG(ERROR) &lt;&lt; <span class="stringliteral">&quot;Failed to convert cache for serialization.&quot;</span>;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  }</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;  <span class="keyword">auto</span>&amp; kvPairs = std::get&lt;0&gt;(serializedCacheAndVersion.value());</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;  <span class="keyword">auto</span>&amp; <a class="code" href="ClientProtocol_8cpp.html#abe1b247743d4691ae90a9b12b08cc176">version</a> = std::get&lt;1&gt;(serializedCacheAndVersion.value());</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;  <span class="keyword">auto</span> persisted =</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    persistence.persistVersionedData(<a class="code" href="namespacefolly_1_1gen.html#ac24ec252b1b738a40c274285527c193f">std::move</a>(kvPairs), version);</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;  <span class="keywordflow">return</span> persisted;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;}</div><div class="ttc" id="namespacefolly_1_1gen_html_ac24ec252b1b738a40c274285527c193f"><div class="ttname"><a href="namespacefolly_1_1gen.html#ac24ec252b1b738a40c274285527c193f">folly::gen::move</a></div><div class="ttdeci">constexpr detail::Map&lt; Move &gt; move</div><div class="ttdef"><b>Definition:</b> <a href="Base-inl_8h_source.html#l02567">Base-inl.h:2567</a></div></div>
<div class="ttc" id="ClientProtocol_8cpp_html_abe1b247743d4691ae90a9b12b08cc176"><div class="ttname"><a href="ClientProtocol_8cpp.html#abe1b247743d4691ae90a9b12b08cc176">version</a></div><div class="ttdeci">ProtocolVersion version</div><div class="ttdef"><b>Definition:</b> <a href="ClientProtocol_8cpp_source.html#l01005">ClientProtocol.cpp:1005</a></div></div>
<div class="ttc" id="classwangle_1_1LRUPersistentCache_html_a7c89180fae7c002ac23925ccce7b83bd"><div class="ttname"><a href="classwangle_1_1LRUPersistentCache.html#a7c89180fae7c002ac23925ccce7b83bd">wangle::LRUPersistentCache::cache_</a></div><div class="ttdeci">LRUInMemoryCache&lt; K, V, MutexT &gt; cache_</div><div class="ttdef"><b>Definition:</b> <a href="LRUPersistentCache_8h_source.html#l00257">LRUPersistentCache.h:257</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af45bb4c57317db72a11ab07dc60c3fb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename MutexT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::syncThreadMain </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00121">121</a> of file <a class="el" href="LRUPersistentCache-inl_8h_source.html">LRUPersistentCache-inl.h</a>.</p>

<p>References <a class="el" href="ThreadName_8cpp_source.html#l00109">folly::setThreadName()</a>, and <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00146">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::sync()</a>.</p>
<div class="fragment"><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;                                                                {</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  <a class="code" href="namespacefolly.html#a2e933f76070b83ef7519c9c2ac8a1117">folly::setThreadName</a>(<span class="stringliteral">&quot;lru-sync-thread&quot;</span>);</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;  <span class="keyword">auto</span> <span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>LRUPersistentCache&lt;K, V, MutexT&gt;*<span class="keyword">&gt;</span>(arg);</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;  <span class="keyword">self</span>-&gt;sync();</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;}</div><div class="ttc" id="namespacefolly_html_a2e933f76070b83ef7519c9c2ac8a1117"><div class="ttname"><a href="namespacefolly.html#a2e933f76070b83ef7519c9c2ac8a1117">folly::setThreadName</a></div><div class="ttdeci">bool setThreadName(std::thread::id tid, StringPiece name)</div><div class="ttdef"><b>Definition:</b> <a href="ThreadName_8cpp_source.html#l00109">ThreadName.cpp:109</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a7c89180fae7c002ac23925ccce7b83bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT = std::mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwangle_1_1LRUInMemoryCache.html">LRUInMemoryCache</a>&lt;K, V, MutexT&gt; <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::cache_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="LRUPersistentCache_8h_source.html#l00257">257</a> of file <a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a>.</p>

<p>Referenced by <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00112">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::hasPendingUpdates()</a>, <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00236">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::load()</a>, <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00130">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::oneShotSync()</a>, <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00090">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::put()</a>, <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00146">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::sync()</a>, and <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00178">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::syncNow()</a>.</p>

</div>
</div>
<a class="anchor" id="a016d852231aa66e1535cff9e0115c941"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT = std::mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classfolly_1_1Executor.html">folly::Executor</a>&gt; <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::executor_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="LRUPersistentCache_8h_source.html#l00292">292</a> of file <a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a>.</p>

<p>Referenced by <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00045">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::LRUPersistentCache()</a>, <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00090">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::put()</a>, and <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00069">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::~LRUPersistentCache()</a>.</p>

</div>
</div>
<a class="anchor" id="aaf611ef758be7996827c8b9544bf89d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT = std::mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic_flag <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::executorScheduled_ = ATOMIC_FLAG_INIT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="LRUPersistentCache_8h_source.html#l00267">267</a> of file <a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a>.</p>

<p>Referenced by <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00130">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::oneShotSync()</a>, and <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00090">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::put()</a>.</p>

</div>
</div>
<a class="anchor" id="a6045c5ff13560b2a3f3fcadb4ea641e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT = std::mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::steady_clock::time_point <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::lastExecutorScheduleTime_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="LRUPersistentCache_8h_source.html#l00276">276</a> of file <a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a>.</p>

<p>Referenced by <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00090">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::put()</a>.</p>

</div>
</div>
<a class="anchor" id="af246945baba03071238b1fad94beffa6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT = std::mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::nSyncRetries_ {<a class="el" href="namespacewangle_1_1client_1_1persistence.html#a221c3cb2f9657aec7b03222846a89eeb">client::persistence::DEFAULT_CACHE_SYNC_RETRIES</a>}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="LRUPersistentCache_8h_source.html#l00273">273</a> of file <a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a>.</p>

<p>Referenced by <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00130">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::oneShotSync()</a>, and <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00146">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::sync()</a>.</p>

</div>
</div>
<a class="anchor" id="a0bd97e6e8ad2e5e9100b0aa6fe625f41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT = std::mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::nSyncTries_ {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="LRUPersistentCache_8h_source.html#l00275">275</a> of file <a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a>.</p>

<p>Referenced by <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00130">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::oneShotSync()</a>.</p>

</div>
</div>
<a class="anchor" id="a6b1dc6b4eab04e0f55c0832aabe02ec1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT = std::mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classwangle_1_1CachePersistence.html">CachePersistence</a>&lt;K, V&gt; &gt; <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::persistence_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="LRUPersistentCache_8h_source.html#l00284">284</a> of file <a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a>.</p>

<p>Referenced by <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00206">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::getPersistence()</a>, <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00112">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::hasPendingUpdates()</a>, and <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00212">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::setPersistenceHelper()</a>.</p>

</div>
</div>
<a class="anchor" id="aff313d97b5c2f1d7779775e6ff4268a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT = std::mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MutexT <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::persistenceLock_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="LRUPersistentCache_8h_source.html#l00286">286</a> of file <a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a>.</p>

<p>Referenced by <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00206">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::getPersistence()</a>, <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00112">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::hasPendingUpdates()</a>, and <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00212">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::setPersistenceHelper()</a>.</p>

</div>
</div>
<a class="anchor" id="a06a71ae938b18705e30af27497673a56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT = std::mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::stopSyncer_ {false}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="LRUPersistentCache_8h_source.html#l00260">260</a> of file <a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a>.</p>

<p>Referenced by <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00146">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::sync()</a>, and <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00069">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::~LRUPersistentCache()</a>.</p>

</div>
</div>
<a class="anchor" id="aa405e907b62768fbb2fbc060b7a655bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT = std::mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::condition_variable <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::stopSyncerCV_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="LRUPersistentCache_8h_source.html#l00264">264</a> of file <a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a>.</p>

<p>Referenced by <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00146">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::sync()</a>, and <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00069">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::~LRUPersistentCache()</a>.</p>

</div>
</div>
<a class="anchor" id="af43b3a33d3053cab6a7df84f752ffd4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT = std::mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="OpenSSLThreading_8cpp.html#a1be3f7fa26e4521098de5f1ec0f865f3">std::mutex</a> <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::stopSyncerMutex_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="LRUPersistentCache_8h_source.html#l00262">262</a> of file <a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a>.</p>

<p>Referenced by <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00146">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::sync()</a>, and <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00069">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::~LRUPersistentCache()</a>.</p>

</div>
</div>
<a class="anchor" id="a65cdae47124ba26ac2c66eecb0c117ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT = std::mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::thread <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::syncer_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="LRUPersistentCache_8h_source.html#l00289">289</a> of file <a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a>.</p>

<p>Referenced by <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00045">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::LRUPersistentCache()</a>, and <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00069">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::~LRUPersistentCache()</a>.</p>

</div>
</div>
<a class="anchor" id="acf50ee1960461284c2bbf522d6b19be1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT = std::mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::chrono::milliseconds <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::syncInterval_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">      <a class="code" href="namespacewangle_1_1client_1_1persistence.html#a9a4ecd2b5d1866ccb2bc23b1113f921b">client::persistence::DEFAULT_CACHE_SYNC_INTERVAL</a>}</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="LRUPersistentCache_8h_source.html#l00270">270</a> of file <a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a>.</p>

<p>Referenced by <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00090">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::put()</a>, and <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00146">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::sync()</a>.</p>

</div>
</div>
<a class="anchor" id="a7f8c5d1001ad1b00f1b93186aa3a4fb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename MutexT = std::mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classwangle_1_1LRUPersistentCache.html">wangle::LRUPersistentCache</a>&lt; K, V, MutexT &gt;::syncOnDestroy_ {false}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="LRUPersistentCache_8h_source.html#l00279">279</a> of file <a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a>.</p>

<p>Referenced by <a class="el" href="LRUPersistentCache-inl_8h_source.html#l00069">wangle::LRUPersistentCache&lt; K, V, MutexT &gt;::~LRUPersistentCache()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>proxygen/wangle/wangle/client/persistence/<a class="el" href="LRUPersistentCache_8h_source.html">LRUPersistentCache.h</a></li>
<li>proxygen/wangle/wangle/client/persistence/<a class="el" href="LRUPersistentCache-inl_8h_source.html">LRUPersistentCache-inl.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacewangle.html">wangle</a></li><li class="navelem"><a class="el" href="classwangle_1_1LRUPersistentCache.html">LRUPersistentCache</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
