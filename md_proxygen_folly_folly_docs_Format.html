<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: `folly/Format.h`</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_proxygen_folly_folly_docs_Format.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">`folly/Format.h` </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><code>folly/Format.h</code> provides a fast, powerful, type-safe, flexible facility for formatting text, using a specification language similar to Python's <a href="http://docs.python.org/library/string.html#formatstrings">str.format</a>. By default, it can format strings, numbers (integral and floating point), and dynamically-typed <code><a class="el" href="structfolly_1_1dynamic.html">folly::dynamic</a></code> objects, and can extract values from random-access containers and string-keyed maps. In many cases, <code>format</code> is faster than <code>sprintf</code> as well as being fully type-safe.</p>
<p>To use <code>format</code>, you need to be using gcc 4.6 or later. You'll want to include <code>folly/Format.h</code>.</p>
<h3>Overview</h3>
<hr/>
<p>Here are some code samples to get started:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;using folly::format;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;using folly::sformat;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;using folly::vformat;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;using folly::svformat;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;// Objects produced by format() can be streamed without creating</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;// an intermediary string; {} yields the next argument using default</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;// formatting.</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;std::cout &lt;&lt; format(&quot;The answers are {} and {}&quot;, 23, 42);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;// =&gt; &quot;The answers are 23 and 42&quot;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;// If you just want the string, though, you&#39;re covered.</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;std::string result = sformat(&quot;The answers are {} and {}&quot;, 23, 42);</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;// =&gt; &quot;The answers are 23 and 42&quot;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;// To insert a literal &#39;{&#39; or &#39;}&#39;, just double it.</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;std::cout &lt;&lt; format(&quot;{} {{}} {{{}}}&quot;, 23, 42);</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;// =&gt; &quot;23 {} {42}&quot;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;// Arguments can be referenced out of order, even multiple times</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;std::cout &lt;&lt; format(&quot;The answers are {1}, {0}, and {1} again&quot;, 23, 42);</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;// =&gt; &quot;The answers are 42, 23, and 42 again&quot;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;// It&#39;s perfectly fine to not reference all arguments</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;std::cout &lt;&lt; format(&quot;The only answer is {1}&quot;, 23, 42);</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;// =&gt; &quot;The only answer is 42&quot;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;// Values can be extracted from indexable containers</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;// (random-access sequences and integral-keyed maps), and also from</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;// string-keyed maps</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;std::vector&lt;int&gt; v {23, 42};</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;std::map&lt;std::string, std::string&gt; m { {&quot;what&quot;, &quot;answer&quot;} };</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;std::cout &lt;&lt; format(&quot;The only {1[what]} is {0[1]}&quot;, v, m);</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;// =&gt; &quot;The only answer is 42&quot;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;// If you only have one container argument, vformat makes the syntax simpler</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;std::map&lt;std::string, std::string&gt; m { {&quot;what&quot;, &quot;answer&quot;}, {&quot;value&quot;, &quot;42&quot;} };</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;std::cout &lt;&lt; vformat(&quot;The only {what} is {value}&quot;, m);</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;// =&gt; &quot;The only answer is 42&quot;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;// same as</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;std::cout &lt;&lt; format(&quot;The only {0[what]} is {0[value]}&quot;, m);</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;// =&gt; &quot;The only answer is 42&quot;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;// And if you just want the string,</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;std::string result = svformat(&quot;The only {what} is {value}&quot;, m);</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;// =&gt; &quot;The only answer is 42&quot;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;std::string result = sformat(&quot;The only {0[what]} is {0[value]}&quot;, m);</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;// =&gt; &quot;The only answer is 42&quot;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;// {} works for vformat too</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;std::vector&lt;int&gt; v {42, 23};</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;std::cout &lt;&lt; vformat(&quot;{} {}&quot;, v);</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;// =&gt; &quot;42 23&quot;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;// format and vformat work with pairs and tuples</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;std::tuple&lt;int, std::string, int&gt; t {42, &quot;hello&quot;, 23};</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;std::cout &lt;&lt; vformat(&quot;{0} {2} {1}&quot;, t);</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;// =&gt; &quot;42 23 hello&quot;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;// Format supports width, alignment, arbitrary fill, and various</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;// format specifiers, with meanings similar to printf</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;// &quot;X&lt;10&quot;: fill with &#39;X&#39;, left-align (&#39;&lt;&#39;), width 10</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;std::cout &lt;&lt; format(&quot;{:X&lt;10} {}&quot;, &quot;hello&quot;, &quot;world&quot;);</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;// =&gt; &quot;helloXXXXX world&quot;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;// Field width may be a runtime value rather than part of the format string</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;int x = 6;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;std::cout &lt;&lt; format(&quot;{:-^*}&quot;, x, &quot;hi&quot;);</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;// =&gt; &quot;--hi--&quot;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;// Explicit arguments work with dynamic field width, as long as indexes are</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;// given for both the value and the field width.</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;std::cout &lt;&lt; format(&quot;{2:+^*0}&quot;,</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;9, &quot;unused&quot;, 456); // =&gt; &quot;+++456+++&quot;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;// Format supports printf-style format specifiers</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;std::cout &lt;&lt; format(&quot;{0:05d} decimal = {0:04x} hex&quot;, 42);</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;// =&gt; &quot;00042 decimal = 002a hex&quot;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;// Formatter objects may be written to a string using folly::to or</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;// folly::toAppend (see folly/Conv.h), or by calling their appendTo(),</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;// str(), and fbstr() methods</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;std::string s = format(&quot;The only answer is {}&quot;, 42).str();</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;std::cout &lt;&lt; s;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;// =&gt; &quot;The only answer is 42&quot;</div></div><!-- fragment --><h3>Format string syntax</h3>
<hr/>
<p>Format string (<code>format</code>): <code>"{" [arg_index] ["[" key "]"] [":" format_spec] "}"</code></p>
<ul>
<li><code>arg_index</code>: index of argument to format; default = next argument. Note that a format string may have either default argument indexes or non-default argument indexes, but not both (to avoid confusion).</li>
<li><code>key</code>: if the argument is a container (C-style array or pointer, <code>std::array</code>, vector, deque, map), you may use this to select the element to format; works with random-access sequences and integer- and string-keyed maps. Multiple level keys work as well, with components separated with "."; for example, given <code>map&lt;string, map&lt;string, string&gt;&gt; m</code>, <code>{[foo.bar]}</code> selects <code>m["foo"]["bar"]</code>.</li>
<li><code>format_spec</code>: format specification, see below</li>
</ul>
<p>Format string (<code>vformat</code>): <code>"{" [ key ] [":" format_spec] "}"</code></p>
<ul>
<li><code>key</code>: select the argument to format from the container argument; works with random-access sequences and integer- and string-keyed maps. Multiple level keys work as well, with components separated with "."; for example, given <code>map&lt;string, map&lt;string, string&gt;&gt; m</code>, <code>{foo.bar}</code> selects <code>m["foo"]["bar"]</code>.</li>
<li><code>format_spec</code>: format specification, see below</li>
</ul>
<p>Format specification: <code>[[fill] align] [sign] ["#"] ["0"] [width] [","] ["." precision] ["."] [type]</code></p>
<ul>
<li><code>fill</code> (may only be specified if <code>align</code> is also specified): pad with this character ('' (space) or '<code>0</code>' (zero) might be useful; space is default)</li>
<li><code>align</code>: one of '<code>&lt;</code>', '<code>&gt;</code>', '<code>=</code>', '<code>^</code>':<ul>
<li>'<code>&lt;</code>': left-align (default for most objects)</li>
<li>'<code>&gt;</code>': right-align (default for numbers)</li>
<li>'<code>=</code>': pad after sign, but before significant digits; used to print <code>-0000120</code>; only valid for numbers</li>
<li>'<code>^</code>': center</li>
</ul>
</li>
<li><code>sign</code>: one of '<code>+</code>', '<code>-</code>', ' ' (space) (only valid for numbers)<ul>
<li>'<code>+</code>': output '<code>+</code>' if positive or zero, '<code>-</code>' if negative</li>
<li>'<code>-</code>': output '<code>-</code>' if negative, nothing otherwise (default)</li>
<li>'' (space): output '' (space) if positive or zero, '<code>-</code>' if negative</li>
</ul>
</li>
<li>'<code>#</code>': output base prefix (<code>0</code> for octal, <code>0b</code> or <code>0B</code> for binary, <code>0x</code> or <code>0X</code> for hexadecimal; only valid for integers)</li>
<li>'<code>0</code>': 0-pad after sign, same as specifying "`0=`" as the <code>fill</code> and <code>align</code> parameters (only valid for numbers)</li>
<li><code>width</code>: minimum field width. May be '<code>*</code>' to indicate that the field width is given by an argument. Defaults to the next argument (preceding the value to be formatted) but an explicit argument index may be given following the '<code>*</code>'. Not supported in <code><a class="el" href="namespacefolly.html#a5c08fab8c53c398bb0b6753913c3ce8e">vformat()</a></code>.</li>
<li>'<code>,</code>' (comma): output comma as thousands' separator (only valid for integers, and only for decimal output)</li>
<li><code>precision</code> (not allowed for integers):<ul>
<li>for floating point values, number of digits after decimal point ('<code>f</code>' or '<code>F</code>' presentation) or number of significant digits ('<code>g</code>' or '<code>G</code>')</li>
<li>for others, maximum field size (truncate subsequent characters)</li>
</ul>
</li>
<li>'<code>.</code>' (when used after precision or in lieu of precison): Forces a trailing decimal point to make it clear this is a floating point value.</li>
<li><code>type</code>: presentation format, see below</li>
</ul>
<p>Presentation formats:</p>
<ul>
<li>Strings (<code><a class="el" href="namespacefolly.html#af8d3e3eb9accef5470823e6353f60140">folly::StringPiece</a></code>, <code>std::string</code>, <code><a class="el" href="namespacefolly.html#a4201ff5d4021043b963c128794f417a3">folly::fbstring</a></code>, <code>const char*</code>):<ul>
<li>'<code>s</code>' (default)</li>
</ul>
</li>
<li>Integers:<ul>
<li>'<code>b</code>': output in binary (base 2) ("`0b`" prefix if '<code>#</code>' specified)</li>
<li>'<code><a class="el" href="structB.html">B</a></code>': output in binary (base 2) ("`0B`" prefix if '<code>#</code>' specified)</li>
<li>'<code>c</code>': output as a character (cast to <code>char</code>)</li>
<li>'<code>d</code>': output in decimal (base 10) (default)</li>
<li>'<code>o</code>': output in octal (base 8)</li>
<li>'<code>O</code>': output in octal (base 8) (same as '<code>o</code>')</li>
<li>'<code>x</code>': output in hexadecimal (base 16) (lower-case digits above 9)</li>
<li>'<code><a class="el" href="structX.html">X</a></code>': output in hexadecimal (base 16) (upper-case digits above 9)</li>
<li>'<code>n</code>': locale-aware output (currently same as '<code>d</code>')</li>
</ul>
</li>
<li><code>bool</code>:<ul>
<li>default: output "`true`" or "`false`" as strings</li>
<li>integer presentations allowed as well</li>
</ul>
</li>
<li><code>char</code>:<ul>
<li>same as other integers, but default is '<code>c</code>' instead of '<code>d</code>'</li>
</ul>
</li>
<li>Floating point (<code>float</code>, <code>double</code>; <code>long double</code> is not implemented):<ul>
<li>'<code>e</code>': scientific notation using '<code>e</code>' as exponent character</li>
<li>'<code>E</code>': scientific notation using '<code>E</code>' as exponent character</li>
<li>'<code>f</code>': fixed point</li>
<li>'<code>F</code>': fixed point (same as '<code>f</code>')</li>
<li>'<code>g</code>': general; use either '<code>f</code>' or '<code>e</code>' depending on magnitude (default)</li>
<li>'<code>G</code>': general; use either '<code>f</code>' or '<code>E</code>' depending on magnitude</li>
<li>'<code>n</code>': locale-aware version of '<code>g</code>' (currently same as '<code>g</code>')</li>
<li>'<code>%</code>': percentage: multiply by 100 then display as '<code>f</code>'</li>
</ul>
</li>
</ul>
<h3>Extension</h3>
<hr/>
<p>You can extend <code>format</code> for your own class by providing a specialization for <code><a class="el" href="classfolly_1_1FormatValue.html">folly::FormatValue</a></code>. See <code>folly/Format.h</code> and <code>folly/FormatArg.h</code> for details, and the existing specialization for <code><a class="el" href="structfolly_1_1dynamic.html">folly::dynamic</a></code> in <code>folly/dynamic-inl.h</code> for an implementation example. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
