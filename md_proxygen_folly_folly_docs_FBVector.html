<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: `folly/FBVector.h`</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_proxygen_folly_folly_docs_FBVector.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">`folly/FBVector.h` </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Simply replacing <code>std::vector</code> with <code><a class="el" href="classfolly_1_1fbvector.html">folly::fbvector</a></code> (after having included the <code>folly/FBVector.h</code> header file) will improve the performance of your C++ code using vectors with common coding patterns. The improvements are always non-negative, almost always measurable, frequently significant, sometimes dramatic, and occasionally spectacular.</p>
<h3>Sample</h3>
<hr/>
 <pre class="fragment">folly::fbvector&lt;int&gt; numbers({0, 1, 2, 3});
numbers.reserve(10);
for (int i = 4; i &lt; 10; i++) {
  numbers.push_back(i * 2);
}
assert(numbers[6] == 12);
</pre><h3>Motivation</h3>
<hr/>
<p><code>std::vector</code> is the stalwart abstraction many use for dynamically-allocated arrays in C++. It is also the best known and most used of all containers. It may therefore seem a surprise that <code>std::vector</code> leaves important - and sometimes vital - efficiency opportunities on the table. This document explains how our own drop-in abstraction <code>fbvector</code> improves key performance aspects of <code>std::vector</code>. Refer to <a class="el" href="FBVectorTest_8cpp.html">folly/test/FBVectorTest.cpp</a> for a few benchmarks.</p>
<h3>Memory Handling</h3>
<hr/>
<p>It is well known that <code>std::vector</code> grows exponentially (at a constant factor) in order to avoid quadratic growth performance. The trick is choosing a good factor. Any factor greater than 1 ensures O(1) amortized append complexity towards infinity. But a factor that's too small (say, 1.1) causes frequent vector reallocation, and one that's too large (say, 3 or 4) forces the vector to consume much more memory than needed.</p>
<p>The initial HP implementation by Stepanov used a growth factor of 2; i.e., whenever you'd <code>push_back</code> into a vector without there being room, it would double the current capacity. This was not a good choice: it can be mathematically proven that a growth factor of 2 is rigorously the <em>worst</em> possible because it never allows the vector to reuse any of its previously-allocated memory. Despite other compilers reducing the growth factor to 1.5, gcc has staunchly maintained its factor of</p><ol type="1">
<li>This makes <code>std::vector</code> cache- unfriendly and memory manager unfriendly.</li>
</ol>
<p>To see why that's the case, consider a large vector of capacity C. When there's a request to grow the vector, the vector (assuming no in-place resizing, see the appropriate section in this document) will allocate a chunk of memory next to its current chunk, copy its existing data to the new chunk, and then deallocate the old chunk. So now we have a chunk of size C followed by a chunk of size k * C. Continuing this process we'll then have a chunk of size k * k * C to the right and so on. That leads to a series of the form (using ^^ for power): </p><pre class="fragment">C, C*k,  C*k^^2, C*k^^3, ...
</pre><p>If we choose k = 2 we know that every element in the series will be strictly larger than the sum of all previous ones because of the remarkable equality: </p><pre class="fragment">1 + 2^^1 + 2^^2 + 2^^3... + 2^^n = 2^^(n+1) - 1
</pre><p>This means that any new chunk requested will be larger than all previously used chunks combined, so the vector must crawl forward in memory; it can't move back to its deallocated chunks. But any number smaller than 2 guarantees that you'll at some point be able to reuse the previous chunks. For instance, choosing 1.5 as the factor allows memory reuse after 4 reallocations; 1.45 allows memory reuse after 3 reallocations; and 1.3 allows reuse after only 2 reallocations.</p>
<p>Of course, the above makes a number of simplifying assumptions about how the memory allocator works, but definitely you don't want to choose the theoretically absolute worst growth factor. <code>fbvector</code> uses a growth factor of 1.5. That does not impede good performance at small sizes because of the way <code>fbvector</code> cooperates with jemalloc (below).</p>
<h3>The jemalloc Connection</h3>
<hr/>
<p>Virtually all modern allocators allocate memory in fixed-size quanta that are chosen to minimize management overhead while at the same time offering good coverage at low slack. For example, an allocator may choose blocks of doubling size (32, 64, 128, &lt;t_co&gt;, ...) up to 4096, and then blocks of size multiples of a page up until 1MB, and then 512KB increments and so on.</p>
<p>As discussed above, <code>std::vector</code> also needs to (re)allocate in quanta. The next quantum is usually defined in terms of the current size times the infamous growth constant. Because of this setup, <code>std::vector</code> has some slack memory at the end much like an allocated block has some slack memory at the end.</p>
<p>It doesn't take a rocket surgeon to figure out that an allocator- aware <code>std::vector</code> would be a marriage made in heaven: the vector could directly request blocks of "perfect" size from the allocator so there would be virtually no slack in the allocator. Also, the entire growth strategy could be adjusted to work perfectly with allocator's own block growth strategy. That's exactly what <code>fbvector</code> does - it automatically detects the use of jemalloc and adjusts its reallocation strategy accordingly.</p>
<p>But wait, there's more. Many memory allocators do not support in- place reallocation, although most of them could. This comes from the now notorious design of <code>realloc()</code> to opaquely perform either in-place reallocation or an allocate-memcpy-deallocate cycle. Such lack of control subsequently forced all clib-based allocator designs to avoid in-place reallocation, and that includes C++'s <code>new</code> and <code>std::allocator</code>. This is a major loss of efficiency because an in-place reallocation, being very cheap, may mean a much less aggressive growth strategy. In turn that means less slack memory and faster reallocations.</p>
<h3>Object Relocation</h3>
<hr/>
<p>One particularly sensitive topic about handling C++ values is that they are all conservatively considered <em>non- relocatable</em>. In contrast, a relocatable value would preserve its invariant even if its bits were moved arbitrarily in memory. For example, an <code>int32</code> is relocatable because moving its 4 bytes would preserve its actual value, so the address of that value does not "matter" to its integrity.</p>
<p>C++'s assumption of non-relocatable values hurts everybody for the benefit of a few questionable designs. The issue is that moving a C++ object "by the book" entails (a) creating a new copy from the existing value; (b) destroying the old value. This is quite vexing and violates common sense; consider this hypothetical conversation between Captain Picard and an incredulous alien:</p>
<p>Incredulous Alien: "So, this teleporter, how does it work?"<br />
 Picard: "It beams people and arbitrary matter from one place to
another."<br />
 Incredulous Alien: "Hmmm... is it safe?"<br />
 Picard: "Yes, but earlier models were a hassle. They'd clone the person to another location. Then the teleporting chief would have to shoot the original. Ask O'Brien, he was an intern during those times. <a class="el" href="structA.html">A</a> bloody mess, that's what it was."</p>
<p>Only a tiny minority of objects are genuinely non-relocatable:</p>
<ul>
<li><p class="startli">Objects that use internal pointers, e.g.:</p>
<p class="startli">class Ew { char buffer[1024]; char * pointerInsideBuffer; public: Ew() : pointerInsideBuffer(buffer) {} ... }</p>
</li>
<li>Objects that need to update "observers" that store pointers to them.</li>
</ul>
<p>The first class of designs can always be redone at small or no cost in efficiency. The second class of objects should not be values in the first place - they should be allocated with <code>new</code> and manipulated using (smart) pointers. It is highly unusual for a value to have observers that alias pointers to it.</p>
<p>Relocatable objects are of high interest to <code>std::vector</code> because such knowledge makes insertion into the vector and vector reallocation considerably faster: instead of going to Picard's copy-destroy cycle, relocatable objects can be moved around simply by using <code>memcpy</code> or <code>memmove</code>. This optimization can yield arbitrarily high wins in efficiency; for example, it transforms <code>vector&lt; vector&lt;double&gt; &gt;</code> or <code>vector&lt; hash_map&lt;int, string&gt; &gt;</code> from risky liabilities into highly workable compositions.</p>
<p>In order to allow fast relocation without risk, <code>fbvector</code> uses a trait <code><a class="el" href="structfolly_1_1IsRelocatable.html">folly::IsRelocatable</a></code> defined in <code>"folly/Traits.h"</code>. By default, <code>folly::IsRelocatable::value</code> conservatively yields false. If you know that your type <code><a class="el" href="classWidget.html">Widget</a></code> is in fact relocatable, go right after <code><a class="el" href="classWidget.html">Widget</a></code>'s definition and write this: </p><pre class="fragment">// at global namespace level
namespace folly {
  struct IsRelocatable&lt;Widget&gt; : boost::true_type {};
}
</pre><p>If you don't do this, <code>fbvector&lt;<a class="el" href="classWidget.html">Widget</a>&gt;</code> will fail to compile with a <code>static_assert</code>.</p>
<h3>Miscellaneous</h3>
<hr/>
<p><code>fbvector</code> uses a careful implementation all around to make sure it doesn't lose efficiency through the cracks. Some future directions may be in improving raw memory copying (<code>memcpy</code> is not an intrinsic in gcc and does not work terribly well for large chunks) and in furthering the collaboration with jemalloc. Have fun! </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
