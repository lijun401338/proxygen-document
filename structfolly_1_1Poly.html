<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: folly::Poly&lt; I &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structfolly_1_1Poly.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structfolly_1_1Poly-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">folly::Poly&lt; I &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="PolyDetail_8h_source.html">PolyDetail.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for folly::Poly&lt; I &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structfolly_1_1Poly.png" usemap="#folly::Poly_3C_20I_20_3E_map" alt=""/>
  <map id="folly::Poly_3C_20I_20_3E_map" name="folly::Poly&lt; I &gt;_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0b5695e6f2e2946038b4b82ff8580137"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfolly_1_1Poly.html#a0b5695e6f2e2946038b4b82ff8580137">Poly</a> ()=default</td></tr>
<tr class="separator:a0b5695e6f2e2946038b4b82ff8580137"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class I&gt;<br />
struct folly::Poly&lt; I &gt;</h3>

<p><code><a class="el" href="structfolly_1_1Poly.html">Poly</a></code> is a class template that makes it relatively easy to define a type-erasing polymorphic object wrapper.</p>
<dl class="section user"><dt>Type-erasure</dt><dd></dd></dl>
<dl class="section user"><dt></dt><dd><code>std::function</code> is one example of a type-erasing polymorphic object wrapper; <code><a class="el" href="classfolly_1_1exception__wrapper.html">folly::exception_wrapper</a></code> is another. Type-erasure is often used as an alternative to dynamic polymorphism via inheritance-based virtual dispatch. The distinguishing characteristic of type-erasing wrappers are: <ul>
<li><b>Duck typing:</b> Types do not need to inherit from an abstract base class in order to be assignable to a type-erasing wrapper; they merely need to satisfy a particular interface. </li>
<li><b>Value semantics:</b> Type-erasing wrappers are objects that can be passed around <em>by value</em>. This is in contrast to abstract base classes which must be passed by reference or by pointer or else suffer from <em>slicing</em>, which causes them to lose their polymorphic behaviors. Reference semantics make it difficult to reason locally about code. </li>
<li><b>Automatic memory management:</b> When dealing with inheritance-based dynamic polymorphism, it is often necessary to allocate and manage objects on the heap. This leads to a proliferation of <code><a class="el" href="classshared__ptr.html">shared_ptr</a></code>s and <code>unique_ptr</code>s in APIs, complicating their point-of-use. APIs that take type-erasing wrappers, on the other hand, can often store small objects in-situ, with no dynamic allocation. The memory management, if any, is handled for you, and leads to cleaner APIs: consumers of your API don't need to pass <code><a class="el" href="classshared__ptr.html">shared_ptr</a>&lt;AbstractBase&gt;</code>; they can simply pass any object that satisfies the interface you require. (<code>std::function</code> is a particularly compelling example of this benefit. Far worse would be an inheritance-based callable solution like <code><a class="el" href="classshared__ptr.html">shared_ptr</a>&lt;ICallable&lt;void(int)&gt;&gt;</code>. )</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Example: Defining a type-erasing function wrapper with folly::Poly</dt><dd></dd></dl>
<dl class="section user"><dt></dt><dd>Defining a polymorphic wrapper with <code><a class="el" href="structfolly_1_1Poly.html">Poly</a></code> is a matter of defining two things: <ul>
<li>An <em>interface</em>, consisting of public member functions, and </li>
<li><a class="el" href="structA.html">A</a> <em>mapping</em> from a concrete type to a set of member function bindings.</li>
</ul>
Below is a (heavily commented) example of a simple implementation of a <code>std::function</code>-like polymorphic wrapper. Its interface has only a simgle member function: <code>operator()</code> <pre class="fragment">// An interface for a callable object of a particular signature, Fun
// (most interfaces don't need to be templates, FWIW).
template &lt;class Fun&gt;
struct IFunction;

template &lt;class R, class... As&gt;
struct IFunction&lt;R(As...)&gt; {
  // An interface is defined as a nested class template called
  // Interface that takes a single template parameter, Base, from
  // which it inherits.
  template &lt;class Base&gt;
  struct Interface : Base {
    // The Interface has public member functions. These become the
    // public interface of the resulting Poly instantiation.
    // (Implementation note: Poly&lt;IFunction&lt;Sig&gt;&gt; will publicly
    // inherit from this struct, which is what gives it the right
    // member functions.)
    R operator()(As... as) const {
      // The definition of each member function in your interface will
      // always consist of a single line dispatching to
      // folly::poly_call&lt;N&gt;. The "N" corresponds to the N-th member
      // function in the list of member function bindings, Members,
      // defined below. The first argument will always be *this, and the
      // rest of the arguments should simply forward (if necessary) the
      // member function's arguments.
      return static_cast&lt;R&gt;(
          folly::poly_call&lt;0&gt;(*this, std::forward&lt;As&gt;(as)...));
    }
  };

  // The "Members" alias template is a comma-separated list of bound
  // member functions for a given concrete type "T". The
  // "FOLLY_POLY_MEMBERS" macro accepts a comma-separated list, and the
  // (optional) "FOLLY_POLY_MEMBER" macro lets you disambiguate overloads
  // by explicitly specifying the function signature the target member
  // function should have. In this case, we require "T" to have a
  // function call operator with the signature `R(As...) const`.
  //
  // If you are using a C++17-compatible compiler, you can do away with
  // the macros and write this as:
  //
  //   template &lt;class T&gt;
  //   using Members = folly::PolyMembers&lt;
  //       folly::sig&lt;R(As...) const&gt;(&amp;T::operator())&gt;;
  //
  // And since `folly::sig` is only needed for disambiguation in case of
  // overloads, if you are not concerned about objects with overloaded
  // function call operators, it could be further simplified to:
  //
  //   template &lt;class T&gt;
  //   using Members = folly::PolyMembers&lt;&amp;T::operator()&gt;;
  //
  template &lt;class T&gt;
  using Members = FOLLY_POLY_MEMBERS(
      FOLLY_POLY_MEMBER(R(As...) const, &amp;T::operator()));
};

// Now that we have defined the interface, we can pass it to Poly to
// create our type-erasing wrapper:
template &lt;class Fun&gt;
using Function = Poly&lt;IFunction&lt;Fun&gt;&gt;;
</pre></dd></dl>
<dl class="section user"><dt></dt><dd>Given the above definition of <code><a class="el" href="classfolly_1_1Function.html">Function</a></code>, users can now initialize instances of (say) <code><a class="el" href="classfolly_1_1Function.html">Function</a>&lt;int(int, int)&gt;</code> with function objects like <code>std::plus&lt;int&gt;</code> and <code>std::multiplies&lt;int&gt;</code>, as below: <pre class="fragment">Function&lt;int(int, int)&gt; fun = std::plus&lt;int&gt;{};
assert(5 == fun(2, 3));
fun = std::multiplies&lt;int&gt;{};
assert(6 = fun(2, 3));
</pre></dd></dl>
<dl class="section user"><dt>Defining an interface with C++17</dt><dd></dd></dl>
<dl class="section user"><dt></dt><dd>With C++17, defining an interface to be used with <code><a class="el" href="structfolly_1_1Poly.html">Poly</a></code> is fairly straightforward. As in the <code><a class="el" href="classfolly_1_1Function.html">Function</a></code> example above, there is a struct with a nested <code><a class="el" href="classInterface.html">Interface</a></code> class template and a nested <code>Members</code> alias template. No macros are needed with C++17. </dd></dl>
<dl class="section user"><dt></dt><dd>Imagine we were defining something like a Java-style iterator. If we are using a C++17 compiler, our interface would look something like this: <pre class="fragment">template &lt;class Value&gt;
struct IJavaIterator {
  template &lt;class Base&gt;
  struct Interface : Base {
    bool Done() const { return folly::poly_call&lt;0&gt;(*this); }
    Value Current() const { return folly::poly_call&lt;1&gt;(*this); }
    void Next() { folly::poly_call&lt;2&gt;(*this); }
  };
  // NOTE: This works in C++17 only:
  template &lt;class T&gt;
  using Members = folly::PolyMembers&lt;&amp;T::Done, &amp;T::Current, &amp;T::Next&gt;;
};

template &lt;class Value&gt;
using JavaIterator = Poly&lt;IJavaIterator&gt;;
</pre></dd></dl>
<dl class="section user"><dt></dt><dd>Given the above definition, <code>JavaIterator&lt;int&gt;</code> can be used to hold instances of any type that has <code>Done</code>, <code>Current</code>, and <code>Next</code> member functions with the correct (or compatible) signatures.</dd></dl>
<dl class="section user"><dt></dt><dd>The presence of overloaded member functions complicates this picture. Often, property members are faked in C++ with <code>const</code> and non-<code>const</code> member function overloads, like in the interface specified below: <pre class="fragment">struct IIntProperty {
  template &lt;class Base&gt;
  struct Interface : Base {
    int Value() const { return folly::poly_call&lt;0&gt;(*this); }
    void Value(int i) { folly::poly_call&lt;1&gt;(*this, i); }
  };
  // NOTE: This works in C++17 only:
  template &lt;class T&gt;
  using Members = folly::PolyMembers&lt;
    folly::sig&lt;int() const&gt;(&amp;T::Value),
    folly::sig&lt;void(int)&gt;(&amp;T::Value)&gt;;
};

using IntProperty = Poly&lt;IIntProperty&gt;;
</pre></dd></dl>
<dl class="section user"><dt></dt><dd>Now, any object that has <code>Value</code> members of compatible signatures can be assigned to instances of <code>IntProperty</code> object. Note how <code><a class="el" href="namespacefolly.html#a846f42e996d3c9b0252f6cc3907bc08f">folly::sig</a></code> is used to disambiguate the overloads of <code>&amp;T::Value</code>.</dd></dl>
<dl class="section user"><dt>Defining an interface with C++14</dt><dd></dd></dl>
<dl class="section user"><dt></dt><dd>In C++14, the nice syntax above doesn't work, so we have to resort to macros. The two examples above would look like this: <pre class="fragment">template &lt;class Value&gt;
struct IJavaIterator {
  template &lt;class Base&gt;
  struct Interface : Base {
    bool Done() const { return folly::poly_call&lt;0&gt;(*this); }
    Value Current() const { return folly::poly_call&lt;1&gt;(*this); }
    void Next() { folly::poly_call&lt;2&gt;(*this); }
  };
  // NOTE: This works in C++14 and C++17:
  template &lt;class T&gt;
  using Members = FOLLY_POLY_MEMBERS(&amp;T::Done, &amp;T::Current, &amp;T::Next);
};

template &lt;class Value&gt;
using JavaIterator = Poly&lt;IJavaIterator&gt;;
</pre></dd></dl>
<dl class="section user"><dt></dt><dd>and <pre class="fragment">struct IIntProperty {
  template &lt;class Base&gt;
  struct Interface : Base {
    int Value() const { return folly::poly_call&lt;0&gt;(*this); }
    void Value(int i) { return folly::poly_call&lt;1&gt;(*this, i); }
  };
  // NOTE: This works in C++14 and C++17:
  template &lt;class T&gt;
  using Members = FOLLY_POLY_MEMBERS(
    FOLLY_POLY_MEMBER(int() const, &amp;T::Value),
    FOLLY_POLY_MEMBER(void(int), &amp;T::Value));
};

using IntProperty = Poly&lt;IIntProperty&gt;;
</pre></dd></dl>
<dl class="section user"><dt>Extending interfaces</dt><dd></dd></dl>
<dl class="section user"><dt></dt><dd>One typical advantage of inheritance-based solutions to runtime polymorphism is that one polymorphic interface could extend another through inheritance. The same can be accomplished with type-erasing polymorphic wrappers. In the <code><a class="el" href="structfolly_1_1Poly.html">Poly</a></code> library, you can use <code><a class="el" href="structfolly_1_1PolyExtends.html">folly::PolyExtends</a></code> to say that one interface extends another. <pre class="fragment">struct IFoo {
  template &lt;class Base&gt;
  struct Interface : Base {
    void Foo() const { return folly::poly_call&lt;0&gt;(*this); }
  };
  template &lt;class T&gt;
  using Members = FOLLY_POLY_MEMBERS(&amp;T::Foo);
};

// The IFooBar interface extends the IFoo interface
struct IFooBar : PolyExtends&lt;IFoo&gt; {
  template &lt;class Base&gt;
  struct Interface : Base {
    void Bar() const { return folly::poly_call&lt;0&gt;(*this); }
  };
  template &lt;class T&gt;
  using Members = FOLLY_POLY_MEMBERS(&amp;T::Bar);
};

using FooBar = Poly&lt;IFooBar&gt;;
</pre></dd></dl>
<dl class="section user"><dt></dt><dd>Given the above defintion, instances of type <code>FooBar</code> have both <code><a class="el" href="structFoo.html">Foo()</a></code> and <code><a class="el" href="structBar.html">Bar()</a></code> member functions.</dd></dl>
<dl class="section user"><dt></dt><dd>The sensible conversions exist between a wrapped derived type and a wrapped base type. For instance, assuming <code>IDerived</code> extends <code>IBase</code> with <code><a class="el" href="structfolly_1_1PolyExtends.html">PolyExtends</a></code>: <pre class="fragment">Poly&lt;IDerived&gt; derived = ...;
Poly&lt;IBase&gt; base = derived; // This conversion is OK.
</pre></dd></dl>
<dl class="section user"><dt></dt><dd>As you would expect, there is no conversion in the other direction, and at present there is no <code><a class="el" href="structfolly_1_1Poly.html">Poly</a></code> equivalent to <code>dynamic_cast</code>.</dd></dl>
<dl class="section user"><dt>Type-erasing polymorphic reference wrappers</dt><dd></dd></dl>
<dl class="section user"><dt></dt><dd>Sometimes you don't need to own a copy of an object; a reference will do. For that you can use <code><a class="el" href="structfolly_1_1Poly.html">Poly</a></code> to capture a <em>reference</em> to an object satisfying an interface rather than the whole object itself. The syntax is intuitive. <pre class="fragment">int i = 42;
// Capture a mutable reference to an object of any IRegular type:
Poly&lt;IRegular &amp;&gt; intRef = i;
assert(42 == folly::poly_cast&lt;int&gt;(intRef));
// Assert that we captured the address of "i":
assert(&amp;i == &amp;folly::poly_cast&lt;int&gt;(intRef));
</pre></dd></dl>
<dl class="section user"><dt></dt><dd><a class="el" href="structA.html">A</a> reference-like <code><a class="el" href="structfolly_1_1Poly.html">Poly</a></code> has a different interface than a value-like <code><a class="el" href="structfolly_1_1Poly.html">Poly</a></code>. Rather than calling member functions with the <code>obj.fun()</code> syntax, you would use the <code>obj-&gt;<a class="el" href="BenchmarkTest_8cpp.html#ad6557b4a82b64d9dc4c4545ae55f1600">fun()</a></code> syntax. This is for the sake of <code>const</code>-correctness. For example, consider the code below: <pre class="fragment">struct IFoo {
  template &lt;class Base&gt;
  struct Interface {
    void Foo() { folly::poly_call&lt;0&gt;(*this); }
  };
  template &lt;class T&gt;
  using Members = folly::PolyMembers&lt;&amp;T::Foo&gt;;
};

struct SomeFoo {
  void Foo() { std::printf("SomeFoo::Foo\n"); }
};

SomeFoo foo;
Poly&lt;IFoo &amp;&gt; const anyFoo = foo;
anyFoo-&gt;Foo(); // prints "SomeFoo::Foo"
</pre></dd></dl>
<dl class="section user"><dt></dt><dd>Notice in the above code that the <code><a class="el" href="structFoo.html">Foo</a></code> member function is non-<code>const</code>. Notice also that the <code>anyFoo</code> object is <code>const</code>. However, since it has captured a non-<code>const</code> reference to the <code>foo</code> object, it should still be possible to dispatch to the non-<code>const</code> <code><a class="el" href="structFoo.html">Foo</a></code> member function. When instantiated with a reference type, <code><a class="el" href="structfolly_1_1Poly.html">Poly</a></code> has an overloaded <code>operator-&gt;</code> member that returns a pointer to the <code>IFoo</code> interface with the correct <code>const</code>-ness, which makes this work.</dd></dl>
<dl class="section user"><dt></dt><dd>The same mechanism also prevents users from calling non-<code>const</code> member functions on <code><a class="el" href="structfolly_1_1Poly.html">Poly</a></code> objects that have captured <code>const</code> references, which would violate <code>const</code>-correctness.</dd></dl>
<dl class="section user"><dt></dt><dd>Sensible conversions exist between non-reference and reference <code><a class="el" href="structfolly_1_1Poly.html">Poly</a></code>s. For instance: <pre class="fragment">Poly&lt;IRegular&gt; value = 42;
Poly&lt;IRegular &amp;&gt; mutable_ref = value;
Poly&lt;IRegular const &amp;&gt; const_ref = mutable_ref;

assert(&amp;poly_cast&lt;int&gt;(value) == &amp;poly_cast&lt;int&gt;(mutable_ref));
assert(&amp;poly_cast&lt;int&gt;(value) == &amp;poly_cast&lt;int&gt;(const_ref));
</pre></dd></dl>
<dl class="section user"><dt>Non-member functions (C++17)</dt><dd></dd></dl>
<dl class="section user"><dt></dt><dd>If you wanted to write the interface <code>ILogicallyNegatable</code>, which captures all types that can be negated with unary <code>operator!</code>, you could do it as we've shown above, by binding <code>&amp;T::operator!</code> in the nested <code>Members</code> alias template, but that has the problem that it won't work for types that have defined unary <code>operator!</code> as a free function. To handle this case, the <code><a class="el" href="structfolly_1_1Poly.html">Poly</a></code> library lets you use a free function instead of a member function when creating a binding.</dd></dl>
<dl class="section user"><dt></dt><dd>With C++17 you may use a lambda to create a binding, as shown in the example below: <pre class="fragment">struct ILogicallyNegatable {
  template &lt;class Base&gt;
  struct Interface : Base {
    bool operator!() const { return folly::poly_call&lt;0&gt;(*this); }
  };
  template &lt;class T&gt;
  using Members = folly::PolyMembers&lt;
    +[](T const&amp; t) -&gt; decltype(!t) { return !t; }&gt;;
};
</pre></dd></dl>
<dl class="section user"><dt></dt><dd>This requires some explanation. The unary <code>operator+</code> in front of the lambda is necessary! It causes the lambda to decay to a C-style function pointer, which is one of the types that <code><a class="el" href="namespacefolly.html#a6ee904f3631e2c5dcb03a52ccfbe031b">folly::PolyMembers</a></code> accepts. The <code>decltype</code> in the lambda return type is also necessary. Through the magic of SFINAE, it will cause <code><a class="el" href="structfolly_1_1Poly.html">Poly</a>&lt;ILogicallyNegatable&gt;</code> to reject any types that don't support unary <code>operator!</code>.</dd></dl>
<dl class="section user"><dt></dt><dd>If you are using a free function to create a binding, the first parameter is implicitly the <code>this</code> parameter. It will receive the type-erased object.</dd></dl>
<dl class="section user"><dt>Non-member functions (C++14)</dt><dd></dd></dl>
<dl class="section user"><dt></dt><dd>If you are using a C++14 compiler, the defintion of <code>ILogicallyNegatable</code> above will fail because lambdas are not <code>constexpr</code>. We can get the same effect by writing the lambda as a named free function, as show below: <pre class="fragment">struct ILogicallyNegatable {
  template &lt;class Base&gt;
  struct Interface : Base {
    bool operator!() const { return folly::poly_call&lt;0&gt;(*this); }
  };

  template &lt;class T&gt;
  static auto negate(T const&amp; t) -&gt; decltype(!t) { return !t; }

  template &lt;class T&gt;
  using Members = FOLLY_POLY_MEMBERS(&amp;negate&lt;T&gt;);
};
</pre></dd></dl>
<dl class="section user"><dt></dt><dd>As with the example that uses the lambda in the preceding section, the first parameter is implicitly the <code>this</code> parameter. It will receive the type-erased object.</dd></dl>
<dl class="section user"><dt>Multi-dispatch</dt><dd></dd></dl>
<dl class="section user"><dt></dt><dd>What if you want to create an <code>IAddable</code> interface for things that can be added? Adding requires <em>two</em> objects, both of which are type-erased. This interface requires dispatching on both objects, doing the addition only if the types are the same. For this we make use of the <code>PolySelf</code> template alias to define an interface that takes more than one object of the the erased type. <pre class="fragment">struct IAddable {
  template &lt;class Base&gt;
  struct Interface : Base {
    friend PolySelf&lt;Base, Decay&gt;
    operator+(PolySelf&lt;Base&gt; const&amp; a, PolySelf&lt;Base&gt; const&amp; b) {
      return folly::poly_call&lt;0, IAddable&gt;(a, b);
    }
  };

  template &lt;class T&gt;
  using Members = folly::PolyMembers&lt;
    +[](T const&amp; a, T const&amp; b) -&gt; decltype(a + b) { return a + b; }&gt;;
};
</pre></dd></dl>
<dl class="section user"><dt></dt><dd>Given the above defintion of <code>IAddable</code> we would be able to do the following: <pre class="fragment">Poly&lt;IAddable&gt; a = 2, b = 3;
Poly&lt;IAddable&gt; c = a + b;
assert(poly_cast&lt;int&gt;(c) == 5);
</pre></dd></dl>
<dl class="section user"><dt></dt><dd>If <code>a</code> and <code>b</code> stored objects of different types, a <code><a class="el" href="structfolly_1_1BadPolyCast.html">BadPolyCast</a></code> exception would be thrown.</dd></dl>
<dl class="section user"><dt>Move-only types</dt><dd></dd></dl>
<dl class="section user"><dt></dt><dd>If you want to store move-only types, then your interface should extend the <code>IMoveOnly</code> interface.</dd></dl>
<dl class="section user"><dt>Implementation notes</dt><dd></dd></dl>
<dl class="section user"><dt></dt><dd><code><a class="el" href="structfolly_1_1Poly.html">Poly</a></code> will store "small" objects in an internal buffer, avoiding the cost of of dynamic allocations. At present, this size is not configurable; it is pegged at the size of two <code>double</code>s.</dd></dl>
<dl class="section user"><dt></dt><dd><code><a class="el" href="structfolly_1_1Poly.html">Poly</a></code> objects are always nothrow movable. If you store an object in one that has a potentially throwing move contructor, the object will be stored on the heap, even if it could fit in the internal storage of the <code><a class="el" href="structfolly_1_1Poly.html">Poly</a></code> object. (So be sure to give your objects nothrow move constructors!)</dd></dl>
<dl class="section user"><dt></dt><dd><code><a class="el" href="structfolly_1_1Poly.html">Poly</a></code> implements type-erasure in a manner very similar to how the compiler accomplishes virtual dispatch. Every <code><a class="el" href="structfolly_1_1Poly.html">Poly</a></code> object contains a pointer to a table of function pointers. Member function calls involve a double- indirection: once through the v-pointer, and other indirect function call through the function pointer. </dd></dl>

<p>Definition at line <a class="el" href="PolyDetail_8h_source.html#l00060">60</a> of file <a class="el" href="PolyDetail_8h_source.html">PolyDetail.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0b5695e6f2e2946038b4b82ff8580137"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfolly_1_1Poly.html">folly::Poly</a>&lt; I &gt;::<a class="el" href="structfolly_1_1Poly.html">Poly</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>proxygen/folly/folly/detail/<a class="el" href="PolyDetail_8h_source.html">PolyDetail.h</a></li>
<li>proxygen/folly/folly/<a class="el" href="Poly_8h_source.html">Poly.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefolly.html">folly</a></li><li class="navelem"><a class="el" href="structfolly_1_1Poly.html">Poly</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
