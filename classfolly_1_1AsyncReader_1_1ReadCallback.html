<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: folly::AsyncReader::ReadCallback Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classfolly_1_1AsyncReader_1_1ReadCallback.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classfolly_1_1AsyncReader_1_1ReadCallback-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">folly::AsyncReader::ReadCallback Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="AsyncTransport_8h_source.html">AsyncTransport.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for folly::AsyncReader::ReadCallback:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classfolly_1_1AsyncReader_1_1ReadCallback.png" usemap="#folly::AsyncReader::ReadCallback_map" alt=""/>
  <map id="folly::AsyncReader::ReadCallback_map" name="folly::AsyncReader::ReadCallback_map">
<area href="classBlockingSocket.html" alt="BlockingSocket" shape="rect" coords="213,56,416,80"/>
<area href="classBogoTestClient.html" alt="BogoTestClient" shape="rect" coords="213,112,416,136"/>
<area href="classBogoTestServer.html" alt="BogoTestServer" shape="rect" coords="213,168,416,192"/>
<area href="classfizz_1_1AsyncFizzBase.html" alt="fizz::AsyncFizzBase" shape="rect" coords="213,224,416,248"/>
<area href="classfolly_1_1AlpnServer.html" alt="folly::AlpnServer" shape="rect" coords="213,280,416,304"/>
<area href="classfolly_1_1AttachDetachClient.html" alt="folly::AttachDetachClient" shape="rect" coords="213,336,416,360"/>
<area href="classfolly_1_1BlockingWriteServer.html" alt="folly::BlockingWriteServer" shape="rect" coords="213,392,416,416"/>
<area href="classfolly_1_1ReadCallbackBase.html" alt="folly::ReadCallbackBase" shape="rect" coords="213,448,416,472"/>
<area href="classfolly_1_1RenegotiatingServer.html" alt="folly::RenegotiatingServer" shape="rect" coords="213,504,416,528"/>
<area href="classfolly_1_1SNIServer.html" alt="folly::SNIServer" shape="rect" coords="213,560,416,584"/>
<area href="classfolly_1_1SSLClient.html" alt="folly::SSLClient" shape="rect" coords="213,616,416,640"/>
<area href="classfolly_1_1test_1_1MockReadCallback.html" alt="folly::test::MockReadCallback" shape="rect" coords="213,672,416,696"/>
<area href="classproxygen_1_1HTTPSession.html" alt="proxygen::HTTPSession" shape="rect" coords="213,728,416,752"/>
<area href="classProxyService_1_1ProxyHandler.html" alt="ProxyService::ProxyHandler" shape="rect" coords="213,784,416,808"/>
<area href="classReadCallback.html" alt="ReadCallback" shape="rect" coords="213,840,416,864"/>
<area href="classwangle_1_1AsyncSocketHandler.html" alt="wangle::AsyncSocketHandler" shape="rect" coords="213,896,416,920"/>
<area href="classwangle_1_1SocketPeeker.html" alt="wangle::SocketPeeker" shape="rect" coords="213,952,416,976"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a77ea0dea4d207d7fb23de61bdf1a70d6"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a77ea0dea4d207d7fb23de61bdf1a70d6">~ReadCallback</a> ()=default</td></tr>
<tr class="separator:a77ea0dea4d207d7fb23de61bdf1a70d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1015afbbb572583647171c87eeea1695"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a1015afbbb572583647171c87eeea1695">getReadBuffer</a> (void **bufReturn, size_t *lenReturn)=0</td></tr>
<tr class="separator:a1015afbbb572583647171c87eeea1695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5e2d2009be3fb983aa59d9f4d54029"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a0d5e2d2009be3fb983aa59d9f4d54029">readDataAvailable</a> (size_t len) noexcept=0</td></tr>
<tr class="separator:a0d5e2d2009be3fb983aa59d9f4d54029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d302ff54f36523c45b251365964aba4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a5d302ff54f36523c45b251365964aba4">isBufferMovable</a> () noexcept</td></tr>
<tr class="separator:a5d302ff54f36523c45b251365964aba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007470e0a4b44fff2ecd5b6e9d93d5a3"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a007470e0a4b44fff2ecd5b6e9d93d5a3">maxBufferSize</a> () const </td></tr>
<tr class="separator:a007470e0a4b44fff2ecd5b6e9d93d5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966337ef655a7d9603268cc15032daa1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a966337ef655a7d9603268cc15032daa1">readBufferAvailable</a> (std::unique_ptr&lt; <a class="el" href="classfolly_1_1IOBuf.html">IOBuf</a> &gt;) noexcept</td></tr>
<tr class="separator:a966337ef655a7d9603268cc15032daa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd391e44f632552f9d2acb816365246"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a0cd391e44f632552f9d2acb816365246">readEOF</a> () noexcept=0</td></tr>
<tr class="separator:a0cd391e44f632552f9d2acb816365246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0d791c9bf0400f4ea951528cfbbca4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a4d0d791c9bf0400f4ea951528cfbbca4">readErr</a> (const <a class="el" href="classfolly_1_1AsyncSocketException.html">AsyncSocketException</a> &amp;ex) noexcept=0</td></tr>
<tr class="separator:a4d0d791c9bf0400f4ea951528cfbbca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="AsyncTransport_8h_source.html#l00484">484</a> of file <a class="el" href="AsyncTransport_8h_source.html">AsyncTransport.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a77ea0dea4d207d7fb23de61bdf1a70d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual folly::AsyncReader::ReadCallback::~ReadCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classfolly_1_1ReadCallback.html#ad8d4545b845b4cd07ab6b51ea992213f">folly::ReadCallback</a>, and <a class="el" href="classReadCallback.html#ad025c4d502f554a5bff85b18b0736878">ReadCallback</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1015afbbb572583647171c87eeea1695"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void folly::AsyncReader::ReadCallback::getReadBuffer </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>bufReturn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>lenReturn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When data becomes available, <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a1015afbbb572583647171c87eeea1695">getReadBuffer()</a> will be invoked to get the buffer into which data should be read.</p>
<p>This method allows the <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html">ReadCallback</a> to delay buffer allocation until data becomes available. This allows applications to manage large numbers of idle connections, without having to maintain a separate read buffer for each idle connection.</p>
<p>It is possible that in some cases, <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a1015afbbb572583647171c87eeea1695">getReadBuffer()</a> may be called multiple times before <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a0d5e2d2009be3fb983aa59d9f4d54029">readDataAvailable()</a> is invoked. In this case, the data will be written to the buffer returned from the most recent call to <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a0d5e2d2009be3fb983aa59d9f4d54029">readDataAvailable()</a>. If the previous calls to <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a0d5e2d2009be3fb983aa59d9f4d54029">readDataAvailable()</a> returned different buffers, the <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html">ReadCallback</a> is responsible for ensuring that they are not leaked.</p>
<p>If <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a1015afbbb572583647171c87eeea1695">getReadBuffer()</a> throws an exception, returns a nullptr buffer, or returns a 0 length, the <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html">ReadCallback</a> will be uninstalled and its readError() method will be invoked.</p>
<p><a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a1015afbbb572583647171c87eeea1695">getReadBuffer()</a> is not allowed to change the transport state before it returns. (For example, it should never uninstall the read callback, or set a different read callback.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufReturn</td><td><a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a1015afbbb572583647171c87eeea1695">getReadBuffer()</a> should update *bufReturn to contain the address of the read buffer. This parameter will never be nullptr. </td></tr>
    <tr><td class="paramname">lenReturn</td><td><a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a1015afbbb572583647171c87eeea1695">getReadBuffer()</a> should update *lenReturn to contain the maximum number of bytes that may be written to the read buffer. This parameter will never be nullptr. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classfolly_1_1SSLClient.html#a0f587ddcf584694c6446426416b4fb2a">folly::SSLClient</a>, <a class="el" href="classfolly_1_1SNIServer.html#a2c8420657d4df2e9b428a4fc69230427">folly::SNIServer</a>, <a class="el" href="classfolly_1_1RenegotiatingServer.html#a49f6b26e9e91ba99a5a51fc5392f9ead">folly::RenegotiatingServer</a>, <a class="el" href="classfolly_1_1AlpnServer.html#a5b2f9aa2f119877d661e8f6cd80bdaec">folly::AlpnServer</a>, <a class="el" href="classfolly_1_1BlockingWriteServer.html#a1306955161b5b850c7fc37e82a1a5036">folly::BlockingWriteServer</a>, <a class="el" href="classfolly_1_1ReadEOFCallback.html#a6ddcdc1796e31d277e82f969511d17e0">folly::ReadEOFCallback</a>, <a class="el" href="classfolly_1_1ReadErrorCallback.html#a73604dc890d45846c2ac6b33890d82cb">folly::ReadErrorCallback</a>, <a class="el" href="classproxygen_1_1HTTPSession.html#a44d7eea9bf8759a4cbcf2fb1d82255bb">proxygen::HTTPSession</a>, <a class="el" href="classfolly_1_1ReadCallback.html#a1948a0e1f5e874c1b92c4fea52e1488d">folly::ReadCallback</a>, <a class="el" href="classfolly_1_1NoopReadCallback.html#a55b7d0c15fbc5fd9663af28bb48abd6e">folly::NoopReadCallback</a>, <a class="el" href="classfizz_1_1AsyncFizzBase.html#a53993287e6c608f4bf829ab02bdce2d7">fizz::AsyncFizzBase</a>, <a class="el" href="classBogoTestClient.html#aba22ad2b97466ef77cb2aea88dfed2fb">BogoTestClient</a>, <a class="el" href="classfolly_1_1AsyncSSLSocket_1_1DefaultOpenSSLAsyncFinishCallback.html#a9ed12d6eb2d7f54a7b0a48eb9ea5e69c">folly::AsyncSSLSocket::DefaultOpenSSLAsyncFinishCallback</a>, <a class="el" href="classfolly_1_1AttachDetachClient.html#a53ddf664e10c6a85024757bcbfcfc262">folly::AttachDetachClient</a>, <a class="el" href="classwangle_1_1AsyncSocketHandler.html#a167a30d8ed98b8b5e16a9012894ffd40">wangle::AsyncSocketHandler</a>, <a class="el" href="classProxyService_1_1ProxyHandler.html#a984933caf034980463563fe6b3a80212">ProxyService::ProxyHandler</a>, <a class="el" href="classBlockingSocket.html#ad1d8de9deb3c72b00128537e5a5aaf31">BlockingSocket</a>, <a class="el" href="classReadCallback.html#a04c6d0d64e7d658a2534010146da3ee2">ReadCallback</a>, <a class="el" href="classBogoTestServer.html#ad7f8860576e92ffa066da3e0b04b4b98">BogoTestServer</a>, and <a class="el" href="classwangle_1_1SocketPeeker.html#a296f01ad652e0bed34dbb1f27fdaa95e">wangle::SocketPeeker</a>.</p>

<p>Referenced by <a class="el" href="AsyncFizzBase_8cpp_source.html#l00100">fizz::AsyncFizzBase::deliverAppData()</a>, <a class="el" href="TestAsyncTransport_8cpp_source.html#l00547">TestAsyncTransport::fireOneReadEvent()</a>, <a class="el" href="AsyncPipe_8cpp_source.html#l00057">folly::AsyncPipeReader::handlerReady()</a>, <a class="el" href="AsyncSSLSocket_8cpp_source.html#l01346">folly::AsyncSSLSocket::prepareReadBuffer()</a>, and <a class="el" href="AsyncSocket_8cpp_source.html#l01798">folly::AsyncSocket::prepareReadBuffer()</a>.</p>

</div>
</div>
<a class="anchor" id="a5d302ff54f36523c45b251365964aba4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool folly::AsyncReader::ReadCallback::isBufferMovable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When data becomes available, <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a5d302ff54f36523c45b251365964aba4">isBufferMovable()</a> will be invoked to figure out which API will be used, <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a966337ef655a7d9603268cc15032daa1">readBufferAvailable()</a> or <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a0d5e2d2009be3fb983aa59d9f4d54029">readDataAvailable()</a>. If <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a5d302ff54f36523c45b251365964aba4">isBufferMovable()</a> returns true, that means <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html">ReadCallback</a> supports the <a class="el" href="classfolly_1_1IOBuf.html">IOBuf</a> ownership transfer and <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a966337ef655a7d9603268cc15032daa1">readBufferAvailable()</a> will be used. Otherwise, not.</p>
<p>By default, <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a5d302ff54f36523c45b251365964aba4">isBufferMovable()</a> always return false. If <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a966337ef655a7d9603268cc15032daa1">readBufferAvailable()</a> is implemented and to be invoked, You should overwrite <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a5d302ff54f36523c45b251365964aba4">isBufferMovable()</a> and return true in the inherited class.</p>
<p>This method allows the AsyncSocket/AsyncSSLSocket do buffer allocation by itself until data becomes available. Compared with the pre/post buffer allocation in <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a1015afbbb572583647171c87eeea1695">getReadBuffer()</a>/readDataAvailabe(), <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a966337ef655a7d9603268cc15032daa1">readBufferAvailable()</a> has two advantages. First, this can avoid memcpy. E.g., in <a class="el" href="classfolly_1_1AsyncSSLSocket.html">AsyncSSLSocket</a>, the decrypted data was copied from the openssl internal buffer to the readbuf buffer. With the buffer ownership transfer, the internal buffer can be directly "moved" to <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html">ReadCallback</a>. Second, the memory allocation can be more precise. The reason is AsyncSocket/AsyncSSLSocket can allocate the memory of precise size because they have more context about the available data than <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html">ReadCallback</a>. Think about the <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a1015afbbb572583647171c87eeea1695">getReadBuffer()</a> pre-allocate 4072 bytes buffer, but the available data is always 16KB (max OpenSSL record size). </p>

<p>Reimplemented in <a class="el" href="classproxygen_1_1HTTPSession.html#a0f7082999e3f66a8a049dac93cc89120">proxygen::HTTPSession</a>, <a class="el" href="classfizz_1_1AsyncFizzBase.html#ad95e249b10363a85830ce8029bd8614b">fizz::AsyncFizzBase</a>, <a class="el" href="classBogoTestClient.html#ac4c5a9e1fbe6a9f91424357689fcb03c">BogoTestClient</a>, <a class="el" href="classBogoTestServer.html#a69fb08530e10faf3cd83aab67ce2b209">BogoTestServer</a>, <a class="el" href="classwangle_1_1SocketPeeker.html#a7b48484c4364ccc70224e7b124086979">wangle::SocketPeeker</a>, and <a class="el" href="classfolly_1_1test_1_1MockReadCallback.html#a9509af11c7ff5ff397c97e4bd8d49e17">folly::test::MockReadCallback</a>.</p>

<p>Definition at line <a class="el" href="AsyncTransport_8h_source.html#l00561">561</a> of file <a class="el" href="AsyncTransport_8h_source.html">AsyncTransport.h</a>.</p>

<p>Referenced by <a class="el" href="AsyncFizzBase_8cpp_source.html#l00100">fizz::AsyncFizzBase::deliverAppData()</a>, <a class="el" href="AsyncPipe_8cpp_source.html#l00057">folly::AsyncPipeReader::handlerReady()</a>, <a class="el" href="LocalTransport_8h_source.html#l00046">fizz::test::LocalTransport::setReadCB()</a>, and <a class="el" href="AsyncSSLSocket_8cpp_source.html#l01328">folly::AsyncSSLSocket::setReadCB()</a>.</p>
<div class="fragment"><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;                                            {</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a007470e0a4b44fff2ecd5b6e9d93d5a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t folly::AsyncReader::ReadCallback::maxBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Suggested buffer size, allocated for read operations, if callback is movable and supports <a class="el" href="classfolly_1_1IOBuf.html">folly::IOBuf</a> </p>

<p>Definition at line <a class="el" href="AsyncTransport_8h_source.html#l00570">570</a> of file <a class="el" href="AsyncTransport_8h_source.html">AsyncTransport.h</a>.</p>

<p>Referenced by <a class="el" href="AsyncPipe_8cpp_source.html#l00057">folly::AsyncPipeReader::handlerReady()</a>.</p>
<div class="fragment"><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;                                         {</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;      <span class="keywordflow">return</span> 64 * 1024; <span class="comment">// 64K</span></div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a966337ef655a7d9603268cc15032daa1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void folly::AsyncReader::ReadCallback::readBufferAvailable </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classfolly_1_1IOBuf.html">IOBuf</a> &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a966337ef655a7d9603268cc15032daa1">readBufferAvailable()</a> will be invoked when data has been successfully read.</p>
<p>Note that only either <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a966337ef655a7d9603268cc15032daa1">readBufferAvailable()</a> or <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a0d5e2d2009be3fb983aa59d9f4d54029">readDataAvailable()</a> will be invoked according to the return value of <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a5d302ff54f36523c45b251365964aba4">isBufferMovable()</a>. The timing and aftereffect of <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a966337ef655a7d9603268cc15032daa1">readBufferAvailable()</a> are the same as <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a0d5e2d2009be3fb983aa59d9f4d54029">readDataAvailable()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">readBuf</td><td>The unique pointer of read buffer. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classproxygen_1_1HTTPSession.html#a5e76f86ed8e366c32399e02feac3cfe6">proxygen::HTTPSession</a>, <a class="el" href="classfizz_1_1AsyncFizzBase.html#abe1e4d2b4abfcc418fa40353559e0425">fizz::AsyncFizzBase</a>, <a class="el" href="classBogoTestClient.html#aa8c6452fc28fd976555649a667a3ebf8">BogoTestClient</a>, <a class="el" href="classBogoTestServer.html#a0553c0f8395652747a5f770c8f2c75db">BogoTestServer</a>, and <a class="el" href="classfolly_1_1test_1_1MockReadCallback.html#a47a6e51562ca952f6498acc7d92044bf">folly::test::MockReadCallback</a>.</p>

<p>Definition at line <a class="el" href="AsyncTransport_8h_source.html#l00586">586</a> of file <a class="el" href="AsyncTransport_8h_source.html">AsyncTransport.h</a>.</p>

<p>Referenced by <a class="el" href="AsyncFizzBase_8cpp_source.html#l00100">fizz::AsyncFizzBase::deliverAppData()</a>, <a class="el" href="LocalTransport_8h_source.html#l00156">fizz::test::LocalTransport::deliverData()</a>, <a class="el" href="AsyncSocket_8cpp_source.html#l01881">folly::AsyncSocket::handleRead()</a>, and <a class="el" href="AsyncPipe_8cpp_source.html#l00057">folly::AsyncPipeReader::handlerReady()</a>.</p>
<div class="fragment"><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;                                         {}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0d5e2d2009be3fb983aa59d9f4d54029"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void folly::AsyncReader::ReadCallback::readDataAvailable </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a0d5e2d2009be3fb983aa59d9f4d54029">readDataAvailable()</a> will be invoked when data has been successfully read into the buffer returned by the last call to <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a1015afbbb572583647171c87eeea1695">getReadBuffer()</a>.</p>
<p>The read callback remains installed after <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a0d5e2d2009be3fb983aa59d9f4d54029">readDataAvailable()</a> returns. It must be explicitly uninstalled to stop receiving read events. <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a1015afbbb572583647171c87eeea1695">getReadBuffer()</a> will be called at least once before each call to <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a0d5e2d2009be3fb983aa59d9f4d54029">readDataAvailable()</a>. <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a1015afbbb572583647171c87eeea1695">getReadBuffer()</a> will also be called before any call to <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a0cd391e44f632552f9d2acb816365246">readEOF()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>The number of bytes placed in the buffer. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classfolly_1_1ReadCallbackTerminator.html#abc5416a0663faba1d212b95499c3e20a">folly::ReadCallbackTerminator</a>, <a class="el" href="classfolly_1_1SSLClient.html#a7ae9ec46ec83e666ae8a6451b1550a56">folly::SSLClient</a>, <a class="el" href="classfolly_1_1SNIServer.html#acff964c5cfb17bf3c5d3345ccd349d92">folly::SNIServer</a>, <a class="el" href="classfolly_1_1RenegotiatingServer.html#a9f6e3ecc2de713773b31598cc4e5267f">folly::RenegotiatingServer</a>, <a class="el" href="classfolly_1_1AlpnServer.html#ab35e007a77ba44b25d1869e6384180b7">folly::AlpnServer</a>, <a class="el" href="classfolly_1_1BlockingWriteServer.html#ad0ba7b1269968115a3a126c362975694">folly::BlockingWriteServer</a>, <a class="el" href="classfolly_1_1WriteErrorCallback.html#a3f6b1a97c777d163a93aaf73ff7a382e">folly::WriteErrorCallback</a>, <a class="el" href="classfolly_1_1ReadEOFCallback.html#a97e9469eb128854c10b06d1fa2caddae">folly::ReadEOFCallback</a>, <a class="el" href="classfolly_1_1ReadErrorCallback.html#ae911fc8a8b26586bb8652f8032eef12b">folly::ReadErrorCallback</a>, <a class="el" href="classproxygen_1_1HTTPSession.html#ad48c44abccc284d6878ea73bb01feea3">proxygen::HTTPSession</a>, <a class="el" href="classfolly_1_1ReadCallback.html#ac634498edc663fa61ca7b70b588285a0">folly::ReadCallback</a>, <a class="el" href="classfolly_1_1NoopReadCallback.html#a82c8b28bf7648781265a61d30f7d738b">folly::NoopReadCallback</a>, <a class="el" href="classfizz_1_1AsyncFizzBase.html#ad58a8d6d64a10b60a95004a008ea5972">fizz::AsyncFizzBase</a>, <a class="el" href="classBogoTestClient.html#a7047c8ecbc8d5a19a58dc742192ab551">BogoTestClient</a>, <a class="el" href="classfolly_1_1AsyncSSLSocket_1_1DefaultOpenSSLAsyncFinishCallback.html#a118f4be090e957efb1f831332be973df">folly::AsyncSSLSocket::DefaultOpenSSLAsyncFinishCallback</a>, <a class="el" href="classfolly_1_1AttachDetachClient.html#aad7166e8ba401028a726652a8c88a0d3">folly::AttachDetachClient</a>, <a class="el" href="classwangle_1_1AsyncSocketHandler.html#adc696936d2a6d96f7082179dc2652675">wangle::AsyncSocketHandler</a>, <a class="el" href="classProxyService_1_1ProxyHandler.html#a16902f68f0e88c79e9c24578129ccde8">ProxyService::ProxyHandler</a>, <a class="el" href="classBlockingSocket.html#af73dd7a81a6fe4a84befc619ca61111f">BlockingSocket</a>, <a class="el" href="classReadCallback.html#aa155c834c372822b7fa716070ae37bb5">ReadCallback</a>, <a class="el" href="classBogoTestServer.html#aaa6b8fa05e73c0452cfe57aafe5f42c9">BogoTestServer</a>, <a class="el" href="classfolly_1_1test_1_1MockReadCallback.html#ad9698257a39a4cd1c1bbeae24b56dfa5">folly::test::MockReadCallback</a>, and <a class="el" href="classwangle_1_1SocketPeeker.html#a3467690a526fe8c00988c4a802968b61">wangle::SocketPeeker</a>.</p>

<p>Referenced by <a class="el" href="AsyncFizzBase_8cpp_source.html#l00100">fizz::AsyncFizzBase::deliverAppData()</a>, <a class="el" href="TestAsyncTransport_8cpp_source.html#l00547">TestAsyncTransport::fireOneReadEvent()</a>, <a class="el" href="AsyncSocket_8cpp_source.html#l01881">folly::AsyncSocket::handleRead()</a>, and <a class="el" href="AsyncPipe_8cpp_source.html#l00057">folly::AsyncPipeReader::handlerReady()</a>.</p>

</div>
</div>
<a class="anchor" id="a0cd391e44f632552f9d2acb816365246"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void folly::AsyncReader::ReadCallback::readEOF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a0cd391e44f632552f9d2acb816365246">readEOF()</a> will be invoked when the transport is closed.</p>
<p>The read callback will be automatically uninstalled immediately before <a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html#a0cd391e44f632552f9d2acb816365246">readEOF()</a> is invoked. </p>

<p>Implemented in <a class="el" href="classfolly_1_1SSLClient.html#a071256b234200ef25fef39e86cc0f4a2">folly::SSLClient</a>, <a class="el" href="classfolly_1_1SNIServer.html#a75e9e3f1dfebb560577766d745156645">folly::SNIServer</a>, <a class="el" href="classfolly_1_1RenegotiatingServer.html#a56e9ecf50f5ad0f94b1a6ed57471b0aa">folly::RenegotiatingServer</a>, <a class="el" href="classfolly_1_1AlpnServer.html#a46a8fc3e6d40ca0349f98e68521c6cf2">folly::AlpnServer</a>, <a class="el" href="classfolly_1_1BlockingWriteServer.html#af411d875895a7b202cbb4007baa31b2e">folly::BlockingWriteServer</a>, <a class="el" href="classfolly_1_1EmptyReadCallback.html#aa9aaec080347ee847a64b289e5ef6bb1">folly::EmptyReadCallback</a>, <a class="el" href="classfolly_1_1ReadEOFCallback.html#abce9eeeee332299d8a7e9cfc7e6654a4">folly::ReadEOFCallback</a>, <a class="el" href="classproxygen_1_1HTTPSession.html#a98b41eaa29cecf1b8dad11dba197c056">proxygen::HTTPSession</a>, <a class="el" href="classfolly_1_1ReadCallbackBase.html#a8339747405826ee2f85f6cc752792464">folly::ReadCallbackBase</a>, <a class="el" href="classBogoTestClient.html#afd60c5037b17b357ca28724c68fb52cb">BogoTestClient</a>, <a class="el" href="classfizz_1_1AsyncFizzBase.html#a60022d40270f317182d1eb972a3f3c8b">fizz::AsyncFizzBase</a>, <a class="el" href="classfolly_1_1AsyncSSLSocket_1_1DefaultOpenSSLAsyncFinishCallback.html#a5d656bbc089159634757ad5c1534d7d7">folly::AsyncSSLSocket::DefaultOpenSSLAsyncFinishCallback</a>, <a class="el" href="classwangle_1_1AsyncSocketHandler.html#a5ca5751b59880079f5f2b380752c573f">wangle::AsyncSocketHandler</a>, <a class="el" href="classfolly_1_1AttachDetachClient.html#a875267b97e52152d8798c4706fe760ba">folly::AttachDetachClient</a>, <a class="el" href="classReadCallback.html#adf96f4b030b2d60df0db72ead47fc5c8">ReadCallback</a>, <a class="el" href="classBlockingSocket.html#a6250df3356758daa34bed7f321cfd051">BlockingSocket</a>, <a class="el" href="classProxyService_1_1ProxyHandler.html#a848dbad33920e21ea78bcd6830ef6da2">ProxyService::ProxyHandler</a>, <a class="el" href="classBogoTestServer.html#ad1972ed4ad7363f0594b92973325d6b9">BogoTestServer</a>, <a class="el" href="classfolly_1_1test_1_1MockReadCallback.html#ac5ff6bb680ad6fd1fdb28031754de179">folly::test::MockReadCallback</a>, and <a class="el" href="classwangle_1_1SocketPeeker.html#a6ba317f23ba9392c86339b98b542123d">wangle::SocketPeeker</a>.</p>

<p>Referenced by <a class="el" href="AsyncSocket_8cpp_source.html#l01198">folly::AsyncSocket::close()</a>, <a class="el" href="TestAsyncTransport_8cpp_source.html#l00290">TestAsyncTransport::closeNow()</a>, <a class="el" href="AsyncSocket_8cpp_source.html#l01252">folly::AsyncSocket::closeNow()</a>, <a class="el" href="AsyncFizzBase_8cpp_source.html#l00158">fizz::AsyncFizzBase::deliverError()</a>, <a class="el" href="TestAsyncTransport_8cpp_source.html#l00547">TestAsyncTransport::fireOneReadEvent()</a>, <a class="el" href="AsyncSocket_8cpp_source.html#l01881">folly::AsyncSocket::handleRead()</a>, <a class="el" href="AsyncPipe_8cpp_source.html#l00057">folly::AsyncPipeReader::handlerReady()</a>, <a class="el" href="TestAsyncTransport_8cpp_source.html#l00180">TestAsyncTransport::setReadCB()</a>, and <a class="el" href="PeekingAcceptorHandshakeHelperTest_8cpp_source.html#l00136">TEST_F()</a>.</p>

</div>
</div>
<a class="anchor" id="a4d0d791c9bf0400f4ea951528cfbbca4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void folly::AsyncReader::ReadCallback::readErr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfolly_1_1AsyncSocketException.html">AsyncSocketException</a> &amp;&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>readError() will be invoked if an error occurs reading from the transport.</p>
<p>The read callback will be automatically uninstalled immediately before readError() is invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>An exception describing the error that occurred. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classfolly_1_1SSLClient.html#a7db295edd00e0f7db592ddc63c8b8b80">folly::SSLClient</a>, <a class="el" href="classfolly_1_1SNIServer.html#a85742ad067271090e510c7bda0dd93f8">folly::SNIServer</a>, <a class="el" href="classfolly_1_1RenegotiatingServer.html#afd41d3e5040fe5c1c24558bc53ce4ec0">folly::RenegotiatingServer</a>, <a class="el" href="classfolly_1_1AlpnServer.html#a66f915187736e15991a944872361bae3">folly::AlpnServer</a>, <a class="el" href="classfolly_1_1BlockingWriteServer.html#a7e142c4c3c414bd624ac37db032a96e3">folly::BlockingWriteServer</a>, <a class="el" href="classfolly_1_1EmptyReadCallback.html#a87ce758907d94f5dd63db06253c724cc">folly::EmptyReadCallback</a>, <a class="el" href="classfolly_1_1WriteErrorCallback.html#a725a0578878b16ee6a537a723cc6a606">folly::WriteErrorCallback</a>, <a class="el" href="classfolly_1_1ReadErrorCallback.html#a2345a641772346cae9e91f75f360a7e8">folly::ReadErrorCallback</a>, <a class="el" href="classproxygen_1_1HTTPSession.html#a68885654760e144384fa10f8091d25c0">proxygen::HTTPSession</a>, <a class="el" href="classfolly_1_1ReadCallbackBase.html#a46ae490ed7216fd76deb3b32fd87f078">folly::ReadCallbackBase</a>, <a class="el" href="classBogoTestClient.html#ab4aeaa9390c9d5ca3e4abaff35db1e68">BogoTestClient</a>, <a class="el" href="classfizz_1_1AsyncFizzBase.html#aebf746e74d4f6a95475b6c35a4930f60">fizz::AsyncFizzBase</a>, <a class="el" href="classfolly_1_1AsyncSSLSocket_1_1DefaultOpenSSLAsyncFinishCallback.html#a3254dd3abaaad3cfac9c36a7ae14b55b">folly::AsyncSSLSocket::DefaultOpenSSLAsyncFinishCallback</a>, <a class="el" href="classwangle_1_1AsyncSocketHandler.html#a37557a3974c20c2638112389b95f08b4">wangle::AsyncSocketHandler</a>, <a class="el" href="classfolly_1_1AttachDetachClient.html#ab5049448b0bcd94399c4c2b9808520ec">folly::AttachDetachClient</a>, <a class="el" href="classReadCallback.html#addb48b04e9ac20b25d3ca4c3b4453c60">ReadCallback</a>, <a class="el" href="classBlockingSocket.html#ae19f75b5d273ed169d6b1a6380ae1290">BlockingSocket</a>, <a class="el" href="classBogoTestServer.html#ae6f611f28883dd6793a625d97474b33f">BogoTestServer</a>, <a class="el" href="classProxyService_1_1ProxyHandler.html#a7a3514bc4a484aa765676b10a6b50984">ProxyService::ProxyHandler</a>, <a class="el" href="classfolly_1_1test_1_1MockReadCallback.html#aad8409d31d1f9f36d9dcaf003bfc5be2">folly::test::MockReadCallback</a>, and <a class="el" href="classwangle_1_1SocketPeeker.html#ab19b353217d8acef5b6ae4c0c427d66f">wangle::SocketPeeker</a>.</p>

<p>Referenced by <a class="el" href="AsyncPipe_8cpp_source.html#l00032">folly::AsyncPipeReader::failRead()</a>, <a class="el" href="AsyncSocket_8cpp_source.html#l02587">folly::AsyncSocket::failRead()</a>, <a class="el" href="TestAsyncTransport_8cpp_source.html#l00547">TestAsyncTransport::fireOneReadEvent()</a>, <a class="el" href="AsyncSocket_8cpp_source.html#l02748">folly::AsyncSocket::invalidState()</a>, and <a class="el" href="AsyncSocket_8cpp_source.html#l02542">folly::AsyncSocket::invokeAllErrors()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>proxygen/folly/folly/io/async/<a class="el" href="AsyncTransport_8h_source.html">AsyncTransport.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefolly.html">folly</a></li><li class="navelem"><a class="el" href="classfolly_1_1AsyncReader.html">AsyncReader</a></li><li class="navelem"><a class="el" href="classfolly_1_1AsyncReader_1_1ReadCallback.html">ReadCallback</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
