<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: things I learned from std::for_each and std::reduce</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_proxygen_folly_folly_experimental_pushmi_examples_readme.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">things I learned from std::for_each and std::reduce </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>I wrote an operator called <code><a class="el" href="namespacefolly_1_1pushmi_1_1operators.html#af5fb6450a7262d932feec538454f7851">bulk()</a></code> and implemented for_each and reduce in terms of it. I departed from the <code>bulk_execute()</code> signature and tried to model the reduce signature on my <code>bulk</code> operator. I am not satisfied with the result and would need to invest more to get an abstraction for bulk that I was confident was minimal and efficient.</p>
<h1>Background</h1>
<h2>bulk_execute</h2>
<p>The <code>bulk_execute()</code> function is intended to be an abstraction that allows efficient implementation of the parallel std algorithms on both CPU and GPU executors.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Function, <span class="keyword">class</span> SharedFactory&gt;</div><div class="line"><span class="keywordtype">void</span> bulk_execute(<a class="code" href="classFunction.html">Function</a>&amp;&amp; <a class="code" href="PushmiBenchmarks_8cpp.html#ad94c2c2f9fd35a12cc099962b7540071">f</a>, <span class="keywordtype">size_t</span> n, SharedFactory&amp;&amp; sf) <span class="keyword">const</span>;</div></div><!-- fragment --><p><a class="el" href="structA.html">A</a> sequential implementation might look like:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Function, <span class="keyword">class</span> SharedFactory&gt;</div><div class="line"><span class="keywordtype">void</span> bulk_execute(<a class="code" href="classFunction.html">Function</a>&amp;&amp; <a class="code" href="PushmiBenchmarks_8cpp.html#ad94c2c2f9fd35a12cc099962b7540071">f</a>, <span class="keywordtype">size_t</span> n, SharedFactory&amp;&amp; sf)</div><div class="line">{</div><div class="line">  <span class="keyword">auto</span> <a class="code" href="http__parser_8c.html#adc6e5733fc3c22f0a7b2914188c49c90">state</a> = sf();</div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> idx = 0; idx &lt; n; ++idx) {</div><div class="line">      <a class="code" href="PushmiBenchmarks_8cpp.html#ad94c2c2f9fd35a12cc099962b7540071">f</a>(<a class="code" href="http__parser_8c.html#adc6e5733fc3c22f0a7b2914188c49c90">state</a>, idx);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>The <code><a class="el" href="classFunction.html" title="A polymorphic function wrapper that is not copyable and does not require the wrapped function to be c...">Function</a> f</code> already appears to be similar to the accumulate function passed to reduce. It takes the shared state and the index indicating the current value. The SharedFactory is very similar to the initialValue parameter to reduce. The Shape parameter is very similar to the Range parameter to reduce. These similarities motivated me to modify the signature to more explicitly match the reduce pattern.</p>
<h2>bulk operator</h2>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span> ShapeBegin, <span class="keyword">class</span> ShapeEnd, <span class="keyword">class</span> Target, <span class="keyword">class</span> IF, <span class="keyword">class</span> RS&gt;</div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacefolly_1_1pushmi_1_1operators.html#af5fb6450a7262d932feec538454f7851">bulk</a>(</div><div class="line">    F&amp;&amp; func,</div><div class="line">    ShapeBegin sb,</div><div class="line">    ShapeEnd se,</div><div class="line">    Target&amp;&amp; driver,</div><div class="line">    IF&amp;&amp; initFunc,</div><div class="line">    RS&amp;&amp; selector);</div></div><!-- fragment --><p>The <code>bulk</code> function packages the parameters and returns an adapter function.</p>
<blockquote class="doxtable">
<p><a class="el" href="structA.html">A</a> Sender is an object with a <code><a class="el" href="PushmiBenchmarks_8cpp.html#aa30303f6b5a3a130a39cf0464abd760b">submit()</a></code> method </p>
</blockquote>
<blockquote class="doxtable">
<p>An Adapter is a function that takes a Sender and returns a Sender. Adapters are used for composition. </p>
</blockquote>
<p>When called, the Adapter from <code><a class="el" href="namespacefolly_1_1pushmi_1_1operators.html#af5fb6450a7262d932feec538454f7851">bulk()</a></code> will package the Adapter parameter with the original parameters and return a Sender.</p>
<blockquote class="doxtable">
<p><a class="el" href="structA.html">A</a> Receiver is an object that has methods like <code><a class="el" href="Conv_8cpp.html#a2f6ac1714c34743067351b0d2a64162b">value()</a></code>, <code><a class="el" href="namespacefolly_1_1pushmi_1_1operators.html#ac0115beba807afb09cef1eedb85cd89e">error()</a></code> and <code>done()</code>. <a class="el" href="structA.html">A</a> Receiver is like a Promise. </p>
</blockquote>
<p>The <code><a class="el" href="PushmiBenchmarks_8cpp.html#aa30303f6b5a3a130a39cf0464abd760b">submit()</a></code> method takes a Receiver. When called, the Sender from the bulk Adapter will create a Receiver with the original parameters to <code><a class="el" href="namespacefolly_1_1pushmi_1_1operators.html#af5fb6450a7262d932feec538454f7851">bulk()</a></code> and the Receiver parameter. This new Receiver will be passed to <code><a class="el" href="PushmiBenchmarks_8cpp.html#aa30303f6b5a3a130a39cf0464abd760b">submit()</a></code> on the Sender that the bulk Adapter stored in this bulk Sender.</p>
<p>When called, the <code><a class="el" href="Conv_8cpp.html#a2f6ac1714c34743067351b0d2a64162b">value()</a></code> method on the bulk Receiver will pass all the packaged parameters to the Target.</p>
<blockquote class="doxtable">
<p><a class="el" href="structA.html">A</a> Target is a function that orchestrates the bulk operation using the parameters. There would be different Target implementations for device, sequential, concurrent execution patterns. </p>
</blockquote>
<p><a class="el" href="structA.html">A</a> Target implementation might look like:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> IF, <span class="keyword">class</span> RS, <span class="keyword">class</span> Input, <span class="keyword">class</span> F, <span class="keyword">class</span> ShapeBegin, <span class="keyword">class</span> ShapeEnd, <span class="keyword">class</span> Out&gt;</div><div class="line"><span class="keywordtype">void</span> inline_driver(</div><div class="line">    IF <a class="code" href="namespacebm.html#acd2746303d33ebcae3e42779b4beac70">init</a>,</div><div class="line">    RS selector,</div><div class="line">    Input input,</div><div class="line">    F&amp;&amp; func,</div><div class="line">    ShapeBegin sb,</div><div class="line">    ShapeEnd se,</div><div class="line">    Out out) {</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <span class="keyword">auto</span> acc = <a class="code" href="namespacebm.html#acd2746303d33ebcae3e42779b4beac70">init</a>(input);</div><div class="line">        <span class="keywordflow">for</span> (decltype(sb) idx{sb}; idx != se; ++idx){</div><div class="line">            func(acc, idx);</div><div class="line">        }</div><div class="line">        <span class="keyword">auto</span> result = selector(<a class="code" href="namespacefolly_1_1gen.html#ac24ec252b1b738a40c274285527c193f">std::move</a>(acc));</div><div class="line">        <a class="code" href="namespacefolly_1_1pushmi.html#aa31ba5f575014ec93a46c8433c913636">mi::set_value</a>(out, <a class="code" href="namespacefolly_1_1gen.html#ac24ec252b1b738a40c274285527c193f">std::move</a>(result));</div><div class="line">    } <span class="keywordflow">catch</span>(...) {</div><div class="line">        <a class="code" href="namespacefolly_1_1pushmi.html#a3e05ace0e66f549063497d040c210a60">mi::set_error</a>(out, std::current_exception());</div><div class="line">    }</div><div class="line">    };</div></div><!-- fragment --><blockquote class="doxtable">
<p>ways to improve bulk:</p><ul>
<li>merge ShapeBegin and ShapeEnd into a Range.</li>
<li>pass out to selector so that it can deliver an error or a success.</li>
<li>initFunc multiple times to have context local state that does not need locking or CAS loop.</li>
<li>compose the driver implementations from operators rather than each having a bespoke implementation </li>
</ul>
</blockquote>
<h1>for_each</h1>
<p>implementing for_each was straight-forward with the interface.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ExecutionPolicy, <span class="keyword">class</span> RandomAccessIterator, <span class="keyword">class</span> Function&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="FunctionTest_8cpp.html#a2c4f29acec59b67a355f8a4c9575abe6">for_each</a>(</div><div class="line">  ExecutionPolicy&amp;&amp; policy, </div><div class="line">  RandomAccessIterator <a class="code" href="namespacefolly_1_1test.html#a8dadea8eef3a86a23af2016a11e75afc">begin</a>, </div><div class="line">  RandomAccessIterator <a class="code" href="namespacefolly_1_1test.html#a0917528775d48fd53a51907e08c14adf">end</a>, </div><div class="line">  <a class="code" href="classFunction.html">Function</a> <a class="code" href="PushmiBenchmarks_8cpp.html#ad94c2c2f9fd35a12cc099962b7540071">f</a>)</div><div class="line">{</div><div class="line">  <a class="code" href="namespacefolly_1_1pushmi_1_1operators.html#a4c630848173faebd7713192756912933">operators::just</a>(0) | </div><div class="line">    <a class="code" href="namespacefolly_1_1pushmi_1_1operators.html#af5fb6450a7262d932feec538454f7851">operators::bulk</a>(</div><div class="line">      [f](<span class="keyword">auto</span>&amp; acc, <span class="keyword">auto</span> cursor){ <a class="code" href="PushmiBenchmarks_8cpp.html#ad94c2c2f9fd35a12cc099962b7540071">f</a>(*cursor); }, </div><div class="line">      <a class="code" href="namespacefolly_1_1test.html#a8dadea8eef3a86a23af2016a11e75afc">begin</a>,</div><div class="line">      <a class="code" href="namespacefolly_1_1test.html#a0917528775d48fd53a51907e08c14adf">end</a>, </div><div class="line">      policy, </div><div class="line">      [](<span class="keyword">auto</span>&amp;&amp; args){ <span class="keywordflow">return</span> args; }, </div><div class="line">      [](<span class="keyword">auto</span>&amp;&amp; acc){ <span class="keywordflow">return</span> 0; }) |</div><div class="line">    <a class="code" href="namespacefolly_1_1pushmi_1_1operators.html#aa461a510ef521dc64411067acb0eccff">operators::blocking_submit</a>();</div><div class="line">}</div></div><!-- fragment --><p>The oddity is that bulk is expecting a shared state value and a value as input and a value result. Since for_each does not have shared state, this is overhead that becomes obvious and disturbing when looking at the naive concurrent driver in the code (there is a CAS loop around the call to the state update function even though the state is not updated here).</p>
<h1>reduce</h1>
<p>implementing reduce took more effort and some of the code in the drivers and parameters to the driver were modified to get reduce working.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ExecutionPolicy, <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T, <span class="keyword">class</span> BinaryOp&gt;</div><div class="line"><a class="code" href="http__parser_8c.html#ad24d0de3f597ca60dd95c4bc59c2ff73">T</a> <a class="code" href="namespacefolly_1_1pushmi.html#af78b6e69819bc481cca0614b95a35c7f">reduce</a>(</div><div class="line">  ExecutionPolicy&amp;&amp; policy,</div><div class="line">  ForwardIt begin, </div><div class="line">  ForwardIt end, </div><div class="line">  <a class="code" href="http__parser_8c.html#ad24d0de3f597ca60dd95c4bc59c2ff73">T</a> init, </div><div class="line">  BinaryOp binary_op){</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespacefolly_1_1pushmi_1_1operators.html#a4c630848173faebd7713192756912933">operators::just</a>(<a class="code" href="namespacefolly_1_1gen.html#ac24ec252b1b738a40c274285527c193f">std::move</a>(init)) | </div><div class="line">      <a class="code" href="namespacefolly_1_1pushmi_1_1operators.html#af5fb6450a7262d932feec538454f7851">operators::bulk</a>(</div><div class="line">        [binary_op](<span class="keyword">auto</span>&amp; acc, <span class="keyword">auto</span> cursor){ acc = binary_op(acc, *cursor); }, </div><div class="line">        <a class="code" href="namespacefolly_1_1test.html#a8dadea8eef3a86a23af2016a11e75afc">begin</a>,</div><div class="line">        <a class="code" href="namespacefolly_1_1test.html#a0917528775d48fd53a51907e08c14adf">end</a>, </div><div class="line">        policy, </div><div class="line">        [](<span class="keyword">auto</span>&amp;&amp; args){ <span class="keywordflow">return</span> args; }, </div><div class="line">        [](<span class="keyword">auto</span>&amp;&amp; acc){ <span class="keywordflow">return</span> acc; }) |</div><div class="line">      operators::get&lt;T&gt;;</div><div class="line">    }</div></div><!-- fragment --><p>Based on examples that I have been shown, the existing bulk_execute would expect the bulk_execute caller to provide the synchronization for the shared state. In the case of reduce it is important to synchronize when the execution is concurrent and equally important not to synchronize when it is not concurrent. Using if constexpr to implement reduce with and without sync in the parameters to bulk would add a lot of unsafe bespoke work and complication into every algorithm using bulk. In this bulk design the driver owns synchronization instead.</p>
<blockquote class="doxtable">
<p>NOTE - in any case, if a high-level async library design requires manual lock or lock-free primitive usage for correct behavior, then the design needs to be changed. </p>
</blockquote>
<p>I am dissatisfied with the expected perf results from the naive concurrent driver (expectation from looking at the code, will need to measure). For instance, here is the CAS loop over the accumulator function from the naive concurrent driver:</p>
<div class="fragment"><div class="line"><span class="comment">// this indicates to me that bulk is not the right abstraction</span></div><div class="line"><span class="keyword">auto</span> old = std::get&lt;4&gt;(*shared_state).load();</div><div class="line"><span class="keyword">auto</span> step = old;</div><div class="line"><span class="keywordflow">do</span> {</div><div class="line">  step = old;</div><div class="line">  <span class="comment">// func(accumulation, idx)</span></div><div class="line">  std::get&lt;3&gt;(*shared_state)(step, idx);</div><div class="line">} <span class="keywordflow">while</span>(!std::get&lt;4&gt;(*shared_state).compare_exchange_strong(old, step));</div></div><!-- fragment --><p>This is due to having a single shared_state being shared concurrently. I would much prefer having multiple states that are never used concurrently and then composing them all into one final result.</p>
<blockquote class="doxtable">
<p>creating factor * hardware_concurrency() number of states would allow user controlled granularity (factor) for work stealing. each state would only be used from one <code>hardware_concurrency</code> context and thus would have no synchronization when it was modified. </p>
</blockquote>
<h1>static_thread_pool</h1>
<p>this bonus section is to mention the bulk_execute implementation in the static_thread_pool. The static thread pool is a cool piece of tech. in the bulk_execute method I had two observations.</p>
<ol type="1">
<li>every index in the range from 0-N is allocated as a task node</li>
<li>this list of nodes is built locally and then inserted in one lock operation</li>
</ol>
<p>For #1, I expect that there is a desire to reduce the number of task nodes allocated in bulk.</p>
<p>There are multiple ways to achieve #2 on P1055.</p>
<p>one way to achieve this is to add a type that is an executor but just accumulates a local queue. usage would be similar to..</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> pool = thread_pool();</div><div class="line"></div><div class="line"><span class="keyword">auto</span> e = pool.bulk_executor();</div><div class="line">my_bulk_generator(e, . . .); <span class="comment">// lots of calls to submit</span></div><div class="line">pool.bulk_enqueue(e);</div></div><!-- fragment --><h1>ExecutionPolicy</h1>
<p>In building these algorithms I observed that the parallel std algorithms do not really depend on executor, they depend on ExecutionPolicy. GPU and CPU can have different execution policies and it does not affect the implementation or expression of the parallel algorithms (rather than passing an executor around pass an ExecutionPolicy). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
