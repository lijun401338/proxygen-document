<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: proxygen/folly/folly/docs/Futures.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('Futures_8md.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">proxygen/folly/folly/docs/Futures.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="Futures_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Futures</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;### Futures is a framework for expressing asynchronous code in C++ using the Promise/Future pattern.</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;# Overview</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;Folly Futures is an async C++ framework inspired by [Twitter&#39;s Futures](https://twitter.github.io/finagle/guide/Futures.html) implementation in Scala (see also [Future.scala](https://github.com/twitter/util/blob/master/util-core/src/main/scala/com/twitter/util/Future.scala), [Promise.scala](https://github.com/twitter/util/blob/master/util-core/src/main/scala/com/twitter/util/Promise.scala), and friends), and loosely builds upon the existing but anemic Futures code found in the C++11 standard ([std::future](http://en.cppreference.com/w/cpp/thread/future)) and [boost::future](http://www.boost.org/doc/libs/1_53_0/doc/html/thread/synchronization.html#thread.synchronization.futures) (especially &gt;= 1.53.0). Although inspired by the C++11 std::future interface, it is not a drop-in replacement because some ideas don&#39;t translate well enough to maintain API compatibility.</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;The primary difference from std::future is that you can attach callbacks to Futures (with `thenValue` or `thenTry`), under the control of an executor to manage where work runs, which enables sequential and parallel composition of Futures for cleaner asynchronous code.</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;# Brief Synopsis</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;```</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;#include &lt;folly/futures/Future.h&gt;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;#include &lt;folly/executors/ThreadedExecutor.h&gt;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;using namespace folly;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;using namespace std;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;void foo(int x) {</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;  // do something with x</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;  cout &lt;&lt; &quot;foo(&quot; &lt;&lt; x &lt;&lt; &quot;)&quot; &lt;&lt; endl;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;}</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;// ...</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  folly::ThreadedExecutor executor;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  cout &lt;&lt; &quot;making Promise&quot; &lt;&lt; endl;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  Promise&lt;int&gt; p;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;  Future&lt;int&gt; f = p.getSemiFuture().via(&amp;executor);</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  auto f2 = move(f).thenValue(foo);</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  cout &lt;&lt; &quot;Future chain made&quot; &lt;&lt; endl;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;// ... now perhaps in another event callback</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  cout &lt;&lt; &quot;fulfilling Promise&quot; &lt;&lt; endl;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  p.setValue(42);</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  move(f2).get();</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  cout &lt;&lt; &quot;Promise fulfilled&quot; &lt;&lt; endl;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;```</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;This would print:</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;```</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;making Promise</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;Future chain made</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;fulfilling Promise</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;foo(42)</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;Promise fulfilled</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;```</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;## Blog Post</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;In addition to this document, there is [a blog post on code.facebook.com (June</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;2015)](https://code.facebook.com/posts/1661982097368498/futures-for-c-11-at-facebook/).</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;# Brief guide</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;This brief guide covers the basics. For a more in-depth coverage skip to the appropriate section.</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;Let&#39;s begin with an example using an imaginary simplified Memcache client interface:</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;```</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;using std::string;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;class MemcacheClient {</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160; public:</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  struct GetReply {</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    enum class Result {</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;      FOUND,</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;      NOT_FOUND,</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;      SERVER_ERROR,</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    };</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    Result result;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    // The value when result is FOUND,</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    // The error message when result is SERVER_ERROR or CLIENT_ERROR</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    // undefined otherwise</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    string value;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  };</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  GetReply get(string key);</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;};</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;```</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;This API is synchronous, i.e. when you call `get()` you have to wait for the result. This is very simple, but unfortunately it is also very easy to write very slow code using synchronous APIs.</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;Now, consider this traditional asynchronous signature for the same operation:</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;```</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;int async_get(string key, std::function&lt;void(GetReply)&gt; callback);</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;```</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;When you call `async_get()`, your asynchronous operation begins and when it finishes your callback will be called with the result. Very performant code can be written with an API like this, but for nontrivial applications the code devolves into a special kind of spaghetti code affectionately referred to as &quot;callback hell&quot;.</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;The Future-based API looks like this:</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;```</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;SemiFuture&lt;GetReply&gt; future_get(string key);</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;```</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;A `SemiFuture&lt;GetReply&gt;` or `Future&lt;GetReply&gt;` is a placeholder for the `GetReply` that we will eventually get. For most of the descriptive text below, Future can refer to either `folly::SemiFuture` or `folly::Future` as the former is a safe subset of the latter. A Future usually starts life out &quot;unfulfilled&quot;, or incomplete, i.e.:</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;```</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;fut.isReady() == false</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;fut.value()  // will throw an exception because the Future is not ready</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;```</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;At some point in the future, the `Future` will have been fulfilled, and we can access its value.</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;```</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;fut.isReady() == true</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;GetReply&amp; reply = fut.value();</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;```</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;Futures support exceptions. If the asynchronous producer fails with an exception, your Future may represent an exception instead of a value. In that case:</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;```</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;fut.isReady() == true</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;fut.value() // will rethrow the exception</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;```</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;Just what is exceptional depends on the API. In our example we have chosen not to raise exceptions for `SERVER_ERROR`, but represent this explicitly in the `GetReply` object. On the other hand, an astute Memcache veteran would notice that we left `CLIENT_ERROR` out of `GetReply::Result`, and perhaps a `CLIENT_ERROR` would have been raised as an exception, because `CLIENT_ERROR` means there&#39;s a bug in the library and this would be truly exceptional. These decisions are judgement calls by the API designer. The important thing is that exceptional conditions (including and especially spurious exceptions that nobody expects) get captured and can be handled higher up the &quot;stack&quot;.</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;So far we have described a way to initiate an asynchronous operation via an API that returns a Future, and then sometime later after it is fulfilled, we get its value. This is slightly more useful than a synchronous API, but it&#39;s not yet ideal. There are two more very important pieces to the puzzle.</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;First, we can aggregate Futures, to define a new Future that completes after some or all of the aggregated Futures complete. Consider two examples: fetching a batch of requests and waiting for all of them, and fetching a group of requests and waiting for only one of them.</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;```</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;MemcacheClient mc;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;vector&lt;SemiFuture&lt;GetReply&gt;&gt; futs;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;for (auto&amp; key : keys) {</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  futs.push_back(mc.future_get(key));</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;}</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;auto all = collectAll(futs.begin(), futs.end());</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;vector&lt;SemiFuture&lt;GetReply&gt;&gt; futs;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;for (auto&amp; key : keys) {</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;  futs.push_back(mc.future_get(key));</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;}</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;auto any = collectAny(futs.begin(), futs.end());</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;```</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;`all` and `any` are Futures (for the exact type and usage see the header files). They will be complete when all/one of futs are complete, respectively. (There is also `collectN()` for when you need some.)</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;Second, we can associate a Future with an executor. An executor specifies where work will run, and we detail this more later. In summary, given an executor we can convert a `SemiFuture` to a `Future` with an executor, or a `Future` on one executor to a `Future` on another executor.</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;For example:</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;```</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;folly::ThreadedExecutor executor;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;SemiFuture&lt;GetReply&gt; semiFut = mc.future_get(&quot;foo&quot;);</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;Future&lt;GetReply&gt; fut1 = std::move(semiFut).via(&amp;executor);</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;```</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;Once an executor is attached, a `Future` allows continuations to be attached and chained together monadically. An example will clarify:</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;```</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;SemiFuture&lt;GetReply&gt; semiFut = mc.future_get(&quot;foo&quot;);</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;Future&lt;GetReply&gt; fut1 = std::move(semiFut).via(&amp;executor);</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;Future&lt;string&gt; fut2 = std::move(fut1).thenValue(</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;  [](GetReply reply) {</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    if (reply.result == MemcacheClient::GetReply::Result::FOUND)</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;      return reply.value;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    throw SomeException(&quot;No value&quot;);</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;  });</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;Future&lt;Unit&gt; fut3 = std::move(fut2)</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;  .thenValue([](string str) {</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    cout &lt;&lt; str &lt;&lt; endl;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;  })</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;  .thenTry([](folly::Try&lt;string&gt; strTry) {</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    cout &lt;&lt; strTry.value() &lt;&lt; endl;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;  })</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;  .thenError&lt;std::exception&gt;([](std::exception const&amp; e) {</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    cerr &lt;&lt; e.what() &lt;&lt; endl;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;  });</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;```</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;That example is a little contrived but the idea is that you can transform a result from one type to another, potentially in a chain, and unhandled errors propagate. Of course, the intermediate variables are optional.</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;Using `.thenValue` or `.thenTry` to add callbacks is idiomatic. It brings all the code into one place, which avoids callback hell. `.thenValue` appends a continuation that takes `T&amp;&amp;` for some `Future&lt;T&gt;` and an error bypasses the callback and is passed to the next, `thenTry` takes a callback taking `folly::Try&lt;T&gt;` which encapsulates both value and exception. `thenError&lt;ExceptionType&gt;` will bypass a value and only run if there is an exception, the `ExceptionType` template parameter allows filtering by exception type; `ExceptionType` is optional and if not passed the function will be parameterised with a `folly::exception_wrapper`.</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;Up to this point we have skirted around the matter of waiting for Futures. You may never need to wait for a Future, because your code is event-driven and all follow-up action happens in a then-block. But if want to have a batch workflow, where you initiate a batch of asynchronous operations and then wait for them all to finish at a synchronization point, then you will want to wait for a Future. Futures have a blocking method called `wait()` that does exactly that and optionally takes a timeout.</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;Futures are partially threadsafe. A Promise or Future can migrate between threads as long as there&#39;s a full memory barrier of some sort. `Future::thenValue` and `Promise::setValue` (and all variants that boil down to those two calls) can be called from different threads. **But**, be warned that you might be surprised about which thread your callback executes on. Let&#39;s consider an example, where we take a future straight from a promise, without going via the safer SemiFuture, and where we therefore have a `Future` that does not carry an executor. This is in general something to avoid.</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;```</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;// Thread A</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;Promise&lt;Unit&gt; p;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;auto f = p.getFuture();</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;// Thread B</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;std::move(f).thenValue(x).thenValue(y).thenTry(z);</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;// Thread A</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;p.setValue();</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;```</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;This is legal and technically threadsafe. However, it is important to realize that you do not know in which thread `x`, `y`, and/or `z` will execute. Maybe they will execute in Thread A when `p.setValue()` is called. Or, maybe they will execute in Thread B when `f.thenValue` is called. Or, maybe `x` will execute in Thread A, but `y` and/or `z` will execute in Thread B. There&#39;s a race between `setValue` and `then`—whichever runs last will execute the callback. The only guarantee is that one of them will run the callback.</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;For safety, `.via` should be preferred. We can chain `.via` operations to give very strong control over where callbacks run:</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;```</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;std::move(aFuture)</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;  .thenValue(x)</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;  .via(e1).thenValue(y1).thenValue(y2)</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;  .via(e2).thenValue(z);</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;```</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;`x` will execute in the context of the executor associated with `aFuture`. `y1` and `y2` will execute in the context of `e1`, and `z` will execute in the context of `e2`. If after `z` you want to get back to the original context, you need to get there with a call to `via` passing the original executor. Another way to express this is using an overload of `then` that takes an Executor:</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;```</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;std::move(aFuture)</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;  .thenValue(x)</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;  .thenValue(e1, y1, y2)</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;  .thenValue(e2, z);</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;```</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;Either way, there is no ambiguity about which executor will run `y1`, `y2`, or `z`.</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;You can still have a race after `via` if you break it into multiple statements, e.g. in this counterexample:</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;```</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;f2 = std::move(f).via(e1).thenValue(y1).thenValue(y2); // nothing racy here</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;std::move(f2).thenValue(y3); // racy</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;```</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;# You make me Promises, Promises</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;If you are wrapping an asynchronous operation, or providing an asynchronous API to users, then you will want to make `Promise`s. Every Future has a corresponding Promise (except Futures that spring into existence already completed, with `makeFuture()`). Promises are simple: you make one, you extract the Future, and you fulfill it with a value or an exception. Example:</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;```</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;Promise&lt;int&gt; p;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;SemiFuture&lt;int&gt; f = p.getSemiFuture();</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;f.isReady() == false</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;p.setValue(42);</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;f.isReady() == true</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;f.value() == 42</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;```</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;and an exception example:</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;```</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;Promise&lt;int&gt; p;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;SemiFuture&lt;int&gt; f = p.getSemiFuture();</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;f.isReady() == false</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;p.setException(std::runtime_error(&quot;Fail&quot;));</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;f.isReady() == true</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;f.value() // throws the exception</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;```</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;It&#39;s good practice to use setWith which takes a function and automatically captures exceptions, e.g.</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;```</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;Promise&lt;int&gt; p;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;p.setWith([]{</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;  try {</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;    // do stuff that may throw</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    return 42;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;  } catch (MySpecialException const&amp; e) {</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    // handle it</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    return 7;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;  }</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;  // Any exceptions that we didn&#39;t catch, will be caught for us</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;});</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;```</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="Futures_8md.html">Futures.md</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
