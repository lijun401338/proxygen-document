<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="DistributedMutex_8h_source.html">DistributedMutex.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutexStateProxy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aea758280455d5d54df56c2fa1919e4bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#aea758280455d5d54df56c2fa1919e4bf">DistributedMutex</a> ()</td></tr>
<tr class="separator:aea758280455d5d54df56c2fa1919e4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfd0b66b737e422b421312db1bb8e73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a1dfd0b66b737e422b421312db1bb8e73">DistributedMutex</a> (<a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a1dfd0b66b737e422b421312db1bb8e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4da9faea0adb3a15068784df2aea131"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#af4da9faea0adb3a15068784df2aea131">DistributedMutex</a> (const <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a> &amp;)=delete</td></tr>
<tr class="separator:af4da9faea0adb3a15068784df2aea131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b75c245d2b24db544e990de0e09002"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#ac6b75c245d2b24db544e990de0e09002">operator=</a> (<a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ac6b75c245d2b24db544e990de0e09002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354432cf32bcaf408febec14d6c0303c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a354432cf32bcaf408febec14d6c0303c">operator=</a> (const <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a> &amp;)=delete</td></tr>
<tr class="separator:a354432cf32bcaf408febec14d6c0303c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c5d1b40693aa78f4d57f97a9cdea25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutexStateProxy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a85c5d1b40693aa78f4d57f97a9cdea25">lock</a> ()</td></tr>
<tr class="separator:a85c5d1b40693aa78f4d57f97a9cdea25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64302904ce02bc0f284cff945ea4f87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#ac64302904ce02bc0f284cff945ea4f87">unlock</a> (<a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutexStateProxy</a>)</td></tr>
<tr class="separator:ac64302904ce02bc0f284cff945ea4f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4f202428ece047e471c81c2d6920ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutexStateProxy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#acf4f202428ece047e471c81c2d6920ed">try_lock</a> ()</td></tr>
<tr class="separator:acf4f202428ece047e471c81c2d6920ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a3d59dfd50175ad8de0d0ed97d34f9"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:ad1a3d59dfd50175ad8de0d0ed97d34f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutexStateProxy</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#ad1a3d59dfd50175ad8de0d0ed97d34f9">try_lock_for</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;duration)</td></tr>
<tr class="separator:ad1a3d59dfd50175ad8de0d0ed97d34f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833e91611ebf3e222d9ea77c288a5d3c"><td class="memTemplParams" colspan="2">template&lt;typename Clock , typename Duration &gt; </td></tr>
<tr class="memitem:a833e91611ebf3e222d9ea77c288a5d3c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutexStateProxy</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a833e91611ebf3e222d9ea77c288a5d3c">try_lock_until</a> (const std::chrono::time_point&lt; Clock, <a class="el" href="namespacefolly.html#ad1989ff61ba788d22aa07cb22f8c5c49">Duration</a> &gt; &amp;deadline)</td></tr>
<tr class="separator:a833e91611ebf3e222d9ea77c288a5d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a068b1e6f8cd70e544be2f25f39632529"><td class="memItemLeft" align="right" valign="top">Atomic&lt; std::uintptr_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a068b1e6f8cd70e544be2f25f39632529">state_</a> {0}</td></tr>
<tr class="separator:a068b1e6f8cd70e544be2f25f39632529"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;template&lt; typename &gt; class Atomic = std::atomic, bool TimePublishing = true&gt;<br />
class folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;</h3>

<p><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a> is a small, exclusive-only mutex that distributes the bookkeeping required for mutual exclusion in the stacks of threads that are contending for it. It tries to come at a lower space cost than std::mutex while still trying to maintain the fairness benefits that come from using std::mutex. <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a> provides the entire API included in std::mutex, and more, with slight modifications. <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a> is the same width as a single pointer (8 bytes on most platforms), where on the other hand, std::mutex and pthread_mutex_t are both 40 bytes. It is larger than some of the other smaller locks, but the wide majority of cases using the small locks are wasting the difference in alignment padding anyway</p>
<p>Benchmark results are good - at the time of writing in the common uncontended case, it is 30% faster than some of the other small mutexes in folly and as fast as std::mutex, which recently optimized its uncontended path. In the contended case, it is about 4-5x faster than some of the smaller locks in folly, ~2x faster than std::mutex in clang and ~1.8x faster in gcc. <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a> is also resistent to tail latency pathalogies unlike many of the other small mutexes. Which sleep for large time quantums to reduce spin churn, this causes elevated latencies for threads that enter the sleep cycle. The tail latency of lock acquisition on average up to 10x better with <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a></p>
<p><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a> reduces cache line contention by making each thread wait on a thread local spinlock and futex. This allows threads to keep working only on their own cache lines without requiring cache coherence operations when a mutex heavy contention. This strategy does not require sequential ordering on the centralized atomic storage for wakeup operations as each thread assigned its own wait state</p>
<p>Non-timed mutex acquisitions are scheduled through intrusive LIFO contention chains. Each thread starts by spinning for a short quantum and falls back to two phased sleeping. Enqueue operations are lock free and are piggybacked off mutex acquisition attempts. The LIFO behavior of a contention chain is good in the case where the mutex is held for a short amount of time, as the head of the chain is likely to not have slept on futex() after exhausting its spin quantum. This allow us to avoid unnecessary traversal and syscalls in the fast path with a higher probability. Even though the contention chains are LIFO, the mutex itself does not adhere to that scheduling policy globally. During contention, threads that fail to lock the mutex form a LIFO chain on the central mutex state, this chain is broken when a wakeup is scheduled, and future enqueue operations form a new chain. This makes the chains themselves LIFO, but preserves global fairness through a constant factor which is limited to the number of concurrent failed mutex acquisition attempts. This binds the last in first out behavior to the number of contending threads and helps prevent starvation and latency outliers</p>
<p>This strategy of waking up wakers one by one in a queue does not scale well when the number of threads goes past the number of cores. At which point preemption causes elevated lock acquisition latencies. <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a> implements a hardware timestamp publishing heuristic to detect and adapt to preemption.</p>
<p><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a> does not have the typical mutex API - it does not satisfy the Lockable concept. It requires the user to maintain ephemeral bookkeeping and pass that bookkeeping around to <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#ac64302904ce02bc0f284cff945ea4f87">unlock()</a> calls. The API overhead, however, comes for free when you wrap this mutex for usage with <a class="el" href="structfolly_1_1Synchronized.html">folly::Synchronized</a> or std::unique_lock, which is the recommended usage (std::lock_guard, in optimized mode, has no performance benefit over std::unique_lock, so has been omitted). <a class="el" href="structA.html">A</a> benefit of this API is that it disallows incorrect usage where a thread unlocks a mutex that it does not own, thinking a mutex is functionally identical to a binary semaphore, which, unlike a mutex, is a suitable primitive for that usage</p>
<p>Timed locking through <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a> is implemented through a centralized algorithm - all waiters wait on the central mutex state, by setting and resetting bits within the pointer-length word. Since pointer length atomic integers are incompatible with futex(FUTEX_WAIT) on most systems, a non-standard implementation of futex() is used, where wait queues are managed in user-space. See p1135r0 and <a class="el" href="classfolly_1_1ParkingLot.html">folly::ParkingLot</a> </p>

<p>Definition at line <a class="el" href="DistributedMutex_8h_source.html#l00101">101</a> of file <a class="el" href="DistributedMutex_8h_source.html">DistributedMutex.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aea758280455d5d54df56c2fa1919e4bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class Atomic, bool TimePublishing&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">folly::detail::distributed_mutex::DistributedMutex</a>&lt; Atomic, TimePublishing &gt;::<a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a> is only default constructible, it can neither be moved nor copied </p>

<p>Definition at line <a class="el" href="DistributedMutex-inl_8h_source.html#l00305">305</a> of file <a class="el" href="DistributedMutex-inl_8h_source.html">DistributedMutex-inl.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;    : <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a068b1e6f8cd70e544be2f25f39632529">state_</a>{<a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#ae61a75661ba545362f7b3e729d8dffbc">kUnlocked</a>} {}</div><div class="ttc" id="namespacefolly_1_1detail_1_1distributed__mutex_html_ae61a75661ba545362f7b3e729d8dffbc"><div class="ttname"><a href="namespacefolly_1_1detail_1_1distributed__mutex.html#ae61a75661ba545362f7b3e729d8dffbc">folly::detail::distributed_mutex::kUnlocked</a></div><div class="ttdeci">constexpr auto kUnlocked</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex-inl_8h_source.html#l00047">DistributedMutex-inl.h:47</a></div></div>
<div class="ttc" id="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_html_a068b1e6f8cd70e544be2f25f39632529"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a068b1e6f8cd70e544be2f25f39632529">folly::detail::distributed_mutex::DistributedMutex::state_</a></div><div class="ttdeci">Atomic&lt; std::uintptr_t &gt; state_</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex_8h_source.html#l00177">DistributedMutex.h:177</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1dfd0b66b737e422b421312db1bb8e73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class Atomic = std::atomic, bool TimePublishing = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">folly::detail::distributed_mutex::DistributedMutex</a>&lt; Atomic, TimePublishing &gt;::<a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a>&lt; Atomic, TimePublishing &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af4da9faea0adb3a15068784df2aea131"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class Atomic = std::atomic, bool TimePublishing = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">folly::detail::distributed_mutex::DistributedMutex</a>&lt; Atomic, TimePublishing &gt;::<a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a>&lt; Atomic, TimePublishing &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a85c5d1b40693aa78f4d57f97a9cdea25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class Atomic, bool TimePublishing&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a>&lt; Atomic, TimePublishing &gt;::<a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutexStateProxy</a> <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">folly::detail::distributed_mutex::DistributedMutex</a>&lt; Atomic, TimePublishing &gt;::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquires the mutex in exclusive mode</p>
<p>This returns an ephemeral proxy that contains internal mutex state. This must be kept around for the duration of the critical section and passed subsequently to <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#ac64302904ce02bc0f284cff945ea4f87">unlock()</a> as an rvalue</p>
<p>The proxy has no public API and is intended to be for internal usage only</p>
<p>This is not a recursive mutex - trying to acquire the mutex twice from the same thread without unlocking it results in undefined behavior </p>

<p>Definition at line <a class="el" href="DistributedMutex-inl_8h_source.html#l00455">455</a> of file <a class="el" href="DistributedMutex-inl_8h_source.html">DistributedMutex-inl.h</a>.</p>

<p>References <a class="el" href="DistributedMutex-inl_8h_source.html#l00199">folly::detail::distributed_mutex::extractAddress()</a>, <a class="el" href="DistributedMutex-inl_8h_source.html#l00088">folly::detail::distributed_mutex::kAboutToWait</a>, <a class="el" href="DistributedMutex-inl_8h_source.html#l00054">folly::detail::distributed_mutex::kLocked</a>, <a class="el" href="DistributedMutex-inl_8h_source.html#l00076">folly::detail::distributed_mutex::kUninitialized</a>, <a class="el" href="fizz_2build___2gtest_2src_2gtest_2googlemock_2scripts_2generator_2cpp_2ast_8py_source.html#l00058">cpp.ast::next()</a>, <a class="el" href="DistributedMutex-inl_8h_source.html#l00437">folly::detail::distributed_mutex::recordTimedWaiterAndClearTimedBit()</a>, <a class="el" href="DistributedMutex_8h_source.html#l00177">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;::state_</a>, <a class="el" href="F14TestUtil_8h_source.html#l00414">folly::f14::swap()</a>, <a class="el" href="DistributedMutex-inl_8h_source.html#l00766">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;::try_lock()</a>, and <a class="el" href="DistributedMutex-inl_8h_source.html#l00429">folly::detail::distributed_mutex::wait()</a>.</p>

<p>Referenced by <a class="el" href="SmallLocksBenchmark_8cpp_source.html#l00044">burn()</a>.</p>
<div class="fragment"><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;                                               {</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;  <span class="comment">// first try and acquire the lock as a fast path, the underlying</span></div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;  <span class="comment">// implementation is slightly faster than using std::atomic::exchange() as</span></div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;  <span class="comment">// is used in this function.  So we get a small perf boost in the</span></div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;  <span class="comment">// uncontended case</span></div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> <a class="code" href="http__parser_8c.html#adc6e5733fc3c22f0a7b2914188c49c90">state</a> = <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#acf4f202428ece047e471c81c2d6920ed">try_lock</a>()) {</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="http__parser_8c.html#adc6e5733fc3c22f0a7b2914188c49c90">state</a>;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;  }</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;  <span class="keyword">auto</span> previous = std::uintptr_t{0};</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;  <span class="keyword">auto</span> waitMode = <a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#a0330ce90130b3214c3984b2ac6c17e3c">kUninitialized</a>;</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;  <span class="keyword">auto</span> nextWaitMode = <a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#a7535b199ea304941b1220fd9f3ebaf51">kAboutToWait</a>;</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;  <span class="keyword">auto</span> timedWaiter = <span class="keyword">false</span>;</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;  CachelinePadded&lt;Waiter&lt;Atomic&gt;&gt;* nextSleeper = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;  <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;    <span class="comment">// construct the state needed to wait</span></div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;    <span class="keyword">auto</span>&amp;&amp; <a class="code" href="http__parser_8c.html#adc6e5733fc3c22f0a7b2914188c49c90">state</a> = CachelinePadded&lt;Waiter&lt;Atomic&gt;&gt;{waitMode};</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;    <span class="keyword">auto</span>&amp;&amp; address = <span class="keyword">reinterpret_cast&lt;</span>std::uintptr_t<span class="keyword">&gt;</span>(&amp;<a class="code" href="http__parser_8c.html#adc6e5733fc3c22f0a7b2914188c49c90">state</a>);</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    DCHECK(!(address &amp; 0b1));</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    <span class="comment">// set the locked bit in the address we will be persisting in the mutex</span></div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    address |= <a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#a70ac38c3aaa1e9d2ac764c5fac819abb">kLocked</a>;</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;    <span class="comment">// attempt to acquire the mutex, mutex acquisition is successful if the</span></div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;    <span class="comment">// previous value is zeroed out</span></div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    <span class="comment">// we use memory_order_acq_rel here because we want the read-modify-write</span></div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;    <span class="comment">// operation to be both acquire and release.  Acquire becasue if this is a</span></div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;    <span class="comment">// successful lock acquisition, we want to acquire state any other thread</span></div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    <span class="comment">// has released from a prior unlock.  We want release semantics becasue</span></div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;    <span class="comment">// other threads that read the address of this value should see the full</span></div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    <span class="comment">// well-initialized node we are going to wait on if the mutex acquisition</span></div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    <span class="comment">// was unsuccessful</span></div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    previous = <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a068b1e6f8cd70e544be2f25f39632529">state_</a>.exchange(address, std::memory_order_acq_rel);</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;    <a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#a36fff543f1be7027272969d8ee93bca9">recordTimedWaiterAndClearTimedBit</a>(timedWaiter, previous);</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;    <a class="code" href="http__parser_8c.html#adc6e5733fc3c22f0a7b2914188c49c90">state</a>-&gt;next_ = previous;</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;    <span class="keywordflow">if</span> (previous == <a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#ae61a75661ba545362f7b3e729d8dffbc">kUnlocked</a>) {</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;      <span class="keywordflow">return</span> {<span class="keyword">nullptr</span>, address, timedWaiter, {}, <span class="keyword">nullptr</span>, nextSleeper};</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    }</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    DCHECK(previous &amp; <a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#a70ac38c3aaa1e9d2ac764c5fac819abb">kLocked</a>);</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;    <span class="comment">// wait until we get a signal from another thread, if this returns false,</span></div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;    <span class="comment">// we got skipped and had probably been scheduled out, so try again</span></div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#a9e90bda6a29ab15bc2efc5537e22b472">wait</a>(&amp;<a class="code" href="http__parser_8c.html#adc6e5733fc3c22f0a7b2914188c49c90">state</a>, (waitMode == <a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#a7535b199ea304941b1220fd9f3ebaf51">kAboutToWait</a>), nextSleeper)) {</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;      <a class="code" href="namespacefolly_1_1f14.html#a20b1454bd115690f6bccf4b9121f2b38">std::swap</a>(waitMode, nextWaitMode);</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;    }</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;    <span class="comment">// at this point it is safe to access the other fields in the waiter state,</span></div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;    <span class="comment">// since the thread that woke us up is gone and nobody will be touching this</span></div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;    <span class="comment">// state again, note that this requires memory ordering, and this is why we</span></div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;    <span class="comment">// use memory_order_acquire (among other reasons) in the above wait</span></div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;    <span class="comment">// first we see if the value we took off the mutex state was the thread that</span></div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;    <span class="comment">// initated the wakeups, if so, we are the terminal node of the current</span></div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;    <span class="comment">// contention chain.  If we are the terminal node, then we should expect to</span></div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;    <span class="comment">// see a kLocked in the mutex state when we unlock, if we see that, we can</span></div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;    <span class="comment">// commit the unlock to the centralized mutex state.  If not, we need to</span></div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;    <span class="comment">// continue wakeups</span></div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;    <span class="comment">// a nice consequence of passing kLocked as the current address if we are</span></div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;    <span class="comment">// the terminal node is that it naturally just works with the algorithm.  If</span></div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;    <span class="comment">// we get a contention chain when coming out of a contention chain, the tail</span></div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;    <span class="comment">// of the new contention chain will have kLocked set as the previous, which,</span></div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;    <span class="comment">// as it happens &quot;just works&quot;, since we have now established a recursive</span></div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;    <span class="comment">// relationship until broken</span></div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;    <span class="keyword">auto</span> <a class="code" href="namespacecpp_1_1ast.html#a25bc7c34a56f66f8e68856ab63c7e990">next</a> = previous;</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;    <span class="keyword">auto</span> expected = address;</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;    <span class="keywordflow">if</span> (previous == <a class="code" href="http__parser_8c.html#adc6e5733fc3c22f0a7b2914188c49c90">state</a>-&gt;wakerMetadata_.waker_) {</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;      <a class="code" href="namespacecpp_1_1ast.html#a25bc7c34a56f66f8e68856ab63c7e990">next</a> = 0;</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;      expected = <a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#a70ac38c3aaa1e9d2ac764c5fac819abb">kLocked</a>;</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;    }</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;    <span class="comment">// if we are just coming out of a futex call, then it means that the next</span></div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;    <span class="comment">// waiter we are responsible for is also a waiter waiting on a futex, so</span></div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;    <span class="comment">// we return that list in the list of ready threads.  We wlil be waking up</span></div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;    <span class="comment">// the ready threads on unlock no matter what</span></div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;    <span class="keywordflow">return</span> {extractAddress&lt;CachelinePadded&lt;Waiter&lt;Atomic&gt;&gt;&gt;(<a class="code" href="namespacecpp_1_1ast.html#a25bc7c34a56f66f8e68856ab63c7e990">next</a>),</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;            expected,</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;            timedWaiter,</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;            <a class="code" href="http__parser_8c.html#adc6e5733fc3c22f0a7b2914188c49c90">state</a>-&gt;wakerMetadata_,</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;            <a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#ac5036b8070b4c31dda7da8674363dde0">extractAddress</a>&lt;CachelinePadded&lt;Waiter&lt;Atomic&gt;&gt;&gt;(<a class="code" href="http__parser_8c.html#adc6e5733fc3c22f0a7b2914188c49c90">state</a>-&gt;waiters_),</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;            nextSleeper};</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;  }</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;}</div><div class="ttc" id="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_html_acf4f202428ece047e471c81c2d6920ed"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#acf4f202428ece047e471c81c2d6920ed">folly::detail::distributed_mutex::DistributedMutex::try_lock</a></div><div class="ttdeci">DistributedMutexStateProxy try_lock()</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex-inl_8h_source.html#l00766">DistributedMutex-inl.h:766</a></div></div>
<div class="ttc" id="namespacefolly_1_1detail_1_1distributed__mutex_html_ac5036b8070b4c31dda7da8674363dde0"><div class="ttname"><a href="namespacefolly_1_1detail_1_1distributed__mutex.html#ac5036b8070b4c31dda7da8674363dde0">folly::detail::distributed_mutex::extractAddress</a></div><div class="ttdeci">Type * extractAddress(std::uintptr_t from)</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex-inl_8h_source.html#l00199">DistributedMutex-inl.h:199</a></div></div>
<div class="ttc" id="namespacefolly_1_1detail_1_1distributed__mutex_html_a36fff543f1be7027272969d8ee93bca9"><div class="ttname"><a href="namespacefolly_1_1detail_1_1distributed__mutex.html#a36fff543f1be7027272969d8ee93bca9">folly::detail::distributed_mutex::recordTimedWaiterAndClearTimedBit</a></div><div class="ttdeci">void recordTimedWaiterAndClearTimedBit(bool &amp;timedWaiter, std::uintptr_t &amp;previous)</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex-inl_8h_source.html#l00437">DistributedMutex-inl.h:437</a></div></div>
<div class="ttc" id="namespacefolly_1_1detail_1_1distributed__mutex_html_a9e90bda6a29ab15bc2efc5537e22b472"><div class="ttname"><a href="namespacefolly_1_1detail_1_1distributed__mutex.html#a9e90bda6a29ab15bc2efc5537e22b472">folly::detail::distributed_mutex::wait</a></div><div class="ttdeci">bool wait(Waiter *waiter, bool shouldSleep, Waiter *&amp;next)</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex-inl_8h_source.html#l00429">DistributedMutex-inl.h:429</a></div></div>
<div class="ttc" id="namespacefolly_1_1detail_1_1distributed__mutex_html_a7535b199ea304941b1220fd9f3ebaf51"><div class="ttname"><a href="namespacefolly_1_1detail_1_1distributed__mutex.html#a7535b199ea304941b1220fd9f3ebaf51">folly::detail::distributed_mutex::kAboutToWait</a></div><div class="ttdeci">constexpr auto kAboutToWait</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex-inl_8h_source.html#l00088">DistributedMutex-inl.h:88</a></div></div>
<div class="ttc" id="namespacefolly_1_1f14_html_a20b1454bd115690f6bccf4b9121f2b38"><div class="ttname"><a href="namespacefolly_1_1f14.html#a20b1454bd115690f6bccf4b9121f2b38">folly::f14::swap</a></div><div class="ttdeci">void swap(SwapTrackingAlloc&lt; T &gt; &amp;, SwapTrackingAlloc&lt; T &gt; &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="F14TestUtil_8h_source.html#l00414">F14TestUtil.h:414</a></div></div>
<div class="ttc" id="namespacefolly_1_1detail_1_1distributed__mutex_html_ae61a75661ba545362f7b3e729d8dffbc"><div class="ttname"><a href="namespacefolly_1_1detail_1_1distributed__mutex.html#ae61a75661ba545362f7b3e729d8dffbc">folly::detail::distributed_mutex::kUnlocked</a></div><div class="ttdeci">constexpr auto kUnlocked</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex-inl_8h_source.html#l00047">DistributedMutex-inl.h:47</a></div></div>
<div class="ttc" id="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_html_a068b1e6f8cd70e544be2f25f39632529"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a068b1e6f8cd70e544be2f25f39632529">folly::detail::distributed_mutex::DistributedMutex::state_</a></div><div class="ttdeci">Atomic&lt; std::uintptr_t &gt; state_</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex_8h_source.html#l00177">DistributedMutex.h:177</a></div></div>
<div class="ttc" id="namespacefolly_1_1detail_1_1distributed__mutex_html_a0330ce90130b3214c3984b2ac6c17e3c"><div class="ttname"><a href="namespacefolly_1_1detail_1_1distributed__mutex.html#a0330ce90130b3214c3984b2ac6c17e3c">folly::detail::distributed_mutex::kUninitialized</a></div><div class="ttdeci">constexpr auto kUninitialized</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex-inl_8h_source.html#l00076">DistributedMutex-inl.h:76</a></div></div>
<div class="ttc" id="namespacefolly_1_1detail_1_1distributed__mutex_html_a70ac38c3aaa1e9d2ac764c5fac819abb"><div class="ttname"><a href="namespacefolly_1_1detail_1_1distributed__mutex.html#a70ac38c3aaa1e9d2ac764c5fac819abb">folly::detail::distributed_mutex::kLocked</a></div><div class="ttdeci">constexpr auto kLocked</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex-inl_8h_source.html#l00054">DistributedMutex-inl.h:54</a></div></div>
<div class="ttc" id="http__parser_8c_html_adc6e5733fc3c22f0a7b2914188c49c90"><div class="ttname"><a href="http__parser_8c.html#adc6e5733fc3c22f0a7b2914188c49c90">state</a></div><div class="ttdeci">state</div><div class="ttdef"><b>Definition:</b> <a href="http__parser_8c_source.html#l00272">http_parser.c:272</a></div></div>
<div class="ttc" id="namespacecpp_1_1ast_html_a25bc7c34a56f66f8e68856ab63c7e990"><div class="ttname"><a href="namespacecpp_1_1ast.html#a25bc7c34a56f66f8e68856ab63c7e990">cpp.ast.next</a></div><div class="ttdeci">def next(obj)</div><div class="ttdef"><b>Definition:</b> <a href="fizz_2build___2gtest_2src_2gtest_2googlemock_2scripts_2generator_2cpp_2ast_8py_source.html#l00058">ast.py:58</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac6b75c245d2b24db544e990de0e09002"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class Atomic = std::atomic, bool TimePublishing = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a>&amp; <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">folly::detail::distributed_mutex::DistributedMutex</a>&lt; Atomic, TimePublishing &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a>&lt; Atomic, TimePublishing &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a354432cf32bcaf408febec14d6c0303c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class Atomic = std::atomic, bool TimePublishing = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a>&amp; <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">folly::detail::distributed_mutex::DistributedMutex</a>&lt; Atomic, TimePublishing &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a>&lt; Atomic, TimePublishing &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acf4f202428ece047e471c81c2d6920ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class Atomic, bool TimePublishing&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a>&lt; Atomic, TimePublishing &gt;::<a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutexStateProxy</a> <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">folly::detail::distributed_mutex::DistributedMutex</a>&lt; Atomic, TimePublishing &gt;::try_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classfolly_1_1Try.html">Try</a> to acquire the mutex</p>
<p><a class="el" href="structA.html">A</a> non blocking version of the <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a85c5d1b40693aa78f4d57f97a9cdea25">lock()</a> function. The returned object is contextually convertible to bool. And has the value true when the mutex was successfully acquired, false otherwise</p>
<p>This is allowed to return false spuriously, i.e. this is not guaranteed to return true even when the mutex is currently unlocked. In the event of a failed acquisition, this does not impose any memory ordering constraints for other threads </p>

<p>Definition at line <a class="el" href="DistributedMutex-inl_8h_source.html#l00766">766</a> of file <a class="el" href="DistributedMutex-inl_8h_source.html">DistributedMutex-inl.h</a>.</p>

<p>References <a class="el" href="AtomicUtil-inl_8h_source.html#l00237">folly::atomic_fetch_set()</a>, and <a class="el" href="DistributedMutex_8h_source.html#l00177">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;::state_</a>.</p>

<p>Referenced by <a class="el" href="DistributedMutex-inl_8h_source.html#l00455">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;::lock()</a>, <a class="el" href="DistributedMutex-inl_8h_source.html#l00870">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;::try_lock_for()</a>, and <a class="el" href="DistributedMutex-inl_8h_source.html#l00847">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;::try_lock_until()</a>.</p>
<div class="fragment"><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;                                                   {</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;  <span class="comment">// Try and set the least significant bit of the centralized lock state to 1,</span></div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;  <span class="comment">// indicating locked.</span></div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;  <span class="comment">// If this succeeds, it must have been the case that we had a kUnlocked (or</span></div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;  <span class="comment">// 0) in the centralized storage before, since that is the only case where a</span></div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;  <span class="comment">// 0 can be found.  So we assert that in debug mode</span></div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;  <span class="comment">// If this fails, then it is a no-op</span></div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;  <span class="keyword">auto</span> previous = <a class="code" href="namespacefolly.html#aff1974bc7d52a2ee4207539efdf5c92c">atomic_fetch_set</a>(<a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a068b1e6f8cd70e544be2f25f39632529">state_</a>, 0, std::memory_order_acquire);</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;  <span class="keywordflow">if</span> (!previous) {</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;    <span class="keywordflow">return</span> {<span class="keyword">nullptr</span>, <a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#a70ac38c3aaa1e9d2ac764c5fac819abb">kLocked</a>};</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;  }</div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;</div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;  <span class="keywordflow">return</span> {<span class="keyword">nullptr</span>, 0};</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;}</div><div class="ttc" id="namespacefolly_html_aff1974bc7d52a2ee4207539efdf5c92c"><div class="ttname"><a href="namespacefolly.html#aff1974bc7d52a2ee4207539efdf5c92c">folly::atomic_fetch_set</a></div><div class="ttdeci">bool atomic_fetch_set(Atomic &amp;atomic, std::size_t bit, std::memory_order mo)</div><div class="ttdef"><b>Definition:</b> <a href="AtomicUtil-inl_8h_source.html#l00237">AtomicUtil-inl.h:237</a></div></div>
<div class="ttc" id="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_html_a068b1e6f8cd70e544be2f25f39632529"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a068b1e6f8cd70e544be2f25f39632529">folly::detail::distributed_mutex::DistributedMutex::state_</a></div><div class="ttdeci">Atomic&lt; std::uintptr_t &gt; state_</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex_8h_source.html#l00177">DistributedMutex.h:177</a></div></div>
<div class="ttc" id="namespacefolly_1_1detail_1_1distributed__mutex_html_a70ac38c3aaa1e9d2ac764c5fac819abb"><div class="ttname"><a href="namespacefolly_1_1detail_1_1distributed__mutex.html#a70ac38c3aaa1e9d2ac764c5fac819abb">folly::detail::distributed_mutex::kLocked</a></div><div class="ttdeci">constexpr auto kLocked</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex-inl_8h_source.html#l00054">DistributedMutex-inl.h:54</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad1a3d59dfd50175ad8de0d0ed97d34f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class Atomic, bool TimePublishing&gt; </div>
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a>&lt; Atomic, TimePublishing &gt;::<a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutexStateProxy</a> <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">folly::detail::distributed_mutex::DistributedMutex</a>&lt; Atomic, TimePublishing &gt;::try_lock_for </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classfolly_1_1Try.html">Try</a> to acquire the mutex, blocking for the given time</p>
<p>Like <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#acf4f202428ece047e471c81c2d6920ed">try_lock()</a>, this is allowed to fail spuriously and is not guaranteed to return false even when the mutex is currently unlocked. But only after the given time has elapsed</p>
<p><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#ad1a3d59dfd50175ad8de0d0ed97d34f9">try_lock_for()</a> accepts a duration to block for, and <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a833e91611ebf3e222d9ea77c288a5d3c">try_lock_until()</a> accepts an absolute wall clock time point </p>

<p>Definition at line <a class="el" href="DistributedMutex-inl_8h_source.html#l00870">870</a> of file <a class="el" href="DistributedMutex-inl_8h_source.html">DistributedMutex-inl.h</a>.</p>

<p>References <a class="el" href="Base_8h_source.html#l00811">folly::gen::as()</a>, <a class="el" href="TimekeeperTest_8cpp_source.html#l00031">now()</a>, <a class="el" href="DistributedMutex_8h_source.html#l00177">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;::state_</a>, <a class="el" href="DistributedMutex-inl_8h_source.html#l00784">folly::detail::distributed_mutex::timedLock()</a>, and <a class="el" href="DistributedMutex-inl_8h_source.html#l00766">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;::try_lock()</a>.</p>
<div class="fragment"><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;                                                    {</div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;  <span class="comment">// fast path for the uncontended case.  Reasoning for doing this here is the</span></div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;  <span class="comment">// same as in try_lock_until()</span></div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> <a class="code" href="http__parser_8c.html#adc6e5733fc3c22f0a7b2914188c49c90">state</a> = <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#acf4f202428ece047e471c81c2d6920ed">try_lock</a>()) {</div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="http__parser_8c.html#adc6e5733fc3c22f0a7b2914188c49c90">state</a>;</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;  }</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;</div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;  <span class="comment">// fall back to the timed locking algorithm</span></div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;  <span class="keyword">using</span> <a class="code" href="namespacefolly_1_1futures_1_1detail.html#a65fc9bd92314712dac70f428f92f6d3eaf56ec2ab97d604832d90f6394e3f341f">Proxy</a> = DistributedMutexStateProxy;</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;  <span class="keyword">auto</span> deadline = <a class="code" href="TimekeeperTest_8cpp.html#a562b4baa36dcf267f35a4ba4e0aef329">std::chrono::steady_clock::now</a>() + duration;</div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#a8b171e91ac5b735d4d270866d68d9458">timedLock</a>(<a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a068b1e6f8cd70e544be2f25f39632529">state_</a>, deadline, [](<span class="keyword">auto</span>... <a class="code" href="namespacefolly_1_1gen.html#ad2b6d41a026aaee797e48d6e888f59b6">as</a>) { <span class="keywordflow">return</span> <a class="code" href="namespacefolly_1_1futures_1_1detail.html#a65fc9bd92314712dac70f428f92f6d3eaf56ec2ab97d604832d90f6394e3f341f">Proxy</a>{<a class="code" href="namespacefolly_1_1gen.html#ad2b6d41a026aaee797e48d6e888f59b6">as</a>...}; });</div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;}</div><div class="ttc" id="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_html_acf4f202428ece047e471c81c2d6920ed"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#acf4f202428ece047e471c81c2d6920ed">folly::detail::distributed_mutex::DistributedMutex::try_lock</a></div><div class="ttdeci">DistributedMutexStateProxy try_lock()</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex-inl_8h_source.html#l00766">DistributedMutex-inl.h:766</a></div></div>
<div class="ttc" id="TimekeeperTest_8cpp_html_a562b4baa36dcf267f35a4ba4e0aef329"><div class="ttname"><a href="TimekeeperTest_8cpp.html#a562b4baa36dcf267f35a4ba4e0aef329">now</a></div><div class="ttdeci">std::chrono::steady_clock::time_point now()</div><div class="ttdef"><b>Definition:</b> <a href="TimekeeperTest_8cpp_source.html#l00031">TimekeeperTest.cpp:31</a></div></div>
<div class="ttc" id="namespacefolly_1_1gen_html_ad2b6d41a026aaee797e48d6e888f59b6"><div class="ttname"><a href="namespacefolly_1_1gen.html#ad2b6d41a026aaee797e48d6e888f59b6">folly::gen::as</a></div><div class="ttdeci">Collect as()</div><div class="ttdef"><b>Definition:</b> <a href="Base_8h_source.html#l00811">Base.h:811</a></div></div>
<div class="ttc" id="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_html_a068b1e6f8cd70e544be2f25f39632529"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a068b1e6f8cd70e544be2f25f39632529">folly::detail::distributed_mutex::DistributedMutex::state_</a></div><div class="ttdeci">Atomic&lt; std::uintptr_t &gt; state_</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex_8h_source.html#l00177">DistributedMutex.h:177</a></div></div>
<div class="ttc" id="namespacefolly_1_1futures_1_1detail_html_a65fc9bd92314712dac70f428f92f6d3eaf56ec2ab97d604832d90f6394e3f341f"><div class="ttname"><a href="namespacefolly_1_1futures_1_1detail.html#a65fc9bd92314712dac70f428f92f6d3eaf56ec2ab97d604832d90f6394e3f341f">folly::futures::detail::State::Proxy</a></div></div>
<div class="ttc" id="http__parser_8c_html_adc6e5733fc3c22f0a7b2914188c49c90"><div class="ttname"><a href="http__parser_8c.html#adc6e5733fc3c22f0a7b2914188c49c90">state</a></div><div class="ttdeci">state</div><div class="ttdef"><b>Definition:</b> <a href="http__parser_8c_source.html#l00272">http_parser.c:272</a></div></div>
<div class="ttc" id="namespacefolly_1_1detail_1_1distributed__mutex_html_a8b171e91ac5b735d4d270866d68d9458"><div class="ttname"><a href="namespacefolly_1_1detail_1_1distributed__mutex.html#a8b171e91ac5b735d4d270866d68d9458">folly::detail::distributed_mutex::timedLock</a></div><div class="ttdeci">auto timedLock(Atomic &amp;state, Deadline deadline, MakeProxy proxy)</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex-inl_8h_source.html#l00784">DistributedMutex-inl.h:784</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a833e91611ebf3e222d9ea77c288a5d3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class Atomic, bool TimePublishing&gt; </div>
<div class="memtemplate">
template&lt;typename Clock , typename Duration &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a>&lt; Atomic, TimePublishing &gt;::<a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutexStateProxy</a> <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">folly::detail::distributed_mutex::DistributedMutex</a>&lt; Atomic, TimePublishing &gt;::try_lock_until </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, <a class="el" href="namespacefolly.html#ad1989ff61ba788d22aa07cb22f8c5c49">Duration</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>deadline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classfolly_1_1Try.html">Try</a> to acquire the lock, blocking until the given deadline</p>
<p>Other than the difference in the meaning of the second argument, the semantics of this function are identical to <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#ad1a3d59dfd50175ad8de0d0ed97d34f9">try_lock_for()</a> </p>

<p>Definition at line <a class="el" href="DistributedMutex-inl_8h_source.html#l00847">847</a> of file <a class="el" href="DistributedMutex-inl_8h_source.html">DistributedMutex-inl.h</a>.</p>

<p>References <a class="el" href="Base_8h_source.html#l00811">folly::gen::as()</a>, <a class="el" href="DistributedMutex_8h_source.html#l00177">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;::state_</a>, <a class="el" href="DistributedMutex-inl_8h_source.html#l00784">folly::detail::distributed_mutex::timedLock()</a>, and <a class="el" href="DistributedMutex-inl_8h_source.html#l00766">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;::try_lock()</a>.</p>
<div class="fragment"><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;                                                          {</div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;  <span class="comment">// fast path for the uncontended case</span></div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;  <span class="comment">// we get the time after trying to acquire the mutex because in the</span></div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;  <span class="comment">// uncontended case, the price of getting the time is about 1/3 of the</span></div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;  <span class="comment">// actual mutex acquisition.  So we only pay the price of that extra bit of</span></div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;  <span class="comment">// latency when needed</span></div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;  <span class="comment">// this is even higher when VDSO is involved on architectures that do not</span></div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;  <span class="comment">// offer a direct interface to the timestamp counter</span></div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> <a class="code" href="http__parser_8c.html#adc6e5733fc3c22f0a7b2914188c49c90">state</a> = <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#acf4f202428ece047e471c81c2d6920ed">try_lock</a>()) {</div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="http__parser_8c.html#adc6e5733fc3c22f0a7b2914188c49c90">state</a>;</div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;  }</div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;</div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;  <span class="comment">// fall back to the timed locking algorithm</span></div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;  <span class="keyword">using</span> <a class="code" href="namespacefolly_1_1futures_1_1detail.html#a65fc9bd92314712dac70f428f92f6d3eaf56ec2ab97d604832d90f6394e3f341f">Proxy</a> = DistributedMutexStateProxy;</div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#a8b171e91ac5b735d4d270866d68d9458">timedLock</a>(<a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a068b1e6f8cd70e544be2f25f39632529">state_</a>, deadline, [](<span class="keyword">auto</span>... <a class="code" href="namespacefolly_1_1gen.html#ad2b6d41a026aaee797e48d6e888f59b6">as</a>) { <span class="keywordflow">return</span> <a class="code" href="namespacefolly_1_1futures_1_1detail.html#a65fc9bd92314712dac70f428f92f6d3eaf56ec2ab97d604832d90f6394e3f341f">Proxy</a>{<a class="code" href="namespacefolly_1_1gen.html#ad2b6d41a026aaee797e48d6e888f59b6">as</a>...}; });</div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;}</div><div class="ttc" id="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_html_acf4f202428ece047e471c81c2d6920ed"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#acf4f202428ece047e471c81c2d6920ed">folly::detail::distributed_mutex::DistributedMutex::try_lock</a></div><div class="ttdeci">DistributedMutexStateProxy try_lock()</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex-inl_8h_source.html#l00766">DistributedMutex-inl.h:766</a></div></div>
<div class="ttc" id="namespacefolly_1_1gen_html_ad2b6d41a026aaee797e48d6e888f59b6"><div class="ttname"><a href="namespacefolly_1_1gen.html#ad2b6d41a026aaee797e48d6e888f59b6">folly::gen::as</a></div><div class="ttdeci">Collect as()</div><div class="ttdef"><b>Definition:</b> <a href="Base_8h_source.html#l00811">Base.h:811</a></div></div>
<div class="ttc" id="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_html_a068b1e6f8cd70e544be2f25f39632529"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a068b1e6f8cd70e544be2f25f39632529">folly::detail::distributed_mutex::DistributedMutex::state_</a></div><div class="ttdeci">Atomic&lt; std::uintptr_t &gt; state_</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex_8h_source.html#l00177">DistributedMutex.h:177</a></div></div>
<div class="ttc" id="namespacefolly_1_1futures_1_1detail_html_a65fc9bd92314712dac70f428f92f6d3eaf56ec2ab97d604832d90f6394e3f341f"><div class="ttname"><a href="namespacefolly_1_1futures_1_1detail.html#a65fc9bd92314712dac70f428f92f6d3eaf56ec2ab97d604832d90f6394e3f341f">folly::futures::detail::State::Proxy</a></div></div>
<div class="ttc" id="http__parser_8c_html_adc6e5733fc3c22f0a7b2914188c49c90"><div class="ttname"><a href="http__parser_8c.html#adc6e5733fc3c22f0a7b2914188c49c90">state</a></div><div class="ttdeci">state</div><div class="ttdef"><b>Definition:</b> <a href="http__parser_8c_source.html#l00272">http_parser.c:272</a></div></div>
<div class="ttc" id="namespacefolly_1_1detail_1_1distributed__mutex_html_a8b171e91ac5b735d4d270866d68d9458"><div class="ttname"><a href="namespacefolly_1_1detail_1_1distributed__mutex.html#a8b171e91ac5b735d4d270866d68d9458">folly::detail::distributed_mutex::timedLock</a></div><div class="ttdeci">auto timedLock(Atomic &amp;state, Deadline deadline, MakeProxy proxy)</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex-inl_8h_source.html#l00784">DistributedMutex-inl.h:784</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac64302904ce02bc0f284cff945ea4f87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class Atomic, bool Publish&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">folly::detail::distributed_mutex::DistributedMutex</a>&lt; Atomic, Publish &gt;::unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a>&lt; Atomic, TimePublishing &gt;::<a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutexStateProxy</a>&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlocks the mutex</p>
<p>The proxy returned by lock must be passed to unlock as an rvalue. No other option is possible here, since the proxy is only movable and not copyable </p>

<p>Definition at line <a class="el" href="DistributedMutex-inl_8h_source.html#l00705">705</a> of file <a class="el" href="DistributedMutex-inl_8h_source.html">DistributedMutex-inl.h</a>.</p>

<p>References <a class="el" href="DistributedMutex-inl_8h_source.html#l00342">folly::detail::distributed_mutex::doFutexWake()</a>, <a class="el" href="Utility_8h_source.html#l00120">folly::exchange()</a>, <a class="el" href="DistributedMutex-inl_8h_source.html#l00281">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;::DistributedMutexStateProxy&lt; Atomic, TimePublishing &gt;::expected_</a>, <a class="el" href="DistributedMutex-inl_8h_source.html#l00054">folly::detail::distributed_mutex::kLocked</a>, <a class="el" href="fizz_2build___2gtest_2src_2gtest_2googlemock_2scripts_2generator_2cpp_2ast_8py_source.html#l00058">cpp.ast::next()</a>, <a class="el" href="DistributedMutex-inl_8h_source.html#l00268">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;::DistributedMutexStateProxy&lt; Atomic, TimePublishing &gt;::next_</a>, <a class="el" href="DistributedMutex-inl_8h_source.html#l00301">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;::DistributedMutexStateProxy&lt; Atomic, TimePublishing &gt;::ready_</a>, <a class="el" href="DistributedMutex-inl_8h_source.html#l00437">folly::detail::distributed_mutex::recordTimedWaiterAndClearTimedBit()</a>, <a class="el" href="ScopeGuard_8h_source.html#l00274">SCOPE_EXIT</a>, <a class="el" href="DistributedMutex_8h_source.html#l00177">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;::state_</a>, <a class="el" href="DistributedMutex-inl_8h_source.html#l00289">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;::DistributedMutexStateProxy&lt; Atomic, TimePublishing &gt;::timedWaiters_</a>, <a class="el" href="DistributedMutex-inl_8h_source.html#l00677">folly::detail::distributed_mutex::tryUnlockClean()</a>, <a class="el" href="DistributedMutex-inl_8h_source.html#l00296">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;::DistributedMutexStateProxy&lt; Atomic, TimePublishing &gt;::waiters_</a>, <a class="el" href="DistributedMutex-inl_8h_source.html#l00642">folly::detail::distributed_mutex::wake()</a>, <a class="el" href="DistributedMutex-inl_8h_source.html#l00291">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;::DistributedMutexStateProxy&lt; Atomic, TimePublishing &gt;::wakerMetadata_</a>, and <a class="el" href="DistributedMutex-inl_8h_source.html#l00670">folly::detail::distributed_mutex::wakeTimedWaiters()</a>.</p>

<p>Referenced by <a class="el" href="SmallLocksBenchmark_8cpp_source.html#l00044">burn()</a>.</p>
<div class="fragment"><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;                                                      {</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;  <span class="comment">// we always wake up ready threads and timed waiters if we saw either</span></div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;  DCHECK(proxy) &lt;&lt; <span class="stringliteral">&quot;Invalid proxy passed to DistributedMutex::unlock()&quot;</span>;</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;  <a class="code" href="ScopeGuard_8h.html#a175c354c3e38222bc00ce5df5e6d431d">SCOPE_EXIT</a> {</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;    <a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#a3591c1ba613944ea2c74a0ff26c82591">doFutexWake</a>(proxy.ready_);</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;    <a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#aeadcd5df9d2d537b99e7fa8eeb71d76a">wakeTimedWaiters</a>(&amp;<a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a068b1e6f8cd70e544be2f25f39632529">state_</a>, proxy.timedWaiters_);</div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;  };</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;  <span class="comment">// if there is a wait queue we are responsible for, try and start wakeups,</span></div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;  <span class="comment">// don&#39;t bother with the mutex state</span></div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;  <span class="keyword">auto</span> sleepers = proxy.waiters_;</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;  <span class="keywordflow">if</span> (proxy.next_) {</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#a9469036a9940b67e660595c60062759c">wake</a>(Publish, *proxy.next_, proxy.wakerMetadata_, sleepers)) {</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;      <span class="keywordflow">return</span>;</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;    }</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;    <span class="comment">// At this point, if are in the if statement, we were not the terminal</span></div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;    <span class="comment">// node of the wakeup chain.  Terminal nodes have the next_ pointer set to</span></div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;    <span class="comment">// null in lock()</span></div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;    <span class="comment">// So we need to pretend we were the end of the contention chain.  Coming</span></div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;    <span class="comment">// out of a contention chain always has the kLocked state set in the</span></div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;    <span class="comment">// mutex.  Unless there is another contention chain lined up, which does</span></div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;    <span class="comment">// not matter since we are the terminal node anyway</span></div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;    proxy.expected_ = <a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#a70ac38c3aaa1e9d2ac764c5fac819abb">kLocked</a>;</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;  }</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;  <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;    <span class="comment">// otherwise, since we don&#39;t have anyone we need to wake up, we try and</span></div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;    <span class="comment">// release the mutex just as is</span></div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;    <span class="comment">// if this is successful, we can return, the unlock was successful, we have</span></div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;    <span class="comment">// committed a nice kUnlocked to the central storage, yay</span></div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#a92c3204b4a1a760cfd8c3d122130d403">tryUnlockClean</a>(<a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a068b1e6f8cd70e544be2f25f39632529">state_</a>, proxy, sleepers)) {</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;      <span class="keywordflow">return</span>;</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;    }</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;    <span class="comment">// here we have a contention chain built up on the mutex.  We grab the</span></div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;    <span class="comment">// wait queue and start executing wakeups.  We leave a locked bit on the</span></div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;    <span class="comment">// centralized storage and handoff control to the head of the queue</span></div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;    <span class="comment">// we use memory_order_acq_rel here because we want to see the</span></div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;    <span class="comment">// full well-initialized node that the other thread is waiting on</span></div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;    <span class="comment">// If we are unable to wake the contention chain, it is possible that when</span></div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;    <span class="comment">// we come back to looping here, a new contention chain will form.  In</span></div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;    <span class="comment">// that case we need to use kLocked as the waker_ value because the</span></div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;    <span class="comment">// terminal node of the new chain will see kLocked in the central storage</span></div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;    <span class="keyword">auto</span> head = <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a068b1e6f8cd70e544be2f25f39632529">state_</a>.exchange(<a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#a70ac38c3aaa1e9d2ac764c5fac819abb">kLocked</a>, std::memory_order_acq_rel);</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;    <a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#a36fff543f1be7027272969d8ee93bca9">recordTimedWaiterAndClearTimedBit</a>(proxy.timedWaiters_, head);</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;    <span class="keyword">auto</span> <a class="code" href="namespacecpp_1_1ast.html#a25bc7c34a56f66f8e68856ab63c7e990">next</a> = extractAddress&lt;CachelinePadded&lt;Waiter&lt;Atomic&gt;&gt;&gt;(head);</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;    DCHECK((head &amp; <a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#a70ac38c3aaa1e9d2ac764c5fac819abb">kLocked</a>) &amp;&amp; (head != kLocked)) &lt;&lt; <span class="stringliteral">&quot;incorrect state &quot;</span> &lt;&lt; head;</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacefolly_1_1detail_1_1distributed__mutex.html#a9469036a9940b67e660595c60062759c">wake</a>(Publish, *<a class="code" href="namespacecpp_1_1ast.html#a25bc7c34a56f66f8e68856ab63c7e990">next</a>, {<a class="code" href="namespacefolly.html#ab192e7aacc86b36de9b85fa7c16c3f5b">exchange</a>(proxy.expected_, kLocked)}, sleepers)) {</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;      <span class="keywordflow">break</span>;</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;    }</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;  }</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;}</div><div class="ttc" id="namespacefolly_1_1detail_1_1distributed__mutex_html_a9469036a9940b67e660595c60062759c"><div class="ttname"><a href="namespacefolly_1_1detail_1_1distributed__mutex.html#a9469036a9940b67e660595c60062759c">folly::detail::distributed_mutex::wake</a></div><div class="ttdeci">bool wake(bool publishing, Waiter &amp;waiter, WakerMetadata metadata, Waiter *&amp;sleepers)</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex-inl_8h_source.html#l00642">DistributedMutex-inl.h:642</a></div></div>
<div class="ttc" id="ScopeGuard_8h_html_a175c354c3e38222bc00ce5df5e6d431d"><div class="ttname"><a href="ScopeGuard_8h.html#a175c354c3e38222bc00ce5df5e6d431d">SCOPE_EXIT</a></div><div class="ttdeci">#define SCOPE_EXIT</div><div class="ttdef"><b>Definition:</b> <a href="ScopeGuard_8h_source.html#l00274">ScopeGuard.h:274</a></div></div>
<div class="ttc" id="namespacefolly_1_1detail_1_1distributed__mutex_html_a36fff543f1be7027272969d8ee93bca9"><div class="ttname"><a href="namespacefolly_1_1detail_1_1distributed__mutex.html#a36fff543f1be7027272969d8ee93bca9">folly::detail::distributed_mutex::recordTimedWaiterAndClearTimedBit</a></div><div class="ttdeci">void recordTimedWaiterAndClearTimedBit(bool &amp;timedWaiter, std::uintptr_t &amp;previous)</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex-inl_8h_source.html#l00437">DistributedMutex-inl.h:437</a></div></div>
<div class="ttc" id="namespacefolly_1_1detail_1_1distributed__mutex_html_aeadcd5df9d2d537b99e7fa8eeb71d76a"><div class="ttname"><a href="namespacefolly_1_1detail_1_1distributed__mutex.html#aeadcd5df9d2d537b99e7fa8eeb71d76a">folly::detail::distributed_mutex::wakeTimedWaiters</a></div><div class="ttdeci">void wakeTimedWaiters(Atomic *state, bool timedWaiters)</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex-inl_8h_source.html#l00670">DistributedMutex-inl.h:670</a></div></div>
<div class="ttc" id="namespacefolly_html_ab192e7aacc86b36de9b85fa7c16c3f5b"><div class="ttname"><a href="namespacefolly.html#ab192e7aacc86b36de9b85fa7c16c3f5b">folly::exchange</a></div><div class="ttdeci">T exchange(T &amp;obj, U &amp;&amp;new_value)</div><div class="ttdef"><b>Definition:</b> <a href="Utility_8h_source.html#l00120">Utility.h:120</a></div></div>
<div class="ttc" id="namespacefolly_1_1detail_1_1distributed__mutex_html_a92c3204b4a1a760cfd8c3d122130d403"><div class="ttname"><a href="namespacefolly_1_1detail_1_1distributed__mutex.html#a92c3204b4a1a760cfd8c3d122130d403">folly::detail::distributed_mutex::tryUnlockClean</a></div><div class="ttdeci">bool tryUnlockClean(Atomic &amp;state, Proxy &amp;proxy, Sleepers sleepers)</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex-inl_8h_source.html#l00677">DistributedMutex-inl.h:677</a></div></div>
<div class="ttc" id="namespacefolly_1_1detail_1_1distributed__mutex_html_a3591c1ba613944ea2c74a0ff26c82591"><div class="ttname"><a href="namespacefolly_1_1detail_1_1distributed__mutex.html#a3591c1ba613944ea2c74a0ff26c82591">folly::detail::distributed_mutex::doFutexWake</a></div><div class="ttdeci">void doFutexWake(Waiter *waiter)</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex-inl_8h_source.html#l00342">DistributedMutex-inl.h:342</a></div></div>
<div class="ttc" id="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_html_a068b1e6f8cd70e544be2f25f39632529"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a068b1e6f8cd70e544be2f25f39632529">folly::detail::distributed_mutex::DistributedMutex::state_</a></div><div class="ttdeci">Atomic&lt; std::uintptr_t &gt; state_</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex_8h_source.html#l00177">DistributedMutex.h:177</a></div></div>
<div class="ttc" id="namespacefolly_1_1detail_1_1distributed__mutex_html_a70ac38c3aaa1e9d2ac764c5fac819abb"><div class="ttname"><a href="namespacefolly_1_1detail_1_1distributed__mutex.html#a70ac38c3aaa1e9d2ac764c5fac819abb">folly::detail::distributed_mutex::kLocked</a></div><div class="ttdeci">constexpr auto kLocked</div><div class="ttdef"><b>Definition:</b> <a href="DistributedMutex-inl_8h_source.html#l00054">DistributedMutex-inl.h:54</a></div></div>
<div class="ttc" id="namespacecpp_1_1ast_html_a25bc7c34a56f66f8e68856ab63c7e990"><div class="ttname"><a href="namespacecpp_1_1ast.html#a25bc7c34a56f66f8e68856ab63c7e990">cpp.ast.next</a></div><div class="ttdeci">def next(obj)</div><div class="ttdef"><b>Definition:</b> <a href="fizz_2build___2gtest_2src_2gtest_2googlemock_2scripts_2generator_2cpp_2ast_8py_source.html#l00058">ast.py:58</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a068b1e6f8cd70e544be2f25f39632529"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class Atomic = std::atomic, bool TimePublishing = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Atomic&lt;std::uintptr_t&gt; <a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">folly::detail::distributed_mutex::DistributedMutex</a>&lt; Atomic, TimePublishing &gt;::state_ {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="DistributedMutex_8h_source.html#l00177">177</a> of file <a class="el" href="DistributedMutex_8h_source.html">DistributedMutex.h</a>.</p>

<p>Referenced by <a class="el" href="DistributedMutex-inl_8h_source.html#l00455">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;::lock()</a>, <a class="el" href="DistributedMutex-inl_8h_source.html#l00766">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;::try_lock()</a>, <a class="el" href="DistributedMutex-inl_8h_source.html#l00870">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;::try_lock_for()</a>, <a class="el" href="DistributedMutex-inl_8h_source.html#l00847">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;::try_lock_until()</a>, and <a class="el" href="DistributedMutex-inl_8h_source.html#l00705">folly::detail::distributed_mutex::DistributedMutex&lt; Atomic, TimePublishing &gt;::unlock()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>proxygen/folly/folly/synchronization/<a class="el" href="DistributedMutex_8h_source.html">DistributedMutex.h</a></li>
<li>proxygen/folly/folly/synchronization/<a class="el" href="DistributedMutex-inl_8h_source.html">DistributedMutex-inl.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefolly.html">folly</a></li><li class="navelem"><a class="el" href="namespacefolly_1_1detail.html">detail</a></li><li class="navelem"><a class="el" href="namespacefolly_1_1detail_1_1distributed__mutex.html">distributed_mutex</a></li><li class="navelem"><a class="el" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
