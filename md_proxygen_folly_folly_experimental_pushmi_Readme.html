<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: Pushmi</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_proxygen_folly_folly_experimental_pushmi_Readme.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Pushmi </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>pushing values around</h2>
<p>This library is counterpart to <a href="http://wg21.link/p1055r0">P1055 - <em>A Modest Executor Proposal</em></a>.</p>
<p><em>pushmi</em> is a header-only library that uses git submodules for dependencies (<code>git clone --recursive</code>), uses CMake to build, requires compliant C++14 compiler to build and has dependencies on meta and catch2 and some other libraries for testing and examples.</p>
<p><a href="https://godbolt.org/z/vCUK0M"></a></p>
<p><em>pushmi</em> is an implementation for prototyping how Futures, Executors can be defined with shared Concepts. These Concepts can be implemented over and over again to solve different problems and make different tradeoffs. User implementations of the Concepts are first-class citizens due to the attention to composition. Composition also enables each implementation of the Concepts to focus on one concern and then be composed to build more complex solutions.</p>
<h2>Build status</h2>
<p>Travis-CI: <a href="https://travis-ci.org/facebookresearch/pushmi"></a></p>
<h2>Callbacks</h2>
<p><em>Callbacks</em> are very familiar though they take many forms. It is precisely the multiplicity of forms that make Callbacks difficult to compose.</p>
<p><a class="el" href="structA.html">A</a> minimal callback might be passed some state. The state might include an error or might only be a result code. Maybe this is delivered as one parameter, or as many parameters. Maybe the Callback is called once, or many or even zero times.</p>
<p><em>Promises</em> provide a stable contract for Callbacks of a single result or error.</p>
<h2><code>std::promise&lt;&gt;</code></h2>
<p>The interface for <code>std::promise&lt;void&gt;</code> is fairly straightforward.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>promise&lt;void&gt; {</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespacefolly_1_1pushmi.html#aa31ba5f575014ec93a46c8433c913636">set_value</a>();</div><div class="line">  <span class="keywordtype">void</span> set_exception(std::exception_ptr);</div><div class="line"></div><div class="line">  future&lt;void&gt; get_future();</div><div class="line">};</div></div><!-- fragment --><p>usage is also simple, but a bit convoluted (the promise produces the future, has the result set_ function called, and only then is future::get called to get the result).</p>
<div class="fragment"><div class="line">std::promise&lt;void&gt; p;</div><div class="line"><span class="keyword">auto</span> f = p.get_future();</div><div class="line">p.set_value();</div><div class="line"><span class="comment">// or</span></div><div class="line"><span class="comment">// p.set_exception(std::exception_ptr{});</span></div><div class="line">f.get();</div></div><!-- fragment --><p>it is this convolution that creates the race between the producer and consumer that requires expensive internal state to resolve.</p>
<h2><code>receiver</code></h2>
<p>The <code>receiver</code> type in the library provides simple ways to construct new implementations of the Receiver concept.</p>
<p>construct a sink type that accepts any value or error type (and aborts on error)</p>
<div class="fragment"><div class="line">receiver&lt;&gt; <a class="code" href="StringKeyedBenchmark_8cpp.html#aa7f1a46e86fabf3df0ec876cd34220c2">s</a>;</div></div><!-- fragment --><p>construct new type using one or more lambdas, or with designated initializers, use multiple lambdas to build overload sets</p>
<div class="fragment"><div class="line"><span class="comment">// provide done</span></div><div class="line"><span class="keyword">auto</span> s0 = receiver{<a class="code" href="namespacefolly_1_1pushmi.html#a281347c2dcd815dfa96d171276384c85">on_done</a>{[](){}}};</div><div class="line"></div><div class="line"><span class="comment">// provide value</span></div><div class="line"><span class="keyword">auto</span> s1 = receiver{[](<span class="keyword">auto</span> <a class="code" href="ParallelBenchmark_8cpp.html#a62448945ba9492b4ac991254a7d267bb">v</a>){}};</div><div class="line"><span class="keyword">auto</span> s2 = receiver{<a class="code" href="namespacefolly_1_1pushmi.html#ab93e51aa7cce87dcd906ce0198b5f935">on_value</a>{[](int){}, [](<span class="keyword">auto</span> <a class="code" href="ParallelBenchmark_8cpp.html#a62448945ba9492b4ac991254a7d267bb">v</a>){}}};</div><div class="line"></div><div class="line"><span class="comment">// these are quite dangerous as they suppress errors</span></div><div class="line"></div><div class="line"><span class="comment">// provide error</span></div><div class="line"><span class="keyword">auto</span> s3 = receiver{[](<span class="keyword">auto</span> <a class="code" href="ParallelBenchmark_8cpp.html#a62448945ba9492b4ac991254a7d267bb">v</a>){}, [](std::exception_ptr){}, [](){}};</div><div class="line"><span class="keyword">auto</span> s4 = receiver{<a class="code" href="namespacefolly_1_1pushmi.html#a8c6827ff5ab3b42b5d5204a123ad0d1f">on_error</a>{[](std::exception_ptr){}}, <a class="code" href="namespacefolly_1_1pushmi.html#a281347c2dcd815dfa96d171276384c85">on_done</a>{[](){}}};</div><div class="line"><span class="keyword">auto</span> s5 = receiver{<a class="code" href="namespacefolly_1_1pushmi.html#a8c6827ff5ab3b42b5d5204a123ad0d1f">on_error</a>{[](std::exception_ptr){}, [](<span class="keyword">auto</span>){}}};</div><div class="line"><span class="keyword">auto</span> s6 = receiver{<a class="code" href="namespacefolly_1_1pushmi.html#a8c6827ff5ab3b42b5d5204a123ad0d1f">on_error</a>{[](std::exception_ptr){}}};</div></div><!-- fragment --><p>construct a new type with shared state across the lambdas. very useful for building a filter on top of an existing receiver. The state must be a Receiver, but can be a super-set with additional state for this filter.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> s0 = receiver{receiver{}};</div><div class="line"></div><div class="line"><span class="keyword">auto</span> s1 = receiver{receiver{}, <a class="code" href="namespacefolly_1_1pushmi.html#a281347c2dcd815dfa96d171276384c85">on_done</a>{</div><div class="line">    [](receiver&lt;&gt;&amp; out, std::exception_ptr <a class="code" href="namespacefolly_1_1pushmi_1_1extension__operators.html">ep</a>){out | <a class="code" href="namespacefolly_1_1pushmi.html#a210186e9d2183adba2b5f6533eb6c0a5">set_done</a>();}}};</div><div class="line"></div><div class="line"><span class="keyword">auto</span> s2 = receiver{receiver{},</div><div class="line">  [](receiver&lt;&gt;&amp; out, <span class="keyword">auto</span> <a class="code" href="ParallelBenchmark_8cpp.html#a62448945ba9492b4ac991254a7d267bb">v</a>){out | <a class="code" href="namespacefolly_1_1pushmi.html#aa31ba5f575014ec93a46c8433c913636">set_value</a>(<a class="code" href="namespacefolly_1_1pushmi.html">v</a>);};</div><div class="line"><span class="keyword">auto</span> s3 = receiver{receiver{}, <a class="code" href="namespacefolly_1_1pushmi.html#ab93e51aa7cce87dcd906ce0198b5f935">on_value</a>{</div><div class="line">  [](receiver&lt;&gt;&amp; out, <span class="keywordtype">int</span> <a class="code" href="ParallelBenchmark_8cpp.html#a62448945ba9492b4ac991254a7d267bb">v</a>){out | <a class="code" href="namespacefolly_1_1pushmi.html#aa31ba5f575014ec93a46c8433c913636">set_value</a>(<a class="code" href="namespacefolly_1_1pushmi.html">v</a>);},</div><div class="line">  [](receiver&lt;&gt;&amp; out, <span class="keyword">auto</span> <a class="code" href="ParallelBenchmark_8cpp.html#a62448945ba9492b4ac991254a7d267bb">v</a>){out | <a class="code" href="namespacefolly_1_1pushmi.html#aa31ba5f575014ec93a46c8433c913636">set_value</a>(<a class="code" href="namespacefolly_1_1pushmi.html">v</a>);}}};</div><div class="line"></div><div class="line"><span class="comment">// these are quite dangerous as they suppress errors</span></div><div class="line"><span class="keyword">auto</span> s4 = receiver{receiver{},</div><div class="line">  [](){}</div><div class="line">  [](receiver&lt;&gt;&amp; out, std::exception_ptr <a class="code" href="namespacefolly_1_1pushmi_1_1extension__operators.html">ep</a>){out | <a class="code" href="namespacefolly_1_1pushmi.html#a210186e9d2183adba2b5f6533eb6c0a5">set_done</a>();},</div><div class="line">  [](receiver&lt;&gt;&amp;){out | <a class="code" href="namespacefolly_1_1pushmi.html#a210186e9d2183adba2b5f6533eb6c0a5">set_done</a>();}};</div><div class="line"><span class="keyword">auto</span> s5 = receiver{receiver{}, <a class="code" href="namespacefolly_1_1pushmi.html#a8c6827ff5ab3b42b5d5204a123ad0d1f">on_error</a>{</div><div class="line">  [](receiver&lt;&gt;&amp; out, std::exception_ptr <a class="code" href="namespacefolly_1_1pushmi_1_1extension__operators.html">ep</a>){out | <a class="code" href="namespacefolly_1_1pushmi.html#a210186e9d2183adba2b5f6533eb6c0a5">set_done</a>();},</div><div class="line">  [](receiver&lt;&gt;&amp; out, <span class="keyword">auto</span> e){out | <a class="code" href="namespacefolly_1_1pushmi.html#a210186e9d2183adba2b5f6533eb6c0a5">set_done</a>();}}};</div></div><!-- fragment --><p>construct a type-erased type for a particular T &amp; E (each of which could be a std::variant of supported types). I have a plan to provide operators to collapse values and errors to variant or tuple and then expand from variant or tuple back to their constituent values/errors.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> s0 = any_receiver&lt;std::exception_ptr, int&gt;{receiver{}};</div><div class="line"><span class="keyword">auto</span> s1 = any_receiver&lt;std::exception_ptr, int&gt;{receiver{}};</div></div><!-- fragment --><h2><code>single_sender</code></h2>
<p>The <code>single_sender</code> type in the library provides simple ways to construct new implementations of the SingleSender concept.</p>
<p>construct a producer of nothing, aka <code>never()</code></p>
<div class="fragment"><div class="line">single_sender&lt;&gt; sd;</div></div><!-- fragment --><p>construct new type using one or more lambdas, or with designated initializers, use multiple lambdas to build overload sets</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> sd0 = single_sender{<a class="code" href="namespacefolly_1_1pushmi.html#a6d2897e7f54aabd9e7bcfae20ead63cd">on_submit</a>{[](<span class="keyword">auto</span> out){}}};</div><div class="line"><span class="keyword">auto</span> sd1 = single_sender{[](<span class="keyword">auto</span> out){}};</div><div class="line"><span class="keyword">auto</span> sd2 = single_sender{<a class="code" href="namespacefolly_1_1pushmi.html#a6d2897e7f54aabd9e7bcfae20ead63cd">on_submit</a>{[](receiver&lt;&gt; out){}, [](<span class="keyword">auto</span> out){}}};</div></div><!-- fragment --><p>construct a new type with shared state across the lambdas. very useful for building a filter on top of an existing single_sender. The state must be a SingleSender, but can be a super-set with additional state for this filter.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> sd0 = single_sender{single_sender{}};</div><div class="line"></div><div class="line"><span class="keyword">auto</span> sd1 = single_sender{single_sender{}, <a class="code" href="namespacefolly_1_1pushmi.html#a6d2897e7f54aabd9e7bcfae20ead63cd">on_submit</a>{</div><div class="line">    [](single_sender&lt;&gt;&amp; in, <span class="keyword">auto</span> out){in | <a class="code" href="PushmiBenchmarks_8cpp.html#aa30303f6b5a3a130a39cf0464abd760b">submit</a>(out);}}};</div><div class="line"></div><div class="line"><span class="keyword">auto</span> sd2 = single_sender{single_sender{},</div><div class="line">    [](single_sender&lt;&gt;&amp; in, <span class="keyword">auto</span> out){in | <a class="code" href="PushmiBenchmarks_8cpp.html#aa30303f6b5a3a130a39cf0464abd760b">submit</a>(out);}};</div></div><!-- fragment --><p>construct a type-erased type for a particular T &amp; E (which could be a std::variant of supported types). I have a plan to provide operators to collapse values and errors to variant or tuple and then expand from variant or tuple back to their constituent values/errors.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> sd0 = any_single_sender&lt;std::exception_ptr, int&gt;{single_sender{}};</div><div class="line"><span class="keyword">auto</span> sd1 = any_single_sender&lt;std::exception_ptr, int&gt;{single_sender{}};</div></div><!-- fragment --><h2><code>time_single_sender</code></h2>
<p>The <code>time_single_sender</code> type in the library provides simple ways to construct new implementations of the TimeSingleSender concept.</p>
<p>construct a producer of nothing, aka <code>never()</code></p>
<div class="fragment"><div class="line">time_single_sender&lt;&gt; tsd;</div></div><!-- fragment --><p>construct new type using one or more lambdas, or with designated initializers, use multiple lambdas to build overload sets</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> tsd0 = time_single_sender{<a class="code" href="namespacefolly_1_1pushmi.html#a6d2897e7f54aabd9e7bcfae20ead63cd">on_submit</a>{[](<span class="keyword">auto</span> at, <span class="keyword">auto</span> out){}}};</div><div class="line"><span class="keyword">auto</span> tsd1 = time_single_sender{[](<span class="keyword">auto</span> at, <span class="keyword">auto</span> out){}};</div><div class="line"><span class="keyword">auto</span> tsd2 = time_single_sender{<a class="code" href="namespacefolly_1_1pushmi.html#a6d2897e7f54aabd9e7bcfae20ead63cd">on_submit</a>{[](<span class="keyword">auto</span> at, receiver&lt;&gt; out){}, [](<span class="keyword">auto</span> at, <span class="keyword">auto</span> out){}}};</div></div><!-- fragment --><p>construct a new type with shared state across the lambdas. very useful for building a filter on top of an existing time_single_sender. The state must be a SingleSender, but can be a super-set with additional state for this filter.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> tsd0 = time_single_sender{single_sender{}};</div><div class="line"></div><div class="line"><span class="keyword">auto</span> tsd1 = time_single_sender{single_sender{}, <a class="code" href="namespacefolly_1_1pushmi.html#a6d2897e7f54aabd9e7bcfae20ead63cd">on_submit</a>{</div><div class="line">    [](time_single_sender&lt;&gt;&amp; in, <span class="keyword">auto</span> at, <span class="keyword">auto</span> out){in | <a class="code" href="PushmiBenchmarks_8cpp.html#aa30303f6b5a3a130a39cf0464abd760b">submit</a>(at, out);}}};</div><div class="line"></div><div class="line"><span class="keyword">auto</span> tsd2 = time_single_sender{single_sender{},</div><div class="line">    [](time_single_sender&lt;&gt;&amp; in, <span class="keyword">auto</span> at, <span class="keyword">auto</span> out){in | <a class="code" href="PushmiBenchmarks_8cpp.html#aa30303f6b5a3a130a39cf0464abd760b">submit</a>(at, out);}};</div></div><!-- fragment --><p>construct a type-erased type for a particular T &amp; E (which could be a std::variant of supported types). I have a plan to provide operators to collapse values and errors to variant or tuple and then expand from variant or tuple back to their constituent values/errors.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> tsd0 = any_time_single_sender&lt;std::exception_ptr, std::system_clock::time_point, int&gt;{time_single_sender{}};</div><div class="line"><span class="keyword">auto</span> tsd1 = any_time_single_sender&lt;std::exception_ptr, std::system_clock::time_point, int&gt;{time_single_sender{}};</div></div><!-- fragment --><h2>put it all together with some algorithms</h2>
<p><a href="https://godbolt.org/z/vCUK0M"></a></p>
<h3>Executor</h3>
<div class="fragment"><div class="line"><span class="keyword">auto</span> nt = <a class="code" href="namespacefolly_1_1pushmi.html#a27a9bd873ef85b688122c91f52a86ad6">new_thread</a>();</div><div class="line">nt | <a class="code" href="namespacefolly_1_1pushmi_1_1operators.html#aa461a510ef521dc64411067acb0eccff">blocking_submit</a>([](<span class="keyword">auto</span> nt){</div><div class="line">  nt |</div><div class="line">    <a class="code" href="namespacefolly_1_1pushmi_1_1operators.html#a34e10c98c0e93a61b44fe231558e7c6f">transform</a>([](<span class="keyword">auto</span> nt){ <span class="keywordflow">return</span> 42; }) | <a class="code" href="PushmiBenchmarks_8cpp.html#aa30303f6b5a3a130a39cf0464abd760b">submit</a>([](<span class="keywordtype">int</span>){}) |</div><div class="line">    <a class="code" href="namespacefolly_1_1pushmi_1_1operators.html#a34e10c98c0e93a61b44fe231558e7c6f">transform</a>([](<span class="keywordtype">int</span> fortyTwo){ <span class="keywordflow">return</span> <span class="stringliteral">&quot;42&quot;</span><a class="code" href="StringKeyedBenchmark_8cpp.html#aa7f1a46e86fabf3df0ec876cd34220c2">s</a>; }) | <a class="code" href="PushmiBenchmarks_8cpp.html#aa30303f6b5a3a130a39cf0464abd760b">submit</a>([](<a class="code" href="Conv_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>){});</div><div class="line">});</div></div><!-- fragment --><h3>Single</h3>
<div class="fragment"><div class="line"><span class="keyword">auto</span> fortyTwo = <a class="code" href="namespacefolly_1_1pushmi_1_1operators.html#a4c630848173faebd7713192756912933">just</a>(42) |</div><div class="line">  <a class="code" href="namespacefolly_1_1pushmi_1_1operators.html#a34e10c98c0e93a61b44fe231558e7c6f">transform</a>([](<span class="keyword">auto</span> <a class="code" href="namespacefolly_1_1pushmi.html">v</a>){ <span class="keywordflow">return</span> std::to_string(<a class="code" href="namespacefolly_1_1pushmi.html">v</a>); }) |</div><div class="line">  <a class="code" href="namespacefolly_1_1pushmi_1_1operators.html#a3d6588d393c51815f51c2bc8b475cde8">on</a>(<a class="code" href="namespacefolly_1_1pushmi.html#a27a9bd873ef85b688122c91f52a86ad6">new_thread</a>) |</div><div class="line">  <a class="code" href="namespacefolly_1_1pushmi_1_1operators.html#a3eb45e3f11bb2b9490f37bdaf7706bea">via</a>(<a class="code" href="namespacefolly_1_1pushmi.html#a27a9bd873ef85b688122c91f52a86ad6">new_thread</a>) |</div><div class="line">  get&lt;std::string&gt;;</div><div class="line"></div><div class="line"><a class="code" href="namespacefolly_1_1pushmi_1_1operators.html#a4c630848173faebd7713192756912933">just</a>(42) |</div><div class="line">    <a class="code" href="namespacefolly_1_1pushmi_1_1operators.html#a34e10c98c0e93a61b44fe231558e7c6f">transform</a>([](<span class="keyword">auto</span> <a class="code" href="namespacefolly_1_1pushmi.html">v</a>){ <span class="keywordflow">return</span> std::to_string(<a class="code" href="namespacefolly_1_1pushmi.html">v</a>); }) |</div><div class="line">    <a class="code" href="namespacefolly_1_1pushmi_1_1operators.html#a3d6588d393c51815f51c2bc8b475cde8">on</a>(<a class="code" href="namespacefolly_1_1pushmi.html#a27a9bd873ef85b688122c91f52a86ad6">new_thread</a>) |</div><div class="line">    <a class="code" href="namespacefolly_1_1pushmi_1_1operators.html#a3eb45e3f11bb2b9490f37bdaf7706bea">via</a>(<a class="code" href="namespacefolly_1_1pushmi.html#a27a9bd873ef85b688122c91f52a86ad6">new_thread</a>) |</div><div class="line">    <a class="code" href="namespacefolly_1_1pushmi_1_1operators.html#aa461a510ef521dc64411067acb0eccff">blocking_submit</a>([](<a class="code" href="Conv_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>){});</div></div><!-- fragment --><h3>Many</h3>
<p><a href="https://godbolt.org/z/woVAi9"></a></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code" href="PushmiBenchmarks_8cpp.html#a4e506a3ad8385688fda41fbd279ac064">values</a> = std::array&lt;int, 5&gt;{4, 20, 7, 3, 8};</div><div class="line"></div><div class="line"><span class="keyword">auto</span> f = <a class="code" href="namespacefolly_1_1pushmi_1_1operators.html#a66a275bf0c134161fd2050e9ec72a29d">op::from</a>(<a class="code" href="PushmiBenchmarks_8cpp.html#a4e506a3ad8385688fda41fbd279ac064">values</a>) |</div><div class="line">    <a class="code" href="PushmiBenchmarks_8cpp.html#aa30303f6b5a3a130a39cf0464abd760b">op::submit</a>([&amp;](<span class="keywordtype">int</span>){});</div></div><!-- fragment --><h3>FlowMany</h3>
<p><a href="https://godbolt.org/z/woVAi9"></a></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code" href="PushmiBenchmarks_8cpp.html#a4e506a3ad8385688fda41fbd279ac064">values</a> = std::array&lt;int, 5&gt;{4, 20, 7, 3, 8};</div><div class="line"></div><div class="line"><span class="keyword">auto</span> f = <a class="code" href="namespacefolly_1_1pushmi_1_1operators.html#a20aaa06e643f5c1fd8551756ff05e46d">op::flow_from</a>(<a class="code" href="PushmiBenchmarks_8cpp.html#a4e506a3ad8385688fda41fbd279ac064">values</a>) |</div><div class="line">    <a class="code" href="FunctionTest_8cpp.html#a2c4f29acec59b67a355f8a4c9575abe6">op::for_each</a>([&amp;](<span class="keywordtype">int</span>){});</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
