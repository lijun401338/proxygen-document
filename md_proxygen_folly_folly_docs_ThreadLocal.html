<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: `folly/ThreadLocal.h`</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_proxygen_folly_folly_docs_ThreadLocal.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">`folly/ThreadLocal.h` </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Improved thread local storage for non-trivial types.</p>
<ul>
<li>~4x faster than <code>boost::thread_specific_ptr</code>.</li>
<li>Similar speed as using <code>pthread_getspecific</code> directly, but only consumes a single <code>pthread_key_t</code> per <code>Tag</code> template param.</li>
<li>Expands on the <code>thread_specific_ptr</code> API with <code>accessAllThreads</code> and extended custom deleter support.</li>
</ul>
<h3>Usage</h3>
<hr/>
<p>The API of <code>ThreadLocalPtr</code> is very close to <code>boost::thread_specific_ptr</code> with the notable addition of the <code>accessAllThreads</code> method. There is also a <code>ThreadLocal</code> class which is a thin wrapper around <code>ThreadLocalPtr</code> that manages allocation automatically (creates a new object the first time it is dereferenced from each thread).</p>
<p><code>ThreadLocalPtr</code> simply gives you a place to put and access a pointer local to each thread such that it will be destroyed appropriately.</p>
<div class="fragment"><div class="line">{</div><div class="line">  <a class="code" href="classfolly_1_1ThreadLocalPtr.html">folly::ThreadLocalPtr&lt;Widget&gt;</a> w;</div><div class="line">  w.<a class="code" href="classfolly_1_1ThreadLocalPtr.html#aa93ea5964c574cefdd18b1439805e3f8">reset</a>(<span class="keyword">new</span> <a class="code" href="classWidget.html">Widget</a>(0), Widget::customDeleterA);</div><div class="line">  std::thread([&amp;w]() {</div><div class="line">    w.<a class="code" href="classfolly_1_1ThreadLocalPtr.html#aa93ea5964c574cefdd18b1439805e3f8">reset</a>(<span class="keyword">new</span> <a class="code" href="classWidget.html">Widget</a>(1), Widget::customDeleterB);</div><div class="line">    w.<a class="code" href="classfolly_1_1ThreadLocalPtr.html#a06d0ae17a194ab62b3db29a855a34865">get</a>()-&gt;mangleWidget();</div><div class="line">  } <span class="comment">// Widget(1) is destroyed with customDeleterB</span></div><div class="line">} <span class="comment">// Widget(0) is destroyed with customDeleterA</span></div></div><!-- fragment --><p>Note that <code>customDeleterB</code> will get called with <code>TLPDestructionMode::THIS_THREAD</code> and <code>customerDeleterA</code> will get called with <code>TLPDestructionMode::ALL_THREADS</code>. This is to distinguish between thread exit vs. the entire <code>ThreadLocalPtr</code> getting destroyed, in which case there is cleanup work that may be avoided.</p>
<p>The <code>accessAllThreads</code> interface is provided to walk all the thread local child objects of a parent. <code>accessAllThreads</code> initializes an accessor which holds a global lock that blocks all creation and destruction of <code>ThreadLocal</code> objects with the same <code>Tag</code> and can be used as an iterable container. Typical use is for frequent write, infrequent read data access patterns such as counters. Note that you must specify a unique Tag type so you don't block other ThreadLocal object usage, and you should try to minimize the lifetime of the accessor so the lock is held for as short as possible).</p>
<p>The following example is a simplification of <code>folly/ThreadCachedInt.h</code>. It keeps track of a counter value and allows multiple threads to add to the count without synchronization. In order to get the total count, <code><a class="el" href="namespacefizz_1_1detail.html#a36dc6280bf4d04bce115a7055a78abac">read()</a></code> iterates through all the thread local values via <code>accessAllThreads()</code> and sums them up. <code>class NewTag</code> is used to break the global mutex so that this class won't block other <code>ThreadLocal</code> usage when <code><a class="el" href="namespacefizz_1_1detail.html#a36dc6280bf4d04bce115a7055a78abac">read()</a></code> is called.</p>
<p>Note that <code><a class="el" href="namespacefizz_1_1detail.html#a36dc6280bf4d04bce115a7055a78abac">read()</a></code> holds the global mutex which blocks construction, destruction, and <code><a class="el" href="namespacefizz_1_1detail.html#a36dc6280bf4d04bce115a7055a78abac">read()</a></code> for other <code><a class="el" href="classSimpleThreadCachedInt.html">SimpleThreadCachedInt</a></code>'s, but does not block <code><a class="el" href="BaseTest_8cpp.html#a337f2c9ca92bb7df9d0625b9fe4ff2bc">add()</a></code>. Also, since it uses the unique <code>NewTag</code>, <code><a class="el" href="classSimpleThreadCachedInt.html">SimpleThreadCachedInt</a></code> does not affect other <code>ThreadLocal</code> usage.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SimpleThreadCachedInt {</div><div class="line"></div><div class="line">  <span class="keyword">class </span>NewTag;  <span class="comment">// Segments the global mutex</span></div><div class="line">  ThreadLocal&lt;int,NewTag&gt; <a class="code" href="classSimpleThreadCachedInt.html#ad5027a9810e4b21b3ca84e3e9c8703ae">val_</a>;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="BaseTest_8cpp.html#a337f2c9ca92bb7df9d0625b9fe4ff2bc">add</a>(<span class="keywordtype">int</span> <a class="code" href="String_8cpp.html#a3c8bc0bb4f045bfe78d1196cb786792c">val</a>) {</div><div class="line">    *val_ += <a class="code" href="String_8cpp.html#a3c8bc0bb4f045bfe78d1196cb786792c">val</a>;  <span class="comment">// operator*() gives a reference to the thread local instance</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> <a class="code" href="namespacefizz_1_1detail.html#a36dc6280bf4d04bce115a7055a78abac">read</a>() {</div><div class="line">    <span class="keywordtype">int</span> ret = 0;</div><div class="line">    <span class="comment">// accessAllThreads acquires the global lock</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a> : val_.accessAllThreads()) {</div><div class="line">      ret += <a class="code" href="fizz_2build___2gtest_2src_2gtest_2googletest_2test_2gtest__output__test__golden__lin_8txt.html#a7e98b8a17c0aad30ba64d47b74e2a6c1">i</a>;</div><div class="line">    }  <span class="comment">// Global lock is released on scope exit</span></div><div class="line">    <span class="keywordflow">return</span> ret;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><h3>Implementation</h3>
<hr/>
<p>We keep a <code>__thread</code> array of pointers to objects (<code>ThreadEntry::elements</code>) where each array has an index for each unique instance of the <code>ThreadLocalPtr</code> object. Each <code>ThreadLocalPtr</code> object has a unique id that is an index into these arrays so we can fetch the correct object from thread local storage very efficiently.</p>
<p>In order to prevent unbounded growth of the id space and thus huge <code>ThreadEntry::elements</code> arrays, for example due to continuous creation and destruction of <code>ThreadLocalPtr</code> objects, we keep track of all active instances by linking them together into a list. When an instance is destroyed we remove it from the chain and insert the id into <code>freeIds_</code> for reuse. These operations require a global mutex, but only happen at construction and destruction time. <code>accessAllThreads</code> also acquires this global mutex.</p>
<p>We use a single global <code>pthread_key_t</code> per <code>Tag</code> to manage object destruction and memory cleanup upon thread exit because there is a finite number of <code>pthread_key_t</code>'s available per machine. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
