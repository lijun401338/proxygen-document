<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: `folly/Poly.h`</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_proxygen_folly_folly_docs_Poly.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">`folly/Poly.h` </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><code>Poly</code> is a class template that makes it relatively easy to define a type-erasing polymorphic object wrapper.</p>
<h3>Type-erasure</h3>
<hr/>
<p><code>std::function</code> is one example of a type-erasing polymorphic object wrapper; <code><a class="el" href="classfolly_1_1exception__wrapper.html">folly::exception_wrapper</a></code> is another. Type-erasure is often used as an alternative to dynamic polymorphism via inheritance-based virtual dispatch. The distinguishing characteristic of type-erasing wrappers are:</p>
<ul>
<li><b>Duck typing:</b> Types do not need to inherit from an abstract base class in order to be assignable to a type-erasing wrapper; they merely need to satisfy a particular interface.</li>
<li><b>Value semantics:</b> Type-erasing wrappers are objects that can be passed around <em>by value</em>. This is in contrast to abstract base classes which must be passed by reference or by pointer or else suffer from <em>slicing</em>, which causes them to lose their polymorphic behaviors. Reference semantics make it difficult to reason locally about code.</li>
<li><b>Automatic memory management:</b> When dealing with inheritance-based dynamic polymorphism, it is often necessary to allocate and manage objects on the heap. This leads to a proliferation of <code><a class="el" href="classshared__ptr.html">shared_ptr</a></code>s and <code>unique_ptr</code>s in APIs, complicating their point-of-use. APIs that take type-erasing wrappers, on the other hand, can often store small objects in-situ, with no dynamic allocation. The memory management, if any, is handled for you, and leads to cleaner APIs: consumers of your API don't need to pass <code><a class="el" href="classshared__ptr.html">shared_ptr</a>&lt;AbstractBase&gt;</code>; they can simply pass any object that satisfies the interface you require. (<code>std::function</code> is a particularly compelling example of this benefit. Far worse would be an inheritance-based callable solution like <code><a class="el" href="classshared__ptr.html">shared_ptr</a>&lt;ICallable&lt;void(int)&gt;&gt;</code>. )</li>
</ul>
<h3>Examples: Defining a type-erasing function wrapper with <code><a class="el" href="structfolly_1_1Poly.html">folly::Poly</a></code></h3>
<hr/>
<p>Defining a polymorphic wrapper with <code>Poly</code> is a matter of defining two things:</p>
<ul>
<li>An <em>interface</em>, consisting of public member functions, and</li>
<li><a class="el" href="structA.html">A</a> <em>mapping</em> from a concrete type to a set of member function bindings.</li>
</ul>
<p>Below is a simple example program that defines a <code>drawable</code> wrapper for any type that provides a <code>draw</code> member function. (The details will be explained later.)</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// This example is an adaptation of one found in Louis Dionne&#39;s dyno library.</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#include &lt;folly/Poly.h&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;#include &lt;iostream&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;struct IDrawable {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  // Define the interface of something that can be drawn:</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  template &lt;class Base&gt; struct Interface : Base {</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    void draw(std::ostream&amp; out) const { folly::poly_call&lt;0&gt;(*this, out);}</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  };</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  // Define how concrete types can fulfill that interface (in C++17):</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  template &lt;class T&gt; using Members = folly::PolyMembers&lt;&amp;T::draw&gt;;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;};</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;// Define an object that can hold anything that can be drawn:</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;using drawable = folly::Poly&lt;IDrawable&gt;;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;struct Square {</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;  void draw(std::ostream&amp; out) const { out &lt;&lt; &quot;Square\n&quot;; }</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;};</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;struct Circle {</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  void draw(std::ostream&amp; out) const { out &lt;&lt; &quot;Circle\n&quot;; }</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;};</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;void f(drawable const&amp; d) {</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  d.draw(std::cout);</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;}</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;int main() {</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  f(Square{}); // prints Square</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  f(Circle{}); // prints Circle</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;}</div></div><!-- fragment --><p>The above program prints:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Square</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Circle</div></div><!-- fragment --><p>Here is another (heavily commented) example of a simple implementation of a <code>std::function</code>-like polymorphic wrapper. Its interface has only a single member function: <code>operator()</code></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// An interface for a callable object of a particular signature, Fun</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;// (most interfaces don&#39;t need to be templates, FWIW).</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;template &lt;class Fun&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;struct IFunction;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;template &lt;class R, class... As&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;struct IFunction&lt;R(As...)&gt; {</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  // An interface is defined as a nested class template called</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  // Interface that takes a single template parameter, Base, from</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  // which it inherits.</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  template &lt;class Base&gt;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  struct Interface : Base {</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    // The Interface has public member functions. These become the</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    // public interface of the resulting Poly instantiation.</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    // (Implementation note: Poly&lt;IFunction&lt;Sig&gt;&gt; will publicly</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    // inherit from this struct, which is what gives it the right</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    // member functions.)</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    R operator()(As... as) const {</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;      // The definition of each member function in your interface will</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;      // always consist of a single line dispatching to folly::poly_call&lt;N&gt;.</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;      // The &quot;N&quot; corresponds to the N-th member function in the</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;      // list of member function bindings, Members, defined below.</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;      // The first argument will always be *this, and the rest of the</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;      // arguments should simply forward (if necessary) the member</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;      // function&#39;s arguments.</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;      return static_cast&lt;R&gt;(</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;          folly::poly_call&lt;0&gt;(*this, std::forward&lt;As&gt;(as)...));</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    }</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  };</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  // The &quot;Members&quot; alias template is a comma-separated list of bound</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  // member functions for a given concrete type &quot;T&quot;. The</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  // &quot;FOLLY_POLY_MEMBERS&quot; macro accepts a comma-separated list, and the</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  // (optional) &quot;FOLLY_POLY_MEMBER&quot; macro lets you disambiguate overloads</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  // by explicitly specifying the function signature the target member</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  // function should have. In this case, we require &quot;T&quot; to have a</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  // function call operator with the signature `R(As...) const`.</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  //</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  // If you are using a C++17-compatible compiler, you can do away with</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  // the macros and write this as:</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  //</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;  //   template &lt;class T&gt;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  //   using Members =</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;  //       folly::PolyMembers&lt;folly::sig&lt;R(As...) const&gt;(&amp;T::operator())&gt;;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;  //</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;  // And since `folly::sig` is only needed for disambiguation in case of</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  // overloads, if you are not concerned about objects with overloaded</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;  // function call operators, it could be further simplified to:</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  //</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;  //   template &lt;class T&gt;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  //   using Members = folly::PolyMembers&lt;&amp;T::operator()&gt;;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  //</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  template &lt;class T&gt;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  using Members = FOLLY_POLY_MEMBERS(</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;      FOLLY_POLY_MEMBER(R(As...) const, &amp;T::operator()));</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;};</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;// Now that we have defined the interface, we can pass it to Poly to</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;// create our type-erasing wrapper:</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;template &lt;class Fun&gt;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;using Function = Poly&lt;IFunction&lt;Fun&gt;&gt;;</div></div><!-- fragment --><p>Given the above definition of <code><a class="el" href="classFunction.html" title="A polymorphic function wrapper that is not copyable and does not require the wrapped function to be c...">Function</a></code>, users can now initialize instances of (say) <code><a class="el" href="classFunction.html" title="A polymorphic function wrapper that is not copyable and does not require the wrapped function to be c...">Function</a>&lt;int(int, int)&gt;</code> with function objects like <code>std::plus&lt;int&gt;</code> and <code>std::multiplies&lt;int&gt;</code>, as below:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Function&lt;int(int, int)&gt; fun = std::plus&lt;int&gt;{};</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;assert(5 == fun(2, 3));</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;fun = std::multiplies&lt;int&gt;{};</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;assert(6 = fun(2, 3));</div></div><!-- fragment --><h3>Defining an interface with C++17</h3>
<hr/>
<p>With C++17, defining an interface to be used with <code>Poly</code> is fairly straightforward. As in the <code><a class="el" href="classFunction.html" title="A polymorphic function wrapper that is not copyable and does not require the wrapped function to be c...">Function</a></code> example above, there is a struct with a nested <code><a class="el" href="classInterface.html">Interface</a></code> class template and a nested <code>Members</code> alias template. No macros are needed with C++17.</p>
<p>Imagine we were defining something like a Java-style iterator. If we are using a C++17 compiler, our interface would look something like this:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;template &lt;class Value&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;struct IJavaIterator {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  template &lt;class Base&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  struct Interface : Base {</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    bool Done() const { return folly::poly_call&lt;0&gt;(*this); }</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    Value Current() const { return folly::poly_call&lt;1&gt;(*this); }</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    void Next() { folly::poly_call&lt;2&gt;(*this); }</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  };</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  // NOTE: This works in C++17 only:</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  template &lt;class T&gt;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  using Members = folly::PolyMembers&lt;&amp;T::Done, &amp;T::Current, &amp;T::Next&gt;;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;};</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;template &lt;class Value&gt;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;using JavaIterator = Poly&lt;IJavaIterator&lt;Value&gt;&gt;;</div></div><!-- fragment --><p>Given the above definition, <code>JavaIterator&lt;int&gt;</code> can be used to hold instances of any type that has <code>Done</code>, <code>Current</code>, and <code>Next</code> member functions with the correct (or compatible) signatures.</p>
<p>The presence of overloaded member functions complicates this picture. Often, property members are faked in C++ with <code>const</code> and non-<code>const</code> member function overloads, like in the interface specified below:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct IIntProperty {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  template &lt;class Base&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  struct Interface : Base {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    int Value() const { return folly::poly_call&lt;0&gt;(*this); }</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    void Value(int i) { folly::poly_call&lt;1&gt;(*this, i); }</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  };</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  // NOTE: This works in C++17 only:</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  template &lt;class T&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  using Members = folly::PolyMembers&lt;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    folly::sig&lt;int() const&gt;(&amp;T::Value),</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    folly::sig&lt;void(int)&gt;(&amp;T::Value)&gt;;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;};</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;using IntProperty = Poly&lt;IIntProperty&gt;;</div></div><!-- fragment --><p>Now, any object that has <code>Value</code> members of compatible signatures can be assigned to instances of <code>IntProperty</code> object. Note how <code><a class="el" href="namespacefolly.html#a846f42e996d3c9b0252f6cc3907bc08f">folly::sig</a></code> is used to disambiguate the overloads of <code>&amp;T::Value</code>.</p>
<h3>Defining an interface with C++14</h3>
<hr/>
<p>In C++14, the nice syntax above doesn't work, so we have to resort to macros. The two examples above would look like this:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;template &lt;class Value&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;struct IJavaIterator {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  template &lt;class Base&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  struct Interface : Base {</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    bool Done() const { return folly::poly_call&lt;0&gt;(*this); }</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    Value Current() const { return folly::poly_call&lt;1&gt;(*this); }</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    void Next() { folly::poly_call&lt;2&gt;(*this); }</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  };</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  // NOTE: This works in C++14 and C++17:</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  template &lt;class T&gt;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  using Members = FOLLY_POLY_MEMBERS(&amp;T::Done, &amp;T::Current, &amp;T::Next);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;};</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;template &lt;class Value&gt;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;using JavaIterator = Poly&lt;IJavaIterator&lt;Value&gt;&gt;;</div></div><!-- fragment --><p>and</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct IIntProperty {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  template &lt;class Base&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  struct Interface : Base {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    int Value() const { return folly::poly_call&lt;0&gt;(*this); }</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    void Value(int i) { return folly::poly_call&lt;1&gt;(*this, i); }</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  };</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  // NOTE: This works in C++14 and C++17:</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  template &lt;class T&gt;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  using Members = FOLLY_POLY_MEMBERS(</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    FOLLY_POLY_MEMBER(int() const, &amp;T::Value),</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    FOLLY_POLY_MEMBER(void(int), &amp;T::Value));</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;};</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;using IntProperty = Poly&lt;IIntProperty&gt;;</div></div><!-- fragment --><h3>Extending interfaces</h3>
<hr/>
<p>One typical advantage of inheritance-based solutions to runtime polymorphism is that one polymorphic interface could extend another through inheritance. The same can be accomplished with type-erasing polymorphic wrappers. In the <code>Poly</code> library, you can use <code><a class="el" href="structfolly_1_1PolyExtends.html">folly::PolyExtends</a></code> to say that one interface extends another.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct IFoo {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  template &lt;class Base&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  struct Interface : Base {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    void Foo() const { return folly::poly_call&lt;0&gt;(*this); }</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  };</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  template &lt;class T&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  using Members = FOLLY_POLY_MEMBERS(&amp;T::Foo);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;};</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;// The IFooBar interface extends the IFoo interface</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;struct IFooBar : PolyExtends&lt;IFoo&gt; {</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  template &lt;class Base&gt;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  struct Interface : Base {</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    void Bar() const { return folly::poly_call&lt;0&gt;(*this); }</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  };</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  template &lt;class T&gt;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;  using Members = FOLLY_POLY_MEMBERS(&amp;T::Bar);</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;};</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;using FooBar = Poly&lt;IFooBar&gt;;</div></div><!-- fragment --><p>Given the above definition, instances of type <code>FooBar</code> have both <code><a class="el" href="structFoo.html">Foo()</a></code> and <code><a class="el" href="structBar.html">Bar()</a></code> member functions.</p>
<p>The sensible conversions exist between a wrapped derived type and a wrapped base type. For instance, assuming <code>IDerived</code> extends <code>IBase</code> with <code>PolyExtends</code>:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Poly&lt;IDerived&gt; derived = ...;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Poly&lt;IBase&gt; base = derived; // This conversion is OK.</div></div><!-- fragment --><p>As you would expect, there is no conversion in the other direction, and at present there is no <code>Poly</code> equivalent to <code>dynamic_cast</code>.</p>
<h3>Type-erasing polymorphic reference wrappers</h3>
<hr/>
<p>Sometimes you don't need to own a copy of an object; a reference will do. For that you can use <code>Poly</code> to capture a <em>reference</em> to an object satisfying an interface rather than the whole object itself. The syntax is intuitive.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;int i = 42;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;// Capture a mutable reference to an object of any IRegular type:</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;Poly&lt;IRegular &amp;&gt; intRef = i;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;assert(42 == folly::poly_cast&lt;int&gt;(intRef));</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;// Assert that we captured the address of &quot;i&quot;:</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;assert(&amp;i == &amp;folly::poly_cast&lt;int&gt;(intRef));</div></div><!-- fragment --><p><a class="el" href="structA.html">A</a> reference-like <code>Poly</code> has a different interface than a value-like <code>Poly</code>. Rather than calling member functions with the <code>obj.fun()</code> syntax, you would use the <code>obj-&gt;<a class="el" href="BenchmarkTest_8cpp.html#ad6557b4a82b64d9dc4c4545ae55f1600">fun()</a></code> syntax. This is for the sake of <code>const</code>-correctness. For example, consider the code below:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct IFoo {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  template &lt;class Base&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  struct Interface {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    void Foo() { folly::poly_call&lt;0&gt;(*this); }</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  };</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  template &lt;class T&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  using Members = folly::PolyMembers&lt;&amp;T::Foo&gt;;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;};</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;struct SomeFoo {</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  void Foo() { std::printf(&quot;SomeFoo::Foo\n&quot;); }</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;};</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;SomeFoo foo;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;Poly&lt;IFoo &amp;&gt; const anyFoo = foo;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;anyFoo-&gt;Foo(); // prints &quot;SomeFoo::Foo&quot;</div></div><!-- fragment --><p>Notice in the above code that the <code><a class="el" href="structFoo.html">Foo</a></code> member function is non-<code>const</code>. Notice also that the <code>anyFoo</code> object is <code>const</code>. However, since it has captured a non-<code>const</code> reference to the <code>foo</code> object, it should still be possible to dispatch to the non-<code>const</code> <code><a class="el" href="structFoo.html">Foo</a></code> member function. When instantiated with a reference type, <code>Poly</code> has an overloaded <code>operator-&gt;</code> member that returns a pointer to the <code>IFoo</code> interface with the correct <code>const</code>-ness, which makes this work.</p>
<p>The same mechanism also prevents users from calling non-<code>const</code> member functions on <code>Poly</code> objects that have captured <code>const</code> references, which would violate <code>const</code>-correctness.</p>
<p>Sensible conversions exist between non-reference and reference <code>Poly</code>s. For instance:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Poly&lt;IRegular&gt; value = 42;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Poly&lt;IRegular &amp;&gt; mutable_ref = value;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Poly&lt;IRegular const &amp;&gt; const_ref = mutable_ref;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;assert(&amp;poly_cast&lt;int&gt;(value) == &amp;poly_cast&lt;int&gt;(mutable_ref));</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;assert(&amp;poly_cast&lt;int&gt;(value) == &amp;poly_cast&lt;int&gt;(const_ref));</div></div><!-- fragment --><h3>Non-member functions (C++17)</h3>
<hr/>
<p>If you wanted to write the interface <code>ILogicallyNegatable</code>, which captures all types that can be negated with unary <code>operator!</code>, you could do it as we've shown above, by binding <code>&amp;T::operator!</code> in the nested <code>Members</code> alias template, but that has the problem that it won't work for types that have defined unary <code>operator!</code> as a free function. To handle this case, the <code>Poly</code> library lets you use a free function instead of a member function when creating a binding.</p>
<p>With C++17 you may use a lambda to create a binding, as shown in the example below:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct ILogicallyNegatable {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  template &lt;class Base&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  struct Interface : Base {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    bool operator!() const { return folly::poly_call&lt;0&gt;(*this); }</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  };</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  template &lt;class T&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  using Members = folly::PolyMembers&lt;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    +[](T const&amp; t) -&gt; decltype(bool(!t)) { return bool(!t); }&gt;;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;};</div></div><!-- fragment --><p>This requires some explanation. The unary <code>operator+</code> in front of the lambda is necessary! It causes the lambda to decay to a C-style function pointer, which is one of the types that <code><a class="el" href="namespacefolly.html#a6ee904f3631e2c5dcb03a52ccfbe031b">folly::PolyMembers</a></code> accepts. The <code>decltype</code> in the lambda return type is also necessary. Through the magic of SFINAE, it will cause <code>Poly&lt;ILogicallyNegatable&gt;</code> to reject any types that don't support unary <code>operator!</code>.</p>
<p>If you are using a free function to create a binding, the first parameter is implicitly the <code>this</code> parameter. It will receive the type-erased object.</p>
<h3>Non-member functions (C++14)</h3>
<hr/>
<p>If you are using a C++14 compiler, the definition of <code>ILogicallyNegatable</code> above will fail because lambdas are not <code>constexpr</code>. We can get the same effect by writing the lambda as a named free function, as show below:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct ILogicallyNegatable {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  template &lt;class Base&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  struct Interface : Base {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    bool operator!() const { return folly::poly_call&lt;0&gt;(*this); }</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  };</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  template &lt;class T&gt;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  static auto negate(T const&amp; t)</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    -&gt; decltype(bool(!t)) { return bool(!t); }</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  template &lt;class T&gt;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  using Members = FOLLY_POLY_MEMBERS(&amp;negate&lt;T&gt;);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;};</div></div><!-- fragment --><p>As with the example that uses the lambda in the preceding section, the first parameter is implicitly the <code>this</code> parameter. It will receive the type-erased object.</p>
<h3>Multi-dispatch</h3>
<hr/>
<p>What if you want to create an <code>IAddable</code> interface for things that can be added? Adding requires <em>two</em> objects, both of which are type-erased. This interface requires dispatching on both objects, doing the addition only if the types are the same. For this we make use of the <code>PolySelf</code> template alias to define an interface that takes more than one object of the the erased type.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct IAddable {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  template &lt;class Base&gt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  struct Interface : Base {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    friend PolySelf&lt;Base&gt;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    operator+(PolySelf&lt;Base&gt; const&amp; a, PolySelf&lt;Base&gt; const&amp; b) const {</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;      return folly::poly_call&lt;0&gt;(a, b);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    }</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  };</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  template &lt;class T&gt;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  using Members = folly::PolyMembers&lt;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    +[](T const&amp; a, T const&amp; b) -&gt; decltype(a + b) { return a + b; }&gt;;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;};</div></div><!-- fragment --><p>Given the above definition of <code>IAddable</code> we would be able to do the following:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Poly&lt;IAddable&gt; a = 2, b = 3;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Poly&lt;IAddable&gt; c = a + b;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;assert(poly_cast&lt;int&gt;(c) == 5);</div></div><!-- fragment --><p>If <code>a</code> and <code>b</code> stored objects of different types, a <code>BadPolyCast</code> exception would be thrown.</p>
<h3>Move-only types</h3>
<hr/>
<p>If you want to store move-only types, then your interface should extend the <code>poly::IMoveOnly</code> interface.</p>
<h3>Implementation notes</h3>
<hr/>
<p><code>Poly</code> will store "small" objects in an internal buffer, avoiding the cost of of dynamic allocations. At present, this size is not configurable; it is pegged at the size of two <code>double</code>s.</p>
<p><code>Poly</code> objects are always nothrow movable. If you store an object in one that has a potentially throwing move constructor, the object will be stored on the heap, even if it could fit in the internal storage of the <code>Poly</code> object. (So be sure to give your objects nothrow move constructors!)</p>
<p><code>Poly</code> implements type-erasure in a manner very similar to how the compiler accomplishes virtual dispatch. Every <code>Poly</code> object contains a pointer to a table of function pointers. Member function calls involve a double- indirection: once through the v-pointer, and other indirect function call through the function pointer. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
