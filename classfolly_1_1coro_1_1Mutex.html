<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: folly::coro::Mutex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classfolly_1_1coro_1_1Mutex.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classfolly_1_1coro_1_1Mutex-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">folly::coro::Mutex Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Mutex_8h_source.html">Mutex.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1coro_1_1Mutex_1_1LockOperation.html">LockOperation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1coro_1_1Mutex_1_1ScopedLockOperation.html">ScopedLockOperation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a554c06cfad5525e3a59246cd6192dab8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1coro_1_1Mutex.html#a554c06cfad5525e3a59246cd6192dab8">Mutex</a> () noexcept</td></tr>
<tr class="memdesc:a554c06cfad5525e3a59246cd6192dab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new async mutex that is initially unlocked.  <a href="#a554c06cfad5525e3a59246cd6192dab8">More...</a><br /></td></tr>
<tr class="separator:a554c06cfad5525e3a59246cd6192dab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bafa8ac4ff2e6c3ecbe7294a469aaf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1coro_1_1Mutex.html#ad3bafa8ac4ff2e6c3ecbe7294a469aaf">Mutex</a> (const <a class="el" href="classfolly_1_1coro_1_1Mutex.html">Mutex</a> &amp;)=delete</td></tr>
<tr class="separator:ad3bafa8ac4ff2e6c3ecbe7294a469aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e2ecba753b6c897310b086bc814e5c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1coro_1_1Mutex.html#ab0e2ecba753b6c897310b086bc814e5c">Mutex</a> (<a class="el" href="classfolly_1_1coro_1_1Mutex.html">Mutex</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ab0e2ecba753b6c897310b086bc814e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e365679acfd0a863962a4cfde6e2e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfolly_1_1coro_1_1Mutex.html">Mutex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1coro_1_1Mutex.html#ab2e365679acfd0a863962a4cfde6e2e7">operator=</a> (const <a class="el" href="classfolly_1_1coro_1_1Mutex.html">Mutex</a> &amp;)=delete</td></tr>
<tr class="separator:ab2e365679acfd0a863962a4cfde6e2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af879f3fefab9e18c4fc16e1410d017a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfolly_1_1coro_1_1Mutex.html">Mutex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1coro_1_1Mutex.html#af879f3fefab9e18c4fc16e1410d017a5">operator=</a> (<a class="el" href="classfolly_1_1coro_1_1Mutex.html">Mutex</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:af879f3fefab9e18c4fc16e1410d017a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa31724db3b265a517a5553182c969d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1coro_1_1Mutex.html#aaa31724db3b265a517a5553182c969d8">~Mutex</a> ()</td></tr>
<tr class="separator:aaa31724db3b265a517a5553182c969d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb013536804fae03ad581a1d7079b3e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1coro_1_1Mutex.html#acb013536804fae03ad581a1d7079b3e6">try_lock</a> () noexcept</td></tr>
<tr class="separator:acb013536804fae03ad581a1d7079b3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79522466ceb8c871dea7e95e5713ab3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfolly_1_1coro_1_1Mutex_1_1ScopedLockOperation.html">ScopedLockOperation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1coro_1_1Mutex.html#a79522466ceb8c871dea7e95e5713ab3d">co_scoped_lock</a> () noexcept</td></tr>
<tr class="separator:a79522466ceb8c871dea7e95e5713ab3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f77ea82f7140622c74682280721896"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfolly_1_1coro_1_1Mutex_1_1LockOperation.html">LockOperation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1coro_1_1Mutex.html#a55f77ea82f7140622c74682280721896">co_lock</a> () noexcept</td></tr>
<tr class="separator:a55f77ea82f7140622c74682280721896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed614869b0ef277c71289c3403d82f15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1coro_1_1Mutex.html#aed614869b0ef277c71289c3403d82f15">unlock</a> () noexcept</td></tr>
<tr class="separator:aed614869b0ef277c71289c3403d82f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:af5696131f7f77e286eb5767119ad7a65"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1coro_1_1Mutex.html#af5696131f7f77e286eb5767119ad7a65">unlockedState</a> () noexcept</td></tr>
<tr class="separator:af5696131f7f77e286eb5767119ad7a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f313ad99dcc1c910dfec71d05f0954"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1coro_1_1Mutex.html#a16f313ad99dcc1c910dfec71d05f0954">lockAsyncImpl</a> (<a class="el" href="classfolly_1_1coro_1_1Mutex_1_1LockOperation.html">LockOperation</a> *awaiter)</td></tr>
<tr class="separator:a16f313ad99dcc1c910dfec71d05f0954"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a77602ac19291317d685027f8ddd4e594"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; void * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1coro_1_1Mutex.html#a77602ac19291317d685027f8ddd4e594">state_</a></td></tr>
<tr class="separator:a77602ac19291317d685027f8ddd4e594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bf1b10147ca6089d24a298349d3c2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfolly_1_1coro_1_1Mutex_1_1LockOperation.html">LockOperation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1coro_1_1Mutex.html#a84bf1b10147ca6089d24a298349d3c2b">waiters_</a></td></tr>
<tr class="separator:a84bf1b10147ca6089d24a298349d3c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6a5f0c24b30d10591f1b603fae6ff40b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfolly_1_1coro_1_1Mutex.html#a6a5f0c24b30d10591f1b603fae6ff40b">LockOperation</a></td></tr>
<tr class="separator:a6a5f0c24b30d10591f1b603fae6ff40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="structA.html">A</a> mutex that can be locked asynchronously using 'co_await'.</p>
<p>Ownership of the mutex is not tied to any particular thread. This allows the coroutine owning the lock to transition from one thread to another while holding the lock and then perform the <a class="el" href="classfolly_1_1coro_1_1Mutex.html#aed614869b0ef277c71289c3403d82f15">unlock()</a> operation on another thread.</p>
<p>This mutex guarantees a FIFO scheduling algorithm - coroutines acquire the lock in the order that they execute the 'co_await mutex.lockAsync()' operation.</p>
<p>Note that you cannot use std::scoped_lock/std::lock_guard to acquire the lock as the lock must be acquired with use of 'co_await' which cannot be used in a constructor.</p>
<p>You can still use the std::scoped_lock/std::lock_guard in conjunction with std::adopt_lock to automatically unlock the mutex when the current scope exits after having locked the mutex using either co_await m.lock_async() or <a class="el" href="classfolly_1_1coro_1_1Mutex.html#acb013536804fae03ad581a1d7079b3e6">try_lock()</a> .</p>
<p>You can also attempt to acquire the lock using std::unique_lock in conjunction with std::try_to_lock.</p>
<p>For example: <a class="el" href="classfolly_1_1coro_1_1Mutex.html">folly::coro::Mutex</a> m; <a class="el" href="classfolly_1_1Executor.html">folly::Executor</a>&amp; executor;</p>
<p>folly::coro::Task&lt;&gt; asyncScopedLockExample() { std::unique_lock&lt;folly::coro::Mutex&gt; lock{co_await m.co_scoped_lock()}; ... }</p>
<p>folly::coro::Task&lt;&gt; asyncManualLockAndUnlock() { co_await m.co_lock(executor); ... m.unlock(); }</p>
<p>void nonAsyncTryLock() { if (m.try_lock()) { // Once the lock is acquired you can pass ownership of the lock to // a std::lock_guard object. std::lock_guard&lt;folly::coro::Mutex&gt; lock{m, std::adopt_lock}; ... } }</p>
<p>void nonAsyncScopedTryLock() { std::unique_lock&lt;folly::coro::Mutex&gt; lock{m, std::try_to_lock}; if (lock) { ... } } </p>

<p>Definition at line <a class="el" href="Mutex_8h_source.html#l00084">84</a> of file <a class="el" href="Mutex_8h_source.html">Mutex.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a554c06cfad5525e3a59246cd6192dab8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">folly::coro::Mutex::Mutex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new async mutex that is initially unlocked. </p>

<p>Definition at line <a class="el" href="Mutex_8h_source.html#l00090">90</a> of file <a class="el" href="Mutex_8h_source.html">Mutex.h</a>.</p>

<p>References <a class="el" href="classfolly_1_1coro_1_1Mutex.html#ab2e365679acfd0a863962a4cfde6e2e7">operator=()</a>, and <a class="el" href="classfolly_1_1coro_1_1Mutex.html#aaa31724db3b265a517a5553182c969d8">~Mutex()</a>.</p>
<div class="fragment"><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;: <a class="code" href="classfolly_1_1coro_1_1Mutex.html#a77602ac19291317d685027f8ddd4e594">state_</a>(<a class="code" href="classfolly_1_1coro_1_1Mutex.html#af5696131f7f77e286eb5767119ad7a65">unlockedState</a>()), <a class="code" href="classfolly_1_1coro_1_1Mutex.html#a84bf1b10147ca6089d24a298349d3c2b">waiters_</a>(<span class="keyword">nullptr</span>) {}</div><div class="ttc" id="classfolly_1_1coro_1_1Mutex_html_a77602ac19291317d685027f8ddd4e594"><div class="ttname"><a href="classfolly_1_1coro_1_1Mutex.html#a77602ac19291317d685027f8ddd4e594">folly::coro::Mutex::state_</a></div><div class="ttdeci">std::atomic&lt; void * &gt; state_</div><div class="ttdef"><b>Definition:</b> <a href="Mutex_8h_source.html#l00210">Mutex.h:210</a></div></div>
<div class="ttc" id="classfolly_1_1coro_1_1Mutex_html_a84bf1b10147ca6089d24a298349d3c2b"><div class="ttname"><a href="classfolly_1_1coro_1_1Mutex.html#a84bf1b10147ca6089d24a298349d3c2b">folly::coro::Mutex::waiters_</a></div><div class="ttdeci">LockOperation * waiters_</div><div class="ttdef"><b>Definition:</b> <a href="Mutex_8h_source.html#l00214">Mutex.h:214</a></div></div>
<div class="ttc" id="classfolly_1_1coro_1_1Mutex_html_af5696131f7f77e286eb5767119ad7a65"><div class="ttname"><a href="classfolly_1_1coro_1_1Mutex.html#af5696131f7f77e286eb5767119ad7a65">folly::coro::Mutex::unlockedState</a></div><div class="ttdeci">void * unlockedState() noexcept</div><div class="ttdef"><b>Definition:</b> <a href="Mutex_8h_source.html#l00192">Mutex.h:192</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad3bafa8ac4ff2e6c3ecbe7294a469aaf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">folly::coro::Mutex::Mutex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfolly_1_1coro_1_1Mutex.html">Mutex</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab0e2ecba753b6c897310b086bc814e5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">folly::coro::Mutex::Mutex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfolly_1_1coro_1_1Mutex.html">Mutex</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaa31724db3b265a517a5553182c969d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">folly::coro::Mutex::~Mutex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="Mutex_8h_source.html#l00090">Mutex()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a55f77ea82f7140622c74682280721896"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfolly_1_1coro_1_1Mutex_1_1LockOperation.html">Mutex::LockOperation</a> folly::coro::Mutex::co_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lock the mutex asynchronously.</p>
<p>You must co_await the return value to wait until the lock is acquired.</p>
<p>Chain a call to .<a class="el" href="namespacefolly.html#ad8577f68fd0aaeeb5a563c9cb8fe0d49">via()</a> to specify the executor to resume on when the lock is eventually acquired in the case that the lock could not be acquired synchronously. The awaiting coroutine will continue without suspending if the lock could be acquired synchronously.</p>
<p>Once the 'co_await m.lockAsync()' operation completes, the awaiting coroutine is responsible for ensuring that .<a class="el" href="classfolly_1_1coro_1_1Mutex.html#aed614869b0ef277c71289c3403d82f15">unlock()</a> is called to release the lock.</p>
<p>Consider using scopedLockAsync() instead to obtain a std::scoped_lock that handles releasing the lock at the end of the scope. </p>

<p>Definition at line <a class="el" href="Mutex_8h_source.html#l00221">221</a> of file <a class="el" href="Mutex_8h_source.html">Mutex.h</a>.</p>

<p>Referenced by <a class="el" href="Mutex_8h_source.html#l00106">try_lock()</a>.</p>
<div class="fragment"><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;                                                  {</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classfolly_1_1coro_1_1Mutex.html#a6a5f0c24b30d10591f1b603fae6ff40b">LockOperation</a>{*<span class="keyword">this</span>};</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;}</div><div class="ttc" id="classfolly_1_1coro_1_1Mutex_html_a6a5f0c24b30d10591f1b603fae6ff40b"><div class="ttname"><a href="classfolly_1_1coro_1_1Mutex.html#a6a5f0c24b30d10591f1b603fae6ff40b">folly::coro::Mutex::LockOperation</a></div><div class="ttdeci">friend class LockOperation</div><div class="ttdef"><b>Definition:</b> <a href="Mutex_8h_source.html#l00189">Mutex.h:189</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a79522466ceb8c871dea7e95e5713ab3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfolly_1_1coro_1_1Mutex_1_1ScopedLockOperation.html">Mutex::ScopedLockOperation</a> folly::coro::Mutex::co_scoped_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lock the mutex asynchronously, returning an RAII object that will release the lock at the end of the scope.</p>
<p>You must co_await the return value to wait until the lock is acquired.</p>
<p>Chain a call to .<a class="el" href="namespacefolly.html#ad8577f68fd0aaeeb5a563c9cb8fe0d49">via()</a> to specify the executor to resume on when the lock is eventually acquired in the case that the lock could not be acquired synchronously. The awaiting coroutine will continue without suspending if the lock could be acquired synchronously.</p>
<p>If you do not specify an executor by calling .<a class="el" href="namespacefolly.html#ad8577f68fd0aaeeb5a563c9cb8fe0d49">via()</a> then the inline executor is used and the awaiting coroutine is resumed inline inside the call to .<a class="el" href="classfolly_1_1coro_1_1Mutex.html#aed614869b0ef277c71289c3403d82f15">unlock()</a> by the previous lock holder. </p>

<p>Definition at line <a class="el" href="Mutex_8h_source.html#l00217">217</a> of file <a class="el" href="Mutex_8h_source.html">Mutex.h</a>.</p>

<p>Referenced by <a class="el" href="Mutex_8h_source.html#l00106">try_lock()</a>.</p>
<div class="fragment"><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;                                                               {</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;  <span class="keywordflow">return</span> ScopedLockOperation{*<span class="keyword">this</span>};</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a16f313ad99dcc1c910dfec71d05f0954"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool folly::coro::Mutex::lockAsyncImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfolly_1_1coro_1_1Mutex_1_1LockOperation.html">LockOperation</a> *&#160;</td>
          <td class="paramname"><em>awaiter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="Mutex_8h_source.html#l00160">folly::coro::Mutex::LockOperation::await_suspend()</a>, and <a class="el" href="Mutex_8h_source.html#l00192">unlockedState()</a>.</p>

</div>
</div>
<a class="anchor" id="ab2e365679acfd0a863962a4cfde6e2e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfolly_1_1coro_1_1Mutex.html">Mutex</a>&amp; folly::coro::Mutex::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfolly_1_1coro_1_1Mutex.html">Mutex</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="Mutex_8h_source.html#l00090">Mutex()</a>.</p>

</div>
</div>
<a class="anchor" id="af879f3fefab9e18c4fc16e1410d017a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfolly_1_1coro_1_1Mutex.html">Mutex</a>&amp; folly::coro::Mutex::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfolly_1_1coro_1_1Mutex.html">Mutex</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acb013536804fae03ad581a1d7079b3e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool folly::coro::Mutex::try_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classfolly_1_1Try.html">Try</a> to lock the mutex synchronously.</p>
<p>Returns true if the lock was able to be acquired synchronously, false if the lock could not be acquired because it was already locked.</p>
<p>If this method returns true then the caller is responsible for ensuring that <a class="el" href="classfolly_1_1coro_1_1Mutex.html#aed614869b0ef277c71289c3403d82f15">unlock()</a> is called to release the lock. </p>

<p>Definition at line <a class="el" href="Mutex_8h_source.html#l00106">106</a> of file <a class="el" href="Mutex_8h_source.html">Mutex.h</a>.</p>

<p>References <a class="el" href="Mutex_8h_source.html#l00221">co_lock()</a>, <a class="el" href="Mutex_8h_source.html#l00217">co_scoped_lock()</a>, <a class="el" href="extension__points_8h_source.html#l00040">folly::pushmi::__adl::noexcept()</a>, <a class="el" href="Mutex_8h_source.html#l00210">state_</a>, <a class="el" href="classfolly_1_1coro_1_1Mutex.html#aed614869b0ef277c71289c3403d82f15">unlock()</a>, and <a class="el" href="Mutex_8h_source.html#l00192">unlockedState()</a>.</p>

<p>Referenced by <a class="el" href="Mutex_8h_source.html#l00156">folly::coro::Mutex::LockOperation::await_ready()</a>.</p>
<div class="fragment"><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;                           {</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="keywordtype">void</span>* oldValue = <a class="code" href="classfolly_1_1coro_1_1Mutex.html#af5696131f7f77e286eb5767119ad7a65">unlockedState</a>();</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classfolly_1_1coro_1_1Mutex.html#a77602ac19291317d685027f8ddd4e594">state_</a>.compare_exchange_strong(</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        oldValue,</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        <span class="keyword">nullptr</span>,</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        std::memory_order_acquire,</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        std::memory_order_relaxed);</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  }</div><div class="ttc" id="classfolly_1_1coro_1_1Mutex_html_a77602ac19291317d685027f8ddd4e594"><div class="ttname"><a href="classfolly_1_1coro_1_1Mutex.html#a77602ac19291317d685027f8ddd4e594">folly::coro::Mutex::state_</a></div><div class="ttdeci">std::atomic&lt; void * &gt; state_</div><div class="ttdef"><b>Definition:</b> <a href="Mutex_8h_source.html#l00210">Mutex.h:210</a></div></div>
<div class="ttc" id="classfolly_1_1coro_1_1Mutex_html_af5696131f7f77e286eb5767119ad7a65"><div class="ttname"><a href="classfolly_1_1coro_1_1Mutex.html#af5696131f7f77e286eb5767119ad7a65">folly::coro::Mutex::unlockedState</a></div><div class="ttdeci">void * unlockedState() noexcept</div><div class="ttdef"><b>Definition:</b> <a href="Mutex_8h_source.html#l00192">Mutex.h:192</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aed614869b0ef277c71289c3403d82f15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void folly::coro::Mutex::unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unlock the mutex.</p>
<p>If there are other coroutines waiting to lock the mutex then this will schedule the resumption of the next coroutine in the queue. </p>

<p>Referenced by <a class="el" href="Mutex_8h_source.html#l00106">try_lock()</a>.</p>

</div>
</div>
<a class="anchor" id="af5696131f7f77e286eb5767119ad7a65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* folly::coro::Mutex::unlockedState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Mutex_8h_source.html#l00192">192</a> of file <a class="el" href="Mutex_8h_source.html">Mutex.h</a>.</p>

<p>References <a class="el" href="classfolly_1_1coro_1_1Mutex.html#a16f313ad99dcc1c910dfec71d05f0954">lockAsyncImpl()</a>.</p>

<p>Referenced by <a class="el" href="Mutex_8h_source.html#l00106">try_lock()</a>.</p>
<div class="fragment"><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;                                 {</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a6a5f0c24b30d10591f1b603fae6ff40b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classfolly_1_1coro_1_1Mutex_1_1LockOperation.html">LockOperation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Mutex_8h_source.html#l00189">189</a> of file <a class="el" href="Mutex_8h_source.html">Mutex.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a77602ac19291317d685027f8ddd4e594"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;void*&gt; folly::coro::Mutex::state_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Mutex_8h_source.html#l00210">210</a> of file <a class="el" href="Mutex_8h_source.html">Mutex.h</a>.</p>

<p>Referenced by <a class="el" href="Mutex_8h_source.html#l00106">try_lock()</a>.</p>

</div>
</div>
<a class="anchor" id="a84bf1b10147ca6089d24a298349d3c2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfolly_1_1coro_1_1Mutex_1_1LockOperation.html">LockOperation</a>* folly::coro::Mutex::waiters_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="Mutex_8h_source.html#l00214">214</a> of file <a class="el" href="Mutex_8h_source.html">Mutex.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>proxygen/folly/folly/experimental/coro/<a class="el" href="Mutex_8h_source.html">Mutex.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefolly.html">folly</a></li><li class="navelem"><a class="el" href="namespacefolly_1_1coro.html">coro</a></li><li class="navelem"><a class="el" href="classfolly_1_1coro_1_1Mutex.html">Mutex</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
